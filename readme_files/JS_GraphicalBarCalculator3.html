<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			div.SmallFont {
				font-size: 11px;
			}
			
			div.StatisticsTable {
				max-width:900px;
			}
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
			
			
			img.img-hor {
				-moz-transform: scaleX(-1);
				-o-transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
				transform: scaleX(-1);
				filter: FlipH;
				-ms-filter: "FlipH";
			}
			img.img-rot {
				/* upwards bar */
				transform: rotate(-90deg)
			}
			img.img-downwardsbar {
				/* it performs the transforms right-to-left*/
				transform: scaleY(-1) rotate(-90deg);
			}
			label { display: block; }
.noselect {
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
}
.ClickHoldChangeNumber {
	cursor: ew-resize
}
	input[type='text'] { font-family: monospace;}
	input[type='number'] { font-family: monospace;}
		</style>
	</head>
<a href="../GraphicalBar_ReadmeDocumentation.html#TopJSLink">Back to top</a><br>
<a href="../GraphicalBar_ReadmeDocumentation.html#ComputeGraphicalBarData">Back to info table</a><br>
<a href="DoubleBarInfo.html#DoubleBarSG">Back to Double bar information</a><br><br>
<p>This javascript HTML file simulates the subroutine <kbd>DrawGraphicalBar</kbd> and <kbd>DrawGraphicalBarSubtractionLoopEdition</kbd>.</p>
Notes:<br>
<ul>
<li>The screen is 256 by 224 pixels, therefore when dealing with 8x8 tiles, the number of 8x8s to fill the entire width or height would be 32 tiles wide 28 tiles tall.</li>
<li>The tile display is only available using default number of pieces or zero for left end, middle, and right end, this is because there are way too many different configurations for me to draw every tile.</li>
<li>When using a vertical bar on a stripe image, the tile data write is the same way as horizontal bar using the <kbd>[TTTTTTTT, YXPCCCTT]</kbd> format, ignoring the header and the terminating byte.</li>
</ul>
<table>
	<tr>
		<td>Fill amount</td>
		<td><input type="number" data-radix="10" min="0" max="65535" data-min="0" data-max="65535" value="0" id="Input_FillAmount"> $<input type="text" data-radix="16" data-padlength="4" data-min="0" data-max="65535" value="0000"><button>Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td>Number of pieces for left end</td>
		<td><input type="number" data-radix="10" min="0" max="255" data-min="0" data-max="255" value="3" id="Input_LeftPiece"> $<input type="text" data-radix="16" data-padlength="2" data-min="0" data-max="255" value="03"><button>Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td>Number of pieces for each middle</td>
		<td><input type="number" data-radix="10" min="0" max="255" data-min="0" data-max="255" value="8" id="Input_MiddlePiece"> $<input type="text" data-radix="16" data-padlength="2" data-min="0" data-max="255" value="08"><button>Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td>Number of pieces for right end</td>
		<td><input type="number" data-radix="10" min="0" max="255" data-min="0" data-max="255" value="3" id="Input_RightPiece"> $<input type="text" data-radix="16" data-padlength="2" data-min="0" data-max="255" value="03"><button>Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td>Number of middle tiles</td>
		<td><input type="number" data-radix="10" min="0" max="255" data-min="0" data-max="255" value="7" id="Input_MiddleLength"> $<input type="text" data-radix="16" data-padlength="2" data-min="0" data-max="255" value="07"><button>Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td>Using double bar?</td>
		<td><label><input type="checkbox" id="ToggleDoubleBar" onchange="MainCode()"></label></td>
	</tr>
	<tr>
		<td><kbd>!Setting_GraphicalBar_SecondFillByteTableOffset</kbd></td>
		<td><input type="number" data-radix="10" min="0" max="257"  data-min="0" data-max="257" value="32" id="Input_DoubleBarAddressOffset" class="DoubleBarRelated"> $<input type="text" data-radix="16" data-padlength="2" data-min="0" data-max="257" value="20" class="DoubleBarRelated"><button class="DoubleBarRelated">Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> location</td>
		<td>
			$<input type="text" data-radix="16" value="7F844A" id="GraphicalBar_TileAddressLocation" list="BarTileTableRAMList"><button>Click & hold to adjust</button>
			<datalist id="BarTileTableRAMList">
				<option value="7F844A">Default LoROM</option>
				<option value="400198">SA-1</option>
			</datalist>
		</td>
	</tr>
	<tr>
		<td>Write your tiles at:</td>
		<td>
			$<input type="text" data-radix="16" value="7FA000" id="StatusBarAddressToWrite" list="StatusBarRAMTileList"><button>Click & hold to adjust</button>
			<datalist id="StatusBarRAMTileList">
				<option value="7E0F09">SMW's status bar (Writes over “TIME”)</option>
				<option value="7FA000">Super status bar </option>
				<option value="404000">Super status bar (SA-1)</option>
				<option value="7FA03E">Super status bar (Top right corner)</option>
				<option value="40403E">Super status bar (SA-1, top right corner)</option>
				<option value="7FEC00">Overworld border plus</option>
				<option value="41EC00">Overworld border plus (SA-1)</option>
			</datalist>
		</td>
	</tr>
	<tr>
		<td>Status bar tile format</td>
		<td>
			<select onchange="MainCode()">
				<option id="StatusBarFormat_2" selected>Interleaved [TT, PP, TT, PP,...]</option>
				<option id="StatusBarFormat_1">2 Seperate tables [TT, TT, TT,...][PP, PP, PP,...]</option>
			</select>
		</td>
	</tr>
	<tr>
		<td>Fill Direction</td>
		<td>
			<select onchange="MainCode()">
				<option id="FillDirection_Right" selected>Right</option>
				<option id="FillDirection_Left">Left</option>
				<option id="FillDirection_Up">Up</option>
				<option id="FillDirection_Down">Down</option>
			</select>
		</td>
	</tr>
	<tr>
		<td>Using <kbd>BarExtendLeft</kbd>? (Only applies to horizontal bars and not using stripe)</td>
		<td><label><input type="checkbox" onchange="MainCode()" id="BarExtendLeft"></label></td>
	</tr>
	<tr>
		<td>Using static end tiles?</td>
		<td>
			<div><label><input type="checkbox" onchange="MainCode();" id="UsingStatic_LeftSide"> (&ldquo;left side&rdquo; for horizontal bars, whatever top or bottom the fill starts at for vertical)</label></div>
			<div><label><input type="checkbox" onchange="MainCode();" id="UsingStatic_RightSide">  (&ldquo;right side&rdquo; for horizontal bars, whatever top or bottom the fill ends at for vertical)</label></div>
		</td>
	</tr>
</table>
<hr>
<div id="OutputInfo">
	<table>
		<tr>
			<td style="font-family: monospace">Total bytes used for fill table</td>
			<td style="font-family: monospace" id="Output_TileTableSizeAndRange"></td>
		</tr>
		<tr>
			<td style="font-family: monospace">Total bytes used for fill table for double bar</td>
			<td style="font-family: monospace" ><span id="Output_TileTableSizeAndRangeDoubleBar"></span> <span id="Output_SecondBarOverlap" style="color: red"></span></td>
		</tr>
		<tr>
			<td style="font-family: monospace">Total bar pieces</td>
			<td style="font-family: monospace" id="Output_TotalBarPieces"></td>
		</tr>
		<tr>
			<td style="font-family: monospace"><kbd>DrawGraphicalBarSubtractionLoopEdition</kbd> remaining fill</td>
			<td style="font-family: monospace" id="Output_RemainingFill"></td>
		</tr>
		<tr>
			<td style="font-family: monospace">Static left end address:</td>
			<td style="font-family: monospace" id="Output_StaticLeftAddr"></td>
		</tr>
		<tr>
			<td style="font-family: monospace">Static right end address:</td>
			<td style="font-family: monospace" id="Output_StaticRightAddr"></td>
		</tr>
	</table><br>
	<div>
		<button title="For Address tracker&apos; auto-assigner" onclick="CopyRAMUsage()">Get autoassigner data</button>
		<span></span>
	</div><br>
	<table>
		<tr>
			<td>
				<div style="width: 800px; height: 300px; overflow: auto; border: 1px solid white;">
					<table id="Output_ByteLayout"></table>
				</div>
			</td>
			<td>
				<div style="width: 800px; height: 300px; overflow: auto; border: 1px solid white;" id="ImgPreview">
				
				</div>
			</td>
		</tr>
	</table>

</div>
<div id="OutputError" hidden><span style="font-family: monospace; color: #ff0000">Error! Not a single byte used.</span></div>

<script>
	let TotalGraphicalBarTableLength = 0n
	let MouseDownClickPos = {
		x: 0,
		y: 0,
		moveByX: 0,
		moveByY: 0,
		PlacedState: false,
		OriginalNumber: 0n
	}
	let ElementToAdjust = null
	window.addEventListener(
		"load",
		function () {
			[...document.querySelectorAll("input")].forEach(ele => { //Add up/down triggers
				if (ele.type == "text"||ele.type == "number") {
					AddInputNumberTriggers(ele)
				}
				if (ele.type == "text") {
					UpDownArrowTriggers(ele)
				}
			});
			[...document.querySelectorAll("button")].filter(btn => { //move mouse to adjust
				return btn.textContent == "Click & hold to adjust"
			}).forEach(ele => {
				ele.addEventListener(
					"mousedown",
					function (e) {
						e.preventDefault()
						if (e.button != 0) {
							return
						}
						MouseDownClickPos.x = e.pageX
						MouseDownClickPos.y = e.pageY
						MouseDownClickPos.moveByX = e.pageX - MouseDownClickPos.x
						MouseDownClickPos.moveByY = e.pageY - MouseDownClickPos.y
						MouseDownClickPos.PlacedState = true
						
						try {
							ElementToAdjust = e.target.parentNode.querySelector("input")
							OriginalNumber = ParseBigIntValue(ElementToAdjust.value, parseInt(ElementToAdjust.dataset.radix))
						} catch {
							ElementToAdjust = null
						}
					}
				)
			})
			document.addEventListener(
				"mouseup",
				function (e) {
					MouseDownClickPos.PlacedState = false
				}
			)
			document.addEventListener(
				"mousemove",
				function (e) {
					if (MouseDownClickPos.PlacedState) {
						MouseDownClickPos.moveByX = e.pageX - MouseDownClickPos.x
						MouseDownClickPos.moveByY = e.pageY - MouseDownClickPos.y
						if (ElementToAdjust != null) {
							ElementToAdjust.value = (OriginalNumber + BigInt(Math.round(MouseDownClickPos.moveByX/8))).toString(ElementToAdjust.dataset.radix)
							UpdateOtherInputs(ElementToAdjust)
						}
					}
				}
			
			)
			MainCode()
		}
	)
	function AddInputNumberTriggers(ele) {
		ele.addEventListener(
			"change",
			function () {
				UpdateOtherInputs(ele)
			}.bind(null, ele)
		)
	}
	function UpDownArrowTriggers(ele) {
		ele.addEventListener(
			"keydown",
			function (e) {
				let KeyName = e.key
				if (/(ArrowDown|ArrowUp)/.test(KeyName)) {
					e.preventDefault()
					let IncrementDecrement = 1n
					if (KeyName == "ArrowDown") {
						IncrementDecrement *= -1n
					}
					let EnteredNumber = ParseBigIntValue(e.target.value, parseInt(e.target.dataset.radix)) + IncrementDecrement
					event.target.value = (EnteredNumber.toString(parseInt(e.target.dataset.radix))).toUpperCase()
					
					let a = 0
					UpdateOtherInputs(e.target)
					
				}
			}
		)
	}
	function CopyRAMUsage() {
		let IsUsingDoubleBar = 1n
		if (document.getElementById("ToggleDoubleBar").checked) {
			IsUsingDoubleBar = 2n
		}
	
		let FreeramAutoAssignerText = ""
		FreeramAutoAssignerText += "Graphical Bar\t!Scratchram_GraphicalBar_LeftEndPiece\t1\t-\t-\n"
		FreeramAutoAssignerText += "Graphical Bar\t!Scratchram_GraphicalBar_MiddlePiece\t1\t-\t-\n"
		FreeramAutoAssignerText += "Graphical Bar\t!Scratchram_GraphicalBar_RightEndPiece\t1\t-\t-\n"
		FreeramAutoAssignerText += "Graphical Bar\t!Scratchram_GraphicalBar_TempLength\t1\t-\t-\n"
		FreeramAutoAssignerText += "Graphical Bar\t!Scratchram_GraphicalBar_FillByteTbl\t" + (TotalGraphicalBarTableLength*IsUsingDoubleBar) + "\t-\t-"
		setClipboard(FreeramAutoAssignerText)
	}
	function HandleMouseMovementToNumberInput(e) {
		let ElementToAdjust = MouseDrag.ElementClicked.parentNode.querySelector("input")
		let NumberValue = ParseBigIntValue(ElementToAdjust.value, ElementToAdjust.dataset.radix)
		NumberValue += BigInt(Math.floor(MouseDrag.DraggedByX/8))
		ElementToAdjust.value = NumberValue.toString(ElementToAdjust.dataset.radix)
		UpdateOtherInputs(e.parentNode.querySelector("input"))
	}
	
	function MainCode() {
		let IsDoubleBarEnabled = document.getElementById("ToggleDoubleBar").checked;
		[...document.querySelectorAll("*.DoubleBarRelated")].forEach(ele => ele.disabled = !IsDoubleBarEnabled);
		let StatusBarByteFormat = 1n
		if (document.getElementById("StatusBarFormat_2").selected) {
			StatusBarByteFormat = 2n
		}
		let IsTwoBarsConflicting = false
		
		let Input_FillAmount =              ParseBigIntValue(document.getElementById("Input_FillAmount").value)
		let Input_LeftPiece =               ParseBigIntValue(document.getElementById("Input_LeftPiece").value)
		let Input_MiddlePiece =             ParseBigIntValue(document.getElementById("Input_MiddlePiece").value)
		let Input_RightPiece =              ParseBigIntValue(document.getElementById("Input_RightPiece").value)
		let Input_MiddleLength =            ParseBigIntValue(document.getElementById("Input_MiddleLength").value)
		let Input_DoubleBarAddressOffset =  ParseBigIntValue(document.getElementById("Input_DoubleBarAddressOffset").value)
		let Input_TileByteTableAddress =    ParseBigIntValue(document.getElementById("GraphicalBar_TileAddressLocation").value, 16)
		let Input_StatusbarAddressToWrite = ParseBigIntValue(document.getElementById("StatusBarAddressToWrite").value, 16)
		
		let DoubleBar_TileByteTableAddress = Input_TileByteTableAddress+Input_DoubleBarAddressOffset
		let DoubleBar_TileByteTableAddress_Ending = DoubleBar_TileByteTableAddress+TotalGraphicalBarTableLength-1n
		
		let NumberOf_LeftByte = 0n
		if (Input_LeftPiece != 0n) {
			NumberOf_LeftByte = 1n
		}
		let NumberOf_MiddleByte = 0n
		if (Input_MiddleLength * Input_MiddlePiece != 0n) {
			NumberOf_MiddleByte = Input_MiddleLength
		}
		let NumberOf_RightByte = 0n
		if (Input_RightPiece != 0n) {
			NumberOf_RightByte = 1n
		}
		TotalGraphicalBarTableLength = NumberOf_LeftByte+NumberOf_MiddleByte+NumberOf_RightByte
		if (TotalGraphicalBarTableLength == 0n) {
			document.getElementById("OutputInfo").hidden = true
			document.getElementById("OutputError").hidden = false
			return
		}
		
		document.getElementById("OutputInfo").hidden = false
		document.getElementById("OutputError").hidden = true
		let BarMaxTotalPieces = Input_LeftPiece + (Input_MiddleLength * Input_MiddlePiece) + Input_RightPiece
		
		let Input_TileByteTableAddress_Ending = Input_TileByteTableAddress+TotalGraphicalBarTableLength-1n
		
		document.getElementById("Output_TileTableSizeAndRange").textContent = TotalGraphicalBarTableLength.toString(10) + " (" + BigIntToStringSignedHex(Input_TileByteTableAddress) + " ~ " + BigIntToStringSignedHex(Input_TileByteTableAddress_Ending) + ")"
		document.getElementById("Output_TileTableSizeAndRangeDoubleBar").textContent = "N/A"
		if (IsDoubleBarEnabled) {
			document.getElementById("Output_TileTableSizeAndRangeDoubleBar").textContent = TotalGraphicalBarTableLength.toString(10) + " (" + BigIntToStringSignedHex(DoubleBar_TileByteTableAddress) + " ~ " + BigIntToStringSignedHex(DoubleBar_TileByteTableAddress_Ending) + ")"
		}
		document.getElementById("Output_TotalBarPieces").textContent = BarMaxTotalPieces.toString(10) + " ($" + BarMaxTotalPieces.toString(16).toUpperCase().padStart(4, "0") + ")"
		
		document.getElementById("BarExtendLeft").disabled = false
		if (document.getElementById("FillDirection_Up").selected||document.getElementById("FillDirection_Down").selected) {
			document.getElementById("BarExtendLeft").disabled = true
		}
		
		//Clear table
			let OutputByteTable = document.getElementById("Output_ByteLayout")
			while (OutputByteTable.lastElementChild) {
				OutputByteTable.removeChild(OutputByteTable.lastElementChild)
			}
			let ImagePreview = document.getElementById("ImgPreview")
			while (ImagePreview.lastElementChild) {
				ImagePreview.removeChild(ImagePreview.lastElementChild)
			}
		//Table header
			let OutputByteTable_HeaderRow = document.createElement("tr")
			
			let OutputByteTable_TableHeader_FillByteTable = document.createElement("th")
			OutputByteTable_TableHeader_FillByteTable.style.fontFamily = "monospace"
			OutputByteTable_TableHeader_FillByteTable.appendChild(document.createTextNode("!Scratchram_GraphicalBar_FillByteTbl"))
			OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_FillByteTable)
			
			if (document.getElementById("ToggleDoubleBar").checked) {
				let OutputByteTable_TableHeader_SecondFillByteTable = document.createElement("th")
				OutputByteTable_TableHeader_SecondFillByteTable.appendChild(document.createTextNode("Second bar location"))
				OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_SecondFillByteTable)
			}
			
			let OutputByteTable_TableHeader_FillAmount = document.createElement("th")
			OutputByteTable_TableHeader_FillAmount.appendChild(document.createTextNode("Fill amount"))
			OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_FillAmount)
			
			let OutputByteTable_TableHeader_FillMax = document.createElement("th")
			OutputByteTable_TableHeader_FillMax.appendChild(document.createTextNode("Maximum fill"))
			OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_FillMax)
			
			let OutputByteTable_TableHeader_ByteType = document.createElement("th")
			OutputByteTable_TableHeader_ByteType.appendChild(document.createTextNode("Byte type"))
			OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_ByteType)
			
			let OutputByteTable_TableHeader_StatusBarWriteLocation = document.createElement("th")
			OutputByteTable_TableHeader_StatusBarWriteLocation.appendChild(document.createTextNode("Written to"))
			OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_StatusBarWriteLocation)
			
			OutputByteTable.appendChild(OutputByteTable_HeaderRow)
		//Graphical bar bytes
			let GraphicalBarBytes = []
			GraphicalBarBytes.length = 257
			GraphicalBarBytes.fill(0n)
			let GraphicalBarBytes_Index = 0n
			let IsEmptyNonFraction = false
			let CurrentStatusBarAddress = Input_StatusbarAddressToWrite
			if (document.getElementById("FillDirection_Left").selected) {
				CurrentStatusBarAddress += (TotalGraphicalBarTableLength-1n)*StatusBarByteFormat
			}
			if (document.getElementById("BarExtendLeft").checked && (document.getElementById("FillDirection_Left").selected||document.getElementById("FillDirection_Right").selected)) {
				CurrentStatusBarAddress += -(TotalGraphicalBarTableLength-1n)*StatusBarByteFormat
			}
			let PreviewAvailable = (() => {
				if (!(Input_LeftPiece == 0n||Input_LeftPiece == 3n)) {
					return false
				}
				if (!(Input_MiddlePiece == 0n||Input_MiddlePiece == 8n)) {
					return false
				}
				if (!(Input_RightPiece == 0n||Input_RightPiece == 3n)) {
					return false
				}
				return true
			})();
			
			//Declare functions
				function GenerateTableRow(Maximum, ByteType, MiddleLeft) {
					let NamesToColors = {
						"Left": "Cyan",
						"Middle": "#00FF00",
						"Right": "Red"
					}
					let TableRow_ByteInfoRow = document.createElement("tr")
					
					let TableRow_ByteInfo_GraphicalBarByte = document.createElement("td")
					TableRow_ByteInfo_GraphicalBarByte.style.fontFamily = "monospace"
					let Text_Address = BigIntToStringSignedHex(Input_TileByteTableAddress+GraphicalBarBytes_Index)
					let CurrentFillByte = Input_TileByteTableAddress+GraphicalBarBytes_Index
					if ((CurrentFillByte >= DoubleBar_TileByteTableAddress && CurrentFillByte <= DoubleBar_TileByteTableAddress_Ending)&&document.getElementById("ToggleDoubleBar").checked) {
						Text_Address += " Overlaps with second bar!"
						TableRow_ByteInfo_GraphicalBarByte.style.color = "red"
						IsTwoBarsConflicting = true
					}
					TableRow_ByteInfo_GraphicalBarByte.appendChild(document.createTextNode(Text_Address))
					TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_GraphicalBarByte)
					
					if (document.getElementById("ToggleDoubleBar").checked) {
						let TableRow_ByteInfo_GraphicalBarByte_SecondBar = document.createElement("td")
						TableRow_ByteInfo_GraphicalBarByte_SecondBar.style.fontFamily = "monospace"
						let SecondBarCurrentFillByte = Input_TileByteTableAddress+Input_DoubleBarAddressOffset+GraphicalBarBytes_Index
						let Text_Address_SecondBar = BigIntToStringSignedHex(SecondBarCurrentFillByte)
						if (SecondBarCurrentFillByte >= Input_TileByteTableAddress && SecondBarCurrentFillByte <= Input_TileByteTableAddress_Ending) {
							Text_Address_SecondBar += " Overlaps with first bar!"
							TableRow_ByteInfo_GraphicalBarByte_SecondBar.style.color = "red"
						}
						
						TableRow_ByteInfo_GraphicalBarByte_SecondBar.appendChild(document.createTextNode(Text_Address_SecondBar))
						TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_GraphicalBarByte_SecondBar)
					}
					
					let TableRow_ByteInfo_FillAmount = document.createElement("td")
					TableRow_ByteInfo_FillAmount.style.fontFamily = "monospace"
					TableRow_ByteInfo_FillAmount.appendChild(document.createTextNode(GraphicalBarBytes[GraphicalBarBytes_Index].toString(10) + " ($" + GraphicalBarBytes[GraphicalBarBytes_Index].toString(16).toUpperCase().padStart(2, "0") + ")"))
					TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_FillAmount)
					if (GraphicalBarBytes[GraphicalBarBytes_Index] == Maximum) {
						TableRow_ByteInfo_FillAmount.style.backgroundColor = "Orange"
					} else {
						if (!IsEmptyNonFraction) {
							TableRow_ByteInfo_FillAmount.style.backgroundColor = "yellow"
							TableRow_ByteInfo_FillAmount.style.color = "black"
							IsEmptyNonFraction = true
						} else { //A fraction
							TableRow_ByteInfo_FillAmount.style.backgroundColor = "grey"
						}
					}
					
					let TableRow_ByteInfo_FillAmountMax = document.createElement("td")
					TableRow_ByteInfo_FillAmountMax.style.fontFamily = "monospace"
					TableRow_ByteInfo_FillAmountMax.appendChild(document.createTextNode(Maximum.toString(10) + " ($" + Maximum.toString(16).toUpperCase().padStart(2, "0") + ")"))
					TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_FillAmountMax)
					
					
					let TableRow_ByteInfo_Type = document.createElement("td")
					TableRow_ByteInfo_Type.style.fontFamily = "monospace"
					TableRow_ByteInfo_Type.style.color = NamesToColors[ByteType]
					if (ByteType != "Middle") {
						TableRow_ByteInfo_Type.appendChild(document.createTextNode(ByteType))
					} else {
						TableRow_ByteInfo_Type.appendChild(document.createTextNode(ByteType + " " + (Input_MiddleLength-MiddleLeft+1n).toString(10)))
					}
					TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_Type)
					
					
					
					let TableRow_ByteInfo_StatusBarWrite = document.createElement("td")
					TableRow_ByteInfo_StatusBarWrite.style.fontFamily = "monospace"
					TableRow_ByteInfo_StatusBarWrite.appendChild(document.createTextNode(BigIntToStringSignedHex(CurrentStatusBarAddress)))
					TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_StatusBarWrite)
					
					let NextTileDirection = 1n //Forwards or backwards
					if (document.getElementById("FillDirection_Left").selected||document.getElementById("FillDirection_Up").selected) {
						NextTileDirection = -1n
					}
					let NextRowDirection = 1n
					if (document.getElementById("FillDirection_Up").selected||document.getElementById("FillDirection_Down").selected) {
						NextRowDirection = 32n
					}
					
					CurrentStatusBarAddress += NextRowDirection*StatusBarByteFormat*NextTileDirection
					
					OutputByteTable.appendChild(TableRow_ByteInfoRow)
				}
				function ImageRender(Max, Type) {
					if (!PreviewAvailable) {
						return
					}
					let IMG_GraphicalBar = document.createElement("img")
					IMG_GraphicalBar.src = "GraphicalBarFills/" + Type + "_" + GraphicalBarBytes[GraphicalBarBytes_Index].toString(10) + "_of_" + Max.toString(10) + ".png"
					ImagePreview.appendChild(IMG_GraphicalBar)
				}
			
			if (Input_LeftPiece != 0n) {
				if (Input_FillAmount >= Input_LeftPiece) {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_LeftPiece
					Input_FillAmount -= Input_LeftPiece
				} else {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_FillAmount
					Input_FillAmount = 0n
				}
				
				GenerateTableRow(Input_LeftPiece, "Left")
				ImageRender(Input_LeftPiece, "LeftEnd")
				
				GraphicalBarBytes_Index++
			}
			for (let MiddleLeft = NumberOf_MiddleByte; MiddleLeft > 0n; MiddleLeft--, GraphicalBarBytes_Index++) {
				if (Input_FillAmount >= Input_MiddlePiece) {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_MiddlePiece
					Input_FillAmount -= Input_MiddlePiece
				} else {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_FillAmount
					Input_FillAmount = 0n
				}
				GenerateTableRow(Input_MiddlePiece, "Middle", MiddleLeft)
				ImageRender(Input_MiddlePiece, "Middle")
			}
			if (Input_RightPiece != 0n) {
				if (Input_FillAmount >= Input_RightPiece) {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_RightPiece
					Input_FillAmount -= Input_RightPiece
				} else {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_FillAmount
					Input_FillAmount = 0n
				}
				GenerateTableRow(Input_RightPiece, "Right")
				ImageRender(Input_RightPiece, "RightEnd")
			}
		//Remaining fill left
			document.getElementById("Output_RemainingFill").textContent = Input_FillAmount.toString(10) + " ($" + Input_FillAmount.toString(16).toUpperCase().padStart(4, "0") + ")"
		//Get Overlapping range
			if (IsTwoBarsConflicting) {
				let LowestOverlappingByte = Input_TileByteTableAddress;
				if (LowestOverlappingByte < DoubleBar_TileByteTableAddress) {
					LowestOverlappingByte = DoubleBar_TileByteTableAddress
				}
				let HighestOverlappingByte = Input_TileByteTableAddress_Ending
				if (HighestOverlappingByte > DoubleBar_TileByteTableAddress_Ending) {
					HighestOverlappingByte = DoubleBar_TileByteTableAddress_Ending
				}
				document.getElementById("Output_SecondBarOverlap").textContent = "Overlap occurs at " + BigIntToStringSignedHex(LowestOverlappingByte) + " ~ " + BigIntToStringSignedHex(HighestOverlappingByte)
			} else {
				document.getElementById("Output_SecondBarOverlap").textContent = ""
			}
		//Static end tiles
			if (document.getElementById("UsingStatic_LeftSide").checked) {
				if (document.getElementById("FillDirection_Right").selected||document.getElementById("FillDirection_Left").selected) { //Horizontal mode
					let BackOffset = 1n
					if (document.getElementById("BarExtendLeft").checked) {
						BackOffset = TotalGraphicalBarTableLength
					}
					document.getElementById("Output_StaticLeftAddr").textContent = BigIntToStringSignedHex(Input_StatusbarAddressToWrite-(BackOffset*1n*StatusBarByteFormat))
				} else { //Vertical mode (not using stripe)
					let Direction = -1n
					if (document.getElementById("FillDirection_Up").selected) {
						Direction = 1n
					}
					document.getElementById("Output_StaticLeftAddr").textContent = BigIntToStringSignedHex(Input_StatusbarAddressToWrite+(32n*StatusBarByteFormat*Direction))
				}
			} else {
				document.getElementById("Output_StaticLeftAddr").textContent = "N/A"
			}
			if (document.getElementById("UsingStatic_RightSide").checked) {
				if (document.getElementById("FillDirection_Right").selected||document.getElementById("FillDirection_Left").selected) { //Horizontal mode
					let Offset = TotalGraphicalBarTableLength
					if (document.getElementById("BarExtendLeft").checked) {
						Offset = 1n
					}
					document.getElementById("Output_StaticRightAddr").textContent = BigIntToStringSignedHex(Input_StatusbarAddressToWrite+(Offset*StatusBarByteFormat))
				} else {
					let Offset = TotalGraphicalBarTableLength
					if (document.getElementById("FillDirection_Up").selected) {
						Offset *= -1n
					}
					document.getElementById("Output_StaticRightAddr").textContent = BigIntToStringSignedHex(Input_StatusbarAddressToWrite+(32n*StatusBarByteFormat*Offset))
				}
			} else {
				document.getElementById("Output_StaticRightAddr").textContent = "N/A"
			}
	}
	//Helper
		function UpdateOtherInputs(ele) {
			let EnteredValue = ele.value.replaceAll(/\s/g, "")
			let EnteredNumber = ParseBigIntValue(EnteredValue, parseInt(ele.dataset.radix))
			let EnteredMin = -Infinity
			if (typeof ele.dataset.min != "undefined") {
				EnteredMin = ParseBigIntValue(ele.dataset.min)
			}
			let EnteredMax = Infinity
			if (typeof ele.dataset.max != "undefined") {
				EnteredMax = ParseBigIntValue(ele.dataset.max)
			}
			EnteredNumber = BigintClamp(EnteredNumber, EnteredMin, EnteredMax)
			
			let InputsToUpdate = [...ele.parentNode.querySelectorAll("input")]
			.filter(ele2 => (/(?:text|number)/).test(ele2.type))
			//Corrects and will update other adjacent inputs
			InputsToUpdate.forEach(ele2 => {
				let StringToDisplay = EnteredNumber.toString(parseInt(ele2.dataset.radix)).toUpperCase()
				try {
					StringToDisplay = StringToDisplay.padStart(parseInt(ele2.dataset.padlength), "0")
				} catch {}
				ele2.value = StringToDisplay
			})
			MainCode()
		}
		
		function BigintClamp(num, min, max) {
			//Restrict a number within a specified range, bigInt edition.
				return num <= min ? min : num >= max ? max : num;
		}
		function createSVGElement(tag) { //https://stackoverflow.com/questions/57894500/why-is-it-necessary-to-use-document-createelementns-when-adding-svg-tags-to
			return document.createElementNS('http://www.w3.org/2000/svg', tag)
		}
		function ParseBigIntValue(string, radix) {
			//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
			//this works with bigInt.
			try {
				let Output = 0n
				let NegativeNumber = 1n
				if ((/^-/).test(string)) {
					NegativeNumber = -1n
				}
				let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
				switch (radix) {
					//decimal
						default:
						if ((/^-?\d+$/).test(string)) {
							Output = BigInt(string)
						}
						break
					//Hexadecimal
						case 16:
						case "0x":
						case "0X":
						if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
							Output = BigInt("0x" + DigitPart) * NegativeNumber
						}
						break
					//Binary
						case 2:
						case "0b":
						case "0B":
						if ((/^-?[01]+$/).test(string)) {
							Output = BigInt("0b" + DigitPart) * NegativeNumber
						}
				
				}
				return Output
			} catch {}
		}
		function BigIntToStringSignedHex(BigIntVal) {
			//Converts a bigint value into a signed ASM-styled hex number:
			//16n -> "$10"
			//-16n -> "-$10"
			let StringOutput = ""
			if (BigIntVal >= 0n) {
				StringOutput = "$" + BigIntVal.toString(16).toUpperCase()
			} else {
				StringOutput = "-$" + (BigIntVal*-1n).toString(16).toUpperCase()
			}
			return StringOutput
		}
		function DeleteCopyMessage(HTMLElement) {
			HTMLElement.textContent = ""
		}
		
		function setClipboard(String) {
			//Credit goes to Mozilla: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/write
			const type = "text/plain";
			const blob = new Blob([String], { type });
			const data = [new ClipboardItem({ [type]: blob })];
			
			let EventElement = event.target
			let CopiedMessage = EventElement.parentNode.querySelector("span")
		
			navigator.clipboard.write(data).then(
				((EventElement) => {
				/* success */
					CopiedMessage.textContent = "Copied!"
					CopiedMessage.style.color = "#00FF00"
					setTimeout(DeleteCopyMessage.bind(null, CopiedMessage), 1500)
				}).bind(null, EventElement),
				((EventElement) => {
				/* failure */
					CopiedMessage.textContent = "Failed!"
					CopiedMessage.style.color = "#FF0000"
					setTimeout(DeleteCopyMessage.bind(null, CopiedMessage), 1500)
				}).bind(null, EventElement)
			);
		}
	//Check if two ranges overlap.
	//Given 2 ranges:
	//Range_A: A_Start and A_End
	//Range_B: B_Start and B_End
	//If B_End is touching A_Start, then Range_B is at the lowest position (or Range_A at the highest position) that would count as an overlap
	//If B_Start is touching A_End, then Range_B is at the highest position (or Range_A is at the lowest position) that would count as an overlap
		function CheckOverlap(A_Start, A_End, B_Start, B_End) {
			if (B_End >= A_Start&&B_Start <= A_End) {
				return true
			} else {
				return false
			}
		}
</script>