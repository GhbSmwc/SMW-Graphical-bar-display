<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			div.SmallFont {
				font-size: 11px;
			}
			
			div.StatisticsTable {
				max-width:900px;
			}
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
			
			
			img.img-hor {
				-moz-transform: scaleX(-1);
				-o-transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
				transform: scaleX(-1);
				filter: FlipH;
				-ms-filter: "FlipH";
			}
			img.img-rot {
				/* upwards bar */
				transform: rotate(-90deg)
			}
			img.img-downwardsbar {
				/* it performs the transforms right-to-left*/
				transform: scaleY(-1) rotate(-90deg);
			}
			label { display: block; }
.noselect {
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
}
.ClickHoldChangeNumber {
	cursor: ew-resize
}
	input[type='text'] { font-family: monospace;}
	input[type='number'] { font-family: monospace;}
		</style>
	</head>
<a href="../GraphicalBar_ReadmeDocumentation.html#TopJSLink">Back to top</a><br>
<a href="../GraphicalBar_ReadmeDocumentation.html#ComputeGraphicalBarData">Back to info table</a><br>
<a href="DoubleBarInfo.html#DoubleBarSG">Back to Double bar information</a><br><br>
<p>This javascript HTML file simulates the subroutine <kbd>DrawGraphicalBar</kbd> and <kbd>DrawGraphicalBarSubtractionLoopEdition</kbd>.</p>
Notes:<br>
<ul>
<li>The screen is 256 by 224 pixels, therefore when dealing with 8x8 tiles, the number of 8x8s to fill the entire width or height would be 32 tiles wide 28 tiles tall.</li>
<li>The tile display is only available using default number of pieces or zero for left end, middle, and right end, this is because there are way too many different configurations for me to draw every tile.</li>
<li>When using a vertical bar on a stripe image, the tile data write is the same way as horizontal bar using the <kbd>[TTTTTTTT, YXPCCCTT]</kbd> format, ignoring the header and the terminating byte.</li>
</ul>
<table>
	<tr>
		<td>Fill amount</td>
		<td><input type="number" data-radix="10" min="0" max="65535" data-min="0" data-max="65535" value="0" id="Input_FillAmount"> $<input type="text" data-radix="16" data-padlength="4" data-min="0" data-max="65535" value="0000"><button>Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td>Number of pieces for left end</td>
		<td><input type="number" data-radix="10" min="0" max="255" data-min="0" data-max="255" value="3" id="Input_LeftPiece"> $<input type="text" data-radix="16" data-padlength="2" data-min="0" data-max="255" value="03"><button>Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td>Number of pieces for each middle</td>
		<td><input type="number" data-radix="10" min="0" max="255" data-min="0" data-max="255" value="8" id="Input_MiddlePiece"> $<input type="text" data-radix="16" data-padlength="2" data-min="0" data-max="255" value="08"><button>Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td>Number of pieces for right end</td>
		<td><input type="number" data-radix="10" min="0" max="255" data-min="0" data-max="255" value="3" id="Input_RightPiece"> $<input type="text" data-radix="16" data-padlength="2" data-min="0" data-max="255" value="03"><button>Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td>Number of middle tiles</td>
		<td><input type="number" data-radix="10" min="0" max="255" data-min="0" data-max="255" value="7" id="Input_MiddleLength"> $<input type="text" data-radix="16" data-padlength="2" data-min="0" data-max="255" value="07"><button>Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td>Using double bar?</td>
		<td><label><input type="checkbox" id="ToggleDoubleBar" onchange="MainCode()"></label></td>
	</tr>
	<tr>
		<td><kbd>!Setting_GraphicalBar_SecondFillByteTableOffset</kbd></td>
		<td><input type="number" data-radix="10" min="0" max="257"  data-min="0" data-max="257" value="32" id="Input_DoubleBarAddressOffset" class="DoubleBarRelated"> $<input type="text" data-radix="16" data-padlength="2" data-min="0" data-max="257" value="20" class="DoubleBarRelated"><button class="DoubleBarRelated">Click & hold to adjust</button></td>
	</tr>
	<tr>
		<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> location</td>
		<td>
			$<input type="text" data-radix="16" value="7F844A" id="GraphicalBar_TileAddressLocation" list="BarTileTableRAMList"><button>Click & hold to adjust</button>
			<datalist id="BarTileTableRAMList">
				<option value="7F844A">Default LoROM</option>
				<option value="400198">SA-1</option>
			</datalist>
		</td>
	</tr>
	<tr>
		<td>Write your tiles at:</td>
		<td>
			$<input type="text" data-radix="16" value="7FA000" id="StatusBarAddressToWrite" list="StatusBarRAMTileList"><button>Click & hold to adjust</button>
			<datalist id="StatusBarRAMTileList">
				<option value="7E0F09">SMW's status bar (Writes over “TIME”)</option>
				<option value="7FA000">Super status bar </option>
				<option value="404000">Super status bar (SA-1)</option>
				<option value="7FA03E">Super status bar (Top right corner)</option>
				<option value="40403E">Super status bar (SA-1, top right corner)</option>
				<option value="7FEC00">Overworld border plus</option>
				<option value="41EC00">Overworld border plus (SA-1)</option>
			</datalist>
		</td>
	</tr>
	<tr>
		<td>Status bar tile format</td>
		<td>
			<select onchange="MainCode()">
				<option id="StatusBarFormat_2" selected>Interleaved [TT, PP, TT, PP,...]</option>
				<option id="StatusBarFormat_1">2 Seperate tables [TT, TT, TT,...][PP, PP, PP,...]</option>
			</select>
		</td>
	</tr>
	<tr>
		<td>Fill Direction</td>
		<td>
			<select onchange="MainCode()">
				<option id="FillDirection_Right" selected>Right</option>
				<option id="FillDirection_Left">Left</option>
				<option id="FillDirection_Up">Up</option>
				<option id="FillDirection_Down">Down</option>
			</select>
		</td>
	</tr>
	<tr>
		<td>Using <kbd>BarExtendLeft</kbd>? (Only applies to horizontal bars and not using stripe)</td>
		<td><label><input type="checkbox" onchange="MainCode()"></label></td>
	</tr>
	<tr>
		<td>Using static end tiles?</td>
		<td>
			<div><label><input type="checkbox"> (&ldquo;left side&rdquo; for horizontal bars, whatever top or bottom the fill starts at for vertical)</label></div>
			<div><label><input type="checkbox">  (&ldquo;right side&rdquo; for horizontal bars, whatever top or bottom the fill ends at for vertical)</label></div>
		</td>
	</tr>
</table>
<hr>
<div id="OutputInfo">
	<table>
		<tr>
			<td style="font-family: monospace">Total bytes used for fill table</td>
			<td style="font-family: monospace" id="Output_TileTableSizeAndRange"></td>
		</tr>
		<tr>
			<td style="font-family: monospace">Total bytes used for fill table for double bar</td>
			<td style="font-family: monospace" id="Output_TileTableSizeAndRangeDoubleBar"></td>
		</tr>
		<tr>
			<td style="font-family: monospace">Total bar pieces</td>
			<td style="font-family: monospace" id="Output_TotalBarPieces"></td>
		</tr>
	</table><br>
	<div>
		<button title="For Address tracker&apos; auto-assigner" onclick="CopyRAMUsage()">Get autoassigner data</button>
		<span></span>
	</div><br>
	<table id="Output_ByteLayout"></table>
</div>
<div id="OutputError" hidden><span style="font-family: monospace; color: #ff0000">Error! Not a single byte used.</span></div>

<script>
	let TotalGraphicalBarTableLength = 0n
	let MouseDownClickPos = {
		x: 0,
		y: 0,
		moveByX: 0,
		moveByY: 0,
		PlacedState: false,
		OriginalNumber: 0n
	}
	let ElementToAdjust = null
	window.addEventListener(
		"load",
		function () {
			[...document.querySelectorAll("input")].forEach(ele => { //Add up/down triggers
				if (ele.type == "text"||ele.type == "number") {
					AddInputNumberTriggers(ele)
				}
				if (ele.type == "text") {
					UpDownArrowTriggers(ele)
				}
			});
			[...document.querySelectorAll("button")].filter(btn => { //move mouse to adjust
				return btn.textContent == "Click & hold to adjust"
			}).forEach(ele => {
				ele.addEventListener(
					"mousedown",
					function (e) {
						e.preventDefault()
						if (e.button != 0) {
							return
						}
						MouseDownClickPos.x = e.pageX
						MouseDownClickPos.y = e.pageY
						MouseDownClickPos.moveByX = e.pageX - MouseDownClickPos.x
						MouseDownClickPos.moveByY = e.pageY - MouseDownClickPos.y
						MouseDownClickPos.PlacedState = true
						
						try {
							ElementToAdjust = e.target.parentNode.querySelector("input")
							OriginalNumber = ParseBigIntValue(ElementToAdjust.value, parseInt(ElementToAdjust.dataset.radix))
						} catch {
							ElementToAdjust = null
						}
					}
				)
			})
			document.addEventListener(
				"mouseup",
				function (e) {
					MouseDownClickPos.PlacedState = false
				}
			)
			document.addEventListener(
				"mousemove",
				function (e) {
					if (MouseDownClickPos.PlacedState) {
						MouseDownClickPos.moveByX = e.pageX - MouseDownClickPos.x
						MouseDownClickPos.moveByY = e.pageY - MouseDownClickPos.y
						if (ElementToAdjust != null) {
							ElementToAdjust.value = (OriginalNumber + BigInt(Math.round(MouseDownClickPos.moveByX/8))).toString(ElementToAdjust.dataset.radix)
							UpdateOtherInputs(ElementToAdjust)
						}
					}
				}
			
			)
			MainCode()
		}
	)
	function AddInputNumberTriggers(ele) {
		ele.addEventListener(
			"change",
			function () {
				UpdateOtherInputs(ele)
			}.bind(null, ele)
		)
	}
	function UpDownArrowTriggers(ele) {
		ele.addEventListener(
			"keydown",
			function (e) {
				let KeyName = e.key
				if (/(ArrowDown|ArrowUp)/.test(KeyName)) {
					e.preventDefault()
					let IncrementDecrement = 1n
					if (KeyName == "ArrowDown") {
						IncrementDecrement *= -1n
					}
					let EnteredNumber = ParseBigIntValue(e.target.value, parseInt(e.target.dataset.radix)) + IncrementDecrement
					event.target.value = (EnteredNumber.toString(parseInt(e.target.dataset.radix))).toUpperCase()
					
					let a = 0
					UpdateOtherInputs(e.target)
					
				}
			}
		)
	}
	function CopyRAMUsage() {
		let FreeramAutoAssignerText = ""
		FreeramAutoAssignerText += "Graphical Bar\t!Scratchram_GraphicalBar_LeftEndPiece\t1\t-\t-\n"
		FreeramAutoAssignerText += "Graphical Bar\t!Scratchram_GraphicalBar_MiddlePiece\t1\t-\t-\n"
		FreeramAutoAssignerText += "Graphical Bar\t!Scratchram_GraphicalBar_RightEndPiece\t1\t-\t-\n"
		FreeramAutoAssignerText += "Graphical Bar\t!Scratchram_GraphicalBar_TempLength\t1\t-\t-\n"
		FreeramAutoAssignerText += "Graphical Bar\t!Scratchram_GraphicalBar_FillByteTbl\t" + TotalGraphicalBarTableLength + "\t-\t-"
		setClipboard(FreeramAutoAssignerText)
	}
	function HandleMouseMovementToNumberInput(e) {
		let ElementToAdjust = MouseDrag.ElementClicked.parentNode.querySelector("input")
		let NumberValue = ParseBigIntValue(ElementToAdjust.value, ElementToAdjust.dataset.radix)
		NumberValue += BigInt(Math.floor(MouseDrag.DraggedByX/8))
		ElementToAdjust.value = NumberValue.toString(ElementToAdjust.dataset.radix)
		UpdateOtherInputs(e.parentNode.querySelector("input"))
	}
	
	function MainCode() {
		let IsDoubleBarEnabled = document.getElementById("ToggleDoubleBar").checked;
		[...document.querySelectorAll("*.DoubleBarRelated")].forEach(ele => ele.disabled = !IsDoubleBarEnabled);
		let StatusBarByteFormat = 1n
		if (document.getElementById("StatusBarFormat_2").selected) {
			StatusBarByteFormat = 2n
		}
		
		let Input_FillAmount =   ParseBigIntValue(document.getElementById("Input_FillAmount").value)
		let Input_LeftPiece =    ParseBigIntValue(document.getElementById("Input_LeftPiece").value)
		let Input_MiddlePiece =  ParseBigIntValue(document.getElementById("Input_MiddlePiece").value)
		let Input_RightPiece =   ParseBigIntValue(document.getElementById("Input_RightPiece").value)
		let Input_MiddleLength = ParseBigIntValue(document.getElementById("Input_MiddleLength").value)
		let Input_DoubleBarAddressOffset = ParseBigIntValue(document.getElementById("Input_DoubleBarAddressOffset").value)
		let Input_TileByteTableAddress = ParseBigIntValue(document.getElementById("GraphicalBar_TileAddressLocation").value, 16)
		let Input_StatusbarAddressToWrite = ParseBigIntValue(document.getElementById("StatusBarAddressToWrite").value, 16)
		
		let NumberOf_LeftByte = 0n
		if (Input_LeftPiece != 0n) {
			NumberOf_LeftByte = 1n
		}
		let NumberOf_MiddleByte = 0n
		if (Input_MiddleLength * Input_MiddlePiece != 0n) {
			NumberOf_MiddleByte = Input_MiddleLength
		}
		let NumberOf_RightByte = 0n
		if (Input_RightPiece != 0n) {
			NumberOf_RightByte = 1n
		}
		TotalGraphicalBarTableLength = NumberOf_LeftByte+NumberOf_MiddleByte+NumberOf_RightByte
		if (TotalGraphicalBarTableLength == 0n) {
			document.getElementById("OutputInfo").hidden = true
			document.getElementById("OutputError").hidden = false
			return
		}
		document.getElementById("OutputInfo").hidden = false
		document.getElementById("OutputError").hidden = true
		let BarMaxTotalPieces = Input_LeftPiece + (Input_MiddleLength * Input_MiddlePiece) + Input_RightPiece
		
		document.getElementById("Output_TileTableSizeAndRange").textContent = TotalGraphicalBarTableLength.toString(10) + " (" + BigIntToStringSignedHex(Input_TileByteTableAddress) + " ~ " + BigIntToStringSignedHex(Input_TileByteTableAddress+TotalGraphicalBarTableLength-1n) + ")"
		document.getElementById("Output_TileTableSizeAndRangeDoubleBar").textContent = "N/A"
		if (IsDoubleBarEnabled) {
			document.getElementById("Output_TileTableSizeAndRangeDoubleBar").textContent = TotalGraphicalBarTableLength.toString(10) + " (" + BigIntToStringSignedHex(Input_TileByteTableAddress+Input_DoubleBarAddressOffset) + " ~ " + BigIntToStringSignedHex(Input_TileByteTableAddress+TotalGraphicalBarTableLength-1n+Input_DoubleBarAddressOffset) + ")"
		}
		document.getElementById("Output_TotalBarPieces").textContent = BarMaxTotalPieces.toString(10) + " (" + BigIntToStringSignedHex(BarMaxTotalPieces) + ")"
		
		//Clear table
			let OutputByteTable = document.getElementById("Output_ByteLayout")
			while (OutputByteTable.lastElementChild) {
				OutputByteTable.removeChild(OutputByteTable.lastElementChild)
			}
		//Table header
			let OutputByteTable_HeaderRow = document.createElement("tr")
			
			let OutputByteTable_TableHeader_FillByteTable = document.createElement("th")
			OutputByteTable_TableHeader_FillByteTable.style.fontFamily = "monospace"
			OutputByteTable_TableHeader_FillByteTable.appendChild(document.createTextNode("!Scratchram_GraphicalBar_FillByteTbl"))
			OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_FillByteTable)
			
			if (document.getElementById("ToggleDoubleBar").checked) {
				let OutputByteTable_TableHeader_SecondFillByteTable = document.createElement("th")
				OutputByteTable_TableHeader_SecondFillByteTable.appendChild(document.createTextNode("Second bar location"))
				OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_SecondFillByteTable)
			}
			
			let OutputByteTable_TableHeader_FillAmount = document.createElement("th")
			OutputByteTable_TableHeader_FillAmount.appendChild(document.createTextNode("Fill amount"))
			OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_FillAmount)
			
			let OutputByteTable_TableHeader_FillMax = document.createElement("th")
			OutputByteTable_TableHeader_FillMax.appendChild(document.createTextNode("Maximum fill"))
			OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_FillMax)
			
			let OutputByteTable_TableHeader_ByteType = document.createElement("th")
			OutputByteTable_TableHeader_ByteType.appendChild(document.createTextNode("Byte type"))
			OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_ByteType)
			
			let OutputByteTable_TableHeader_StatusBarWriteLocation = document.createElement("th")
			OutputByteTable_TableHeader_StatusBarWriteLocation.appendChild(document.createTextNode("Written to"))
			OutputByteTable_HeaderRow.appendChild(OutputByteTable_TableHeader_StatusBarWriteLocation)
			
			OutputByteTable.appendChild(OutputByteTable_HeaderRow)
		//Graphical bar bytes
			let GraphicalBarBytes = []
			GraphicalBarBytes.length = 257
			GraphicalBarBytes.fill(0n)
			let GraphicalBarBytes_Index = 0n
			let IsEmptyNonFraction = false
			let CurrentStatusBarAddress = Input_StatusbarAddressToWrite
			if (document.getElementById("FillDirection_Left").selected) {
				CurrentStatusBarAddress += (TotalGraphicalBarTableLength-1n)*StatusBarByteFormat
			}
			
			//Declare function
				function GenerateTableRow(Maximum, ByteType, MiddleLeft) {
					let NamesToColors = {
						"Left": "Cyan",
						"Middle": "#00FF00",
						"Right": "Red"
					}
					let TableRow_ByteInfoRow = document.createElement("tr")
					
					let TableRow_ByteInfo_GraphicalBarByte = document.createElement("td")
					TableRow_ByteInfo_GraphicalBarByte.style.fontFamily = "monospace"
					TableRow_ByteInfo_GraphicalBarByte.appendChild(document.createTextNode(BigIntToStringSignedHex(Input_TileByteTableAddress+GraphicalBarBytes_Index)))
					TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_GraphicalBarByte)
					
					if (document.getElementById("ToggleDoubleBar").checked) {
						let TableRow_ByteInfo_GraphicalBarByte_SecondBar = document.createElement("td")
						TableRow_ByteInfo_GraphicalBarByte_SecondBar.style.fontFamily = "monospace"
						TableRow_ByteInfo_GraphicalBarByte_SecondBar.appendChild(document.createTextNode(BigIntToStringSignedHex(Input_TileByteTableAddress+Input_DoubleBarAddressOffset+GraphicalBarBytes_Index)))
						TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_GraphicalBarByte_SecondBar)
					}
					
					let TableRow_ByteInfo_FillAmount = document.createElement("td")
					TableRow_ByteInfo_FillAmount.style.fontFamily = "monospace"
					TableRow_ByteInfo_FillAmount.appendChild(document.createTextNode(GraphicalBarBytes[GraphicalBarBytes_Index].toString(10) + " ($" + GraphicalBarBytes[GraphicalBarBytes_Index].toString(16).toUpperCase().padStart(2, "0") + ")"))
					TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_FillAmount)
					if (GraphicalBarBytes[GraphicalBarBytes_Index] == Maximum) {
						TableRow_ByteInfo_FillAmount.style.backgroundColor = "Orange"
					} else {
						if (!IsEmptyNonFraction) {
							TableRow_ByteInfo_FillAmount.style.backgroundColor = "yellow"
							TableRow_ByteInfo_FillAmount.style.color = "black"
							IsEmptyNonFraction = true
						} else { //A fraction
							TableRow_ByteInfo_FillAmount.style.backgroundColor = "grey"
						}
					}
					
					let TableRow_ByteInfo_FillAmountMax = document.createElement("td")
					TableRow_ByteInfo_FillAmountMax.style.fontFamily = "monospace"
					TableRow_ByteInfo_FillAmountMax.appendChild(document.createTextNode(Maximum.toString(10) + " ($" + Maximum.toString(16).toUpperCase().padStart(2, "0") + ")"))
					TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_FillAmountMax)
					
					
					let TableRow_ByteInfo_Type = document.createElement("td")
					TableRow_ByteInfo_Type.style.fontFamily = "monospace"
					TableRow_ByteInfo_Type.style.color = NamesToColors[ByteType]
					if (ByteType != "Middle") {
						TableRow_ByteInfo_Type.appendChild(document.createTextNode(ByteType))
					} else {
						TableRow_ByteInfo_Type.appendChild(document.createTextNode(ByteType + " " + (Input_MiddleLength-MiddleLeft+1n).toString(10)))
					}
					TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_Type)
					
					
					
					let TableRow_ByteInfo_StatusBarWrite = document.createElement("td")
					TableRow_ByteInfo_StatusBarWrite.style.fontFamily = "monospace"
					TableRow_ByteInfo_StatusBarWrite.appendChild(document.createTextNode(BigIntToStringSignedHex(CurrentStatusBarAddress)))
					TableRow_ByteInfoRow.appendChild(TableRow_ByteInfo_StatusBarWrite)
					
					let NextTileDirection = 1n
					if (document.getElementById("FillDirection_Left").selected||document.getElementById("FillDirection_Up").selected) {
						NextTileDirection = -1n
					}
					CurrentStatusBarAddress += 1n*StatusBarByteFormat*NextTileDirection
					
					OutputByteTable.appendChild(TableRow_ByteInfoRow)
				}
			
			if (Input_LeftPiece != 0n) {
				if (Input_FillAmount >= Input_LeftPiece) {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_LeftPiece
					Input_FillAmount -= Input_LeftPiece
				} else {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_FillAmount
					Input_FillAmount = 0n
				}
				
				GenerateTableRow(Input_LeftPiece, "Left")
				
				GraphicalBarBytes_Index++
			}
			for (let MiddleLeft = NumberOf_MiddleByte; MiddleLeft > 0n; MiddleLeft--, GraphicalBarBytes_Index++) {
				if (Input_FillAmount >= Input_MiddlePiece) {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_MiddlePiece
					Input_FillAmount -= Input_MiddlePiece
				} else {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_FillAmount
					Input_FillAmount = 0n
				}
				GenerateTableRow(Input_MiddlePiece, "Middle", MiddleLeft)
				
			}
			if (Input_RightPiece != 0n) {
				if (Input_FillAmount >= Input_RightPiece) {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_RightPiece
					Input_FillAmount -= Input_RightPiece
				} else {
					GraphicalBarBytes[GraphicalBarBytes_Index] = Input_FillAmount
					Input_FillAmount = 0n
				}
				GenerateTableRow(Input_RightPiece, "Right")
			}
		//Remaining fill left
		let a = 0
		
	}
	//Helper
		function UpdateOtherInputs(ele) {
			let EnteredValue = ele.value
			let EnteredNumber = ParseBigIntValue(EnteredValue, parseInt(ele.dataset.radix))
			let EnteredMin = -Infinity
			if (typeof ele.dataset.min != "undefined") {
				EnteredMin = ParseBigIntValue(ele.dataset.min)
			}
			let EnteredMax = Infinity
			if (typeof ele.dataset.max != "undefined") {
				EnteredMax = ParseBigIntValue(ele.dataset.max)
			}
			EnteredNumber = BigintClamp(EnteredNumber, EnteredMin, EnteredMax)
			
			let InputsToUpdate = [...ele.parentNode.querySelectorAll("input")]
			.filter(ele2 => (/(?:text|number)/).test(ele2.type))
			//Corrects and will update other adjacent inputs
			InputsToUpdate.forEach(ele2 => {
				let StringToDisplay = EnteredNumber.toString(parseInt(ele2.dataset.radix)).toUpperCase()
				try {
					StringToDisplay = StringToDisplay.padStart(parseInt(ele2.dataset.padlength), "0")
				} catch {}
				ele2.value = StringToDisplay
			})
			MainCode()
		}
		
		function BigintClamp(num, min, max) {
			//Restrict a number within a specified range, bigInt edition.
				return num <= min ? min : num >= max ? max : num;
		}
		function createSVGElement(tag) { //https://stackoverflow.com/questions/57894500/why-is-it-necessary-to-use-document-createelementns-when-adding-svg-tags-to
			return document.createElementNS('http://www.w3.org/2000/svg', tag)
		}
		function ParseBigIntValue(string, radix) {
			//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
			//this works with bigInt.
			try {
				let Output = 0n
				let NegativeNumber = 1n
				if ((/^-/).test(string)) {
					NegativeNumber = -1n
				}
				let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
				switch (radix) {
					//decimal
						default:
						if ((/^-?\d+$/).test(string)) {
							Output = BigInt(string)
						}
						break
					//Hexadecimal
						case 16:
						case "0x":
						case "0X":
						if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
							Output = BigInt("0x" + DigitPart) * NegativeNumber
						}
						break
					//Binary
						case 2:
						case "0b":
						case "0B":
						if ((/^-?[01]+$/).test(string)) {
							Output = BigInt("0b" + DigitPart) * NegativeNumber
						}
				
				}
				return Output
			} catch {}
		}
		function BigIntToStringSignedHex(BigIntVal) {
			//Converts a bigint value into a signed ASM-styled hex number:
			//16n -> "$10"
			//-16n -> "-$10"
			let StringOutput = ""
			if (BigIntVal >= 0n) {
				StringOutput = "$" + BigIntVal.toString(16).toUpperCase()
			} else {
				StringOutput = "-$" + (BigIntVal*-1n).toString(16).toUpperCase()
			}
			return StringOutput
		}
		function DeleteCopyMessage(HTMLElement) {
			HTMLElement.textContent = ""
		}
		
		function setClipboard(String) {
			//Credit goes to Mozilla: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/write
			const type = "text/plain";
			const blob = new Blob([String], { type });
			const data = [new ClipboardItem({ [type]: blob })];
			
			let EventElement = event.target
			let CopiedMessage = EventElement.parentNode.querySelector("span")
		
			navigator.clipboard.write(data).then(
				((EventElement) => {
				/* success */
					CopiedMessage.textContent = "Copied!"
					CopiedMessage.style.color = "#00FF00"
					setTimeout(DeleteCopyMessage.bind(null, CopiedMessage), 1500)
				}).bind(null, EventElement),
				((EventElement) => {
				/* failure */
					CopiedMessage.textContent = "Failed!"
					CopiedMessage.style.color = "#FF0000"
					setTimeout(DeleteCopyMessage.bind(null, CopiedMessage), 1500)
				}).bind(null, EventElement)
			);
		}
</script>