<svg width="1000" height="1000" style="background-color: #707070" id="SVG_RepeatedSubtractionExplained">
</svg>

<script>
	DrawRepeatedSubtractionSVG()
	
	
	function DrawRepeatedSubtractionSVG() {
		let SVGGraphToDisplay = document.getElementById("SVG_RepeatedSubtractionExplained")
		
		//Amount Settings
			let GraphicalBarLeftEndPiece = 3n
			let GraphicalBarMiddlePiece = 8n
			let GraphicalBarRightEndPiece = 3n
			let GraphicalBarMiddleLength = 4n
			
			let InputAmountFilled = 14n
		//Display positioning settings
			let FilledAmountLeftMargin = 10n
			let TileProcessYPositionRow_Spacing = 150n
			let FilledPieceXPosition = FilledAmountLeftMargin + 10n
			let VerticalLineXPos = FilledPieceXPosition + (InputAmountFilled * 10n) + 30n
		//Don't touch
		{
			//Starting fill amount
			let OutputProcessYPositionStart = 100n
			
			let StartingFillAmountText = createSVGElement("text")
			StartingFillAmountText.setAttribute("x", FilledAmountLeftMargin.toString(10))
			StartingFillAmountText.setAttribute("y", "30")
			StartingFillAmountText.setAttribute("font-family", "monospace")
			StartingFillAmountText.appendChild(document.createTextNode("$00-$01 fill amount:"))
			SVGGraphToDisplay.appendChild(StartingFillAmountText)
			
			for (let Countdown = InputAmountFilled; Countdown > 0n; Countdown--) {
				let Xpositioning = FilledPieceXPosition + ((InputAmountFilled - Countdown) * 10n)
				
				let Piece = createSVGElement("rect")
				Piece.setAttribute("x", Xpositioning.toString(10))
				Piece.setAttribute("y", "50")
				Piece.setAttribute("width", "10")
				Piece.setAttribute("height", "30")
				Piece.setAttribute("stroke-width", "1")
				Piece.setAttribute("stroke", "#000000")
				Piece.setAttribute("fill", "#00C000")
				SVGGraphToDisplay.appendChild(Piece)
			}
			
			let FillAmountNumberTextDisplay = createSVGElement("text")
			FillAmountNumberTextDisplay.setAttribute("x", (FilledAmountLeftMargin + (InputAmountFilled * 10n) + 15n).toString(10))
			FillAmountNumberTextDisplay.setAttribute("y", "70")
			FillAmountNumberTextDisplay.setAttribute("font-family", "monospace")
			FillAmountNumberTextDisplay.appendChild(document.createTextNode(InputAmountFilled.toString(10)))
			SVGGraphToDisplay.appendChild(FillAmountNumberTextDisplay)
			
			let VerticalLine = createSVGElement("line")
			VerticalLine.setAttribute("x1", VerticalLineXPos.toString(10))
			VerticalLine.setAttribute("y1", "0")
			VerticalLine.setAttribute("x2", VerticalLineXPos.toString(10))
			VerticalLine.setAttribute("y2", "1000")
			VerticalLine.setAttribute("stroke", "black")
			SVGGraphToDisplay.appendChild(VerticalLine)
		}
		{
			//Each row representing each tile byte getting filled.
			let RemainingFill = InputAmountFilled
			let TileProcessYPositionRow = 100n
			let CurrentFillXPos = VerticalLineXPos + 20n

			//Show subtraction from the remaining fill amount
			//Declare functions
				function RepeatedSubtractionDisplay({Max = 0n}) {
					let HorizontalLine = createSVGElement("line")
					HorizontalLine.setAttribute("x1", "0")
					HorizontalLine.setAttribute("y1", TileProcessYPositionRow.toString(10))
					HorizontalLine.setAttribute("x2", "1000")
					HorizontalLine.setAttribute("y2", TileProcessYPositionRow.toString(10))
					HorizontalLine.setAttribute("stroke", "black")
					SVGGraphToDisplay.appendChild(HorizontalLine)
					
					let RemainingFillSubtracted = RemainingFill-Max
					
					let SubtractionText = createSVGElement("text")
					SubtractionText.setAttribute("x", FilledAmountLeftMargin.toString(10))
					SubtractionText.setAttribute("y", (TileProcessYPositionRow + 20n).toString(10))
					SubtractionText.setAttribute("font-family", "monospace")
					
					let Text = ""
					if (RemainingFillSubtracted < 0n) {
						SubtractionText.setAttribute("fill", "#900000")
						Text += RemainingFill.toString(10) + " - " + Max.toString(10) + " = (" + RemainingFillSubtracted + ") -> 0"
					} else {
						Text += RemainingFill.toString(10) + " - " + Max.toString(10) + " = " + RemainingFillSubtracted
					}
					SubtractionText.appendChild(document.createTextNode(Text))
					
					SVGGraphToDisplay.appendChild(SubtractionText)
					
					//Graphical fill changes
					if (RemainingFillSubtracted < 0) { //Below max
						for (let Countdown = Max, FillLeft = RemainingFill; Countdown > 0n; Countdown--, FillLeft--) {
							let Xpositioning = FilledPieceXPosition + ((Max - Countdown) * 10n)
							
							let Piece = createSVGElement("rect")
							Piece.setAttribute("x", Xpositioning.toString(10))
							Piece.setAttribute("width", "10")
							Piece.setAttribute("height", "30")
							Piece.setAttribute("stroke-width", "1")
							
							if (FillLeft <= 0n)  { //Below by...
								Piece.setAttribute("stroke-dasharray", "4")
								Piece.setAttribute("fill", "rgb(0,0,0,0)")
								Piece.setAttribute("y", (TileProcessYPositionRow+50n).toString(10))
							} else { //Remaining fill
								Piece.setAttribute("stroke", "#000000")
								Piece.setAttribute("fill", "#B5E61D")
								Piece.setAttribute("y", (TileProcessYPositionRow+40n).toString(10))
							}
							
							Piece.setAttribute("stroke", "#000000")
							SVGGraphToDisplay.appendChild(Piece)
						}
						
					} else {
						for (let Countdown = RemainingFill, Subtracted = RemainingFillSubtracted; Countdown > 0n; Countdown--, Subtracted--) {
							let Xpositioning = FilledPieceXPosition + ((RemainingFill - Countdown) * 10n)
							
							let FillColor = "#00C000"
							let Shifted = 0n
							if (Subtracted <= 0n) {//Boxes that are removed.
								FillColor = "#B5E61D"
								Shifted = -10n
							}
							
							let Piece = createSVGElement("rect")
							Piece.setAttribute("x", Xpositioning.toString(10))
							Piece.setAttribute("y", (TileProcessYPositionRow+50n+Shifted).toString(10))
							Piece.setAttribute("width", "10")
							Piece.setAttribute("height", "30")
							Piece.setAttribute("stroke-width", "1")
							Piece.setAttribute("stroke", "#000000")
							
							Piece.setAttribute("fill", FillColor)
							SVGGraphToDisplay.appendChild(Piece)
						}
					}
				}
				function RepeatedSubtractionFills(Filled) {
					let TempFillAmount = Filled
					let Xpositioning = FilledPieceXPosition+VerticalLineXPos+20n
					let CurrentFillByteIndex = 0n
					
					function GeneratePieces() {
						let PieceFilledOrNot = createSVGElement("rect")
						PieceFilledOrNot.setAttribute("x", (Xpositioning).toString(10))
						PieceFilledOrNot.setAttribute("y", (TileProcessYPositionRow+30n).toString(10))
						PieceFilledOrNot.setAttribute("width", "10")
						PieceFilledOrNot.setAttribute("height", "30")
						PieceFilledOrNot.setAttribute("stroke-width", "1")
						PieceFilledOrNot.setAttribute("stroke", "#000000")
						
						let FillColor = "#00C000"
						if (TempFillAmount == 0n) {
							FillColor = "#808080"
						}
						
						PieceFilledOrNot.setAttribute("fill", FillColor)
						SVGGraphToDisplay.appendChild(PieceFilledOrNot)
						
						TempFillAmount--
						if (TempFillAmount < 0n) {
							TempFillAmount = 0
						}
						Xpositioning += 10n
					}
					function DisplayCurrentlyProcessedTileByte(NumberOfPieces) {
						if (CurrentFillByteIndex == FillByteTableIndex_RecentlyFilled) {
							let HighlightedBox = createSVGElement("rect")
							HighlightedBox.setAttribute("x", (Xpositioning-5n).toString(10))
							HighlightedBox.setAttribute("y", (TileProcessYPositionRow+30n-5n).toString(10))
							HighlightedBox.setAttribute("width", ((NumberOfPieces*10n)+10n).toString(10))
							HighlightedBox.setAttribute("height", "40")
							HighlightedBox.setAttribute("fill", "rgb(0,0,0,0)")
							HighlightedBox.setAttribute("stroke-width", "1")
							HighlightedBox.setAttribute("stroke", "#FFFF00")
							SVGGraphToDisplay.appendChild(HighlightedBox)
						}
					}
					function ByteTypeLabeling({ByteType = "", MiddleCount = 0n}) {
						let NameColor = {
							"Left End": "cyan",
							"Middle": "#00FF00",
							"Right End": "red"
						}
						let ByteTypeText = createSVGElement("text")
						//ByteTypeText.setAttribute("x", Xpositioning.toString(10))
						//ByteTypeText.setAttribute("y", TileProcessYPositionRow+80n)
						ByteTypeText.setAttribute("transform", "translate(" + (Xpositioning+5n).toString(10) + ", " + (TileProcessYPositionRow+70n).toString(10) + ")rotate(90)")
						
						ByteTypeText.setAttribute("fill", NameColor[ByteType])
						ByteTypeText.setAttribute("font-family", "monospace")
						if (ByteType == "Left End" || ByteType == "Right End") {
							ByteTypeText.setAttribute("asdf", "asdf")
						}
						let Text = ByteType
						if (ByteType == "Middle") {
							Text += " " + MiddleCount.toString(10)
						}
						ByteTypeText.appendChild(document.createTextNode(Text))
						SVGGraphToDisplay.appendChild(ByteTypeText)
					}
					if (GraphicalBarLeftEndPiece > 0n) {
						DisplayCurrentlyProcessedTileByte(GraphicalBarLeftEndPiece)
						ByteTypeLabeling({ByteType: "Left End"})
						for (let Countdown = GraphicalBarLeftEndPiece; Countdown > 0n; Countdown--) {
							GeneratePieces()
						}
						Xpositioning += 10n
						CurrentFillByteIndex++
					}
					for (let MiddleCountDown = GraphicalBarMiddleLength; MiddleCountDown > 0n; MiddleCountDown--) {
						DisplayCurrentlyProcessedTileByte(GraphicalBarMiddlePiece)
						ByteTypeLabeling({ByteType: "Middle", MiddleCount: GraphicalBarMiddleLength - MiddleCountDown + 1n})
						for (let FillCountDownPerTile = GraphicalBarMiddlePiece; FillCountDownPerTile > 0n; FillCountDownPerTile--) {
							GeneratePieces()
						}
						Xpositioning += 10n
						CurrentFillByteIndex++
					}
					if (GraphicalBarRightEndPiece > 0n) {
						DisplayCurrentlyProcessedTileByte(GraphicalBarRightEndPiece)
						ByteTypeLabeling({ByteType: "Right End"})
						for (let Countdown = GraphicalBarRightEndPiece; Countdown > 0n; Countdown--) {
							GeneratePieces()
						}
						Xpositioning += 10n
						CurrentFillByteIndex++
					}
				}
				function NextTile({Max = 0n}) {
					RemainingFill -= Max
					if (RemainingFill < 0n) {
						RemainingFill = 0n
					}
					TileProcessYPositionRow += TileProcessYPositionRow_Spacing
					FillByteTableIndex_RecentlyFilled++
				}
			let StartingFillAmountOutputTable = 0n
			function IncreaseFillByteTable(IncreaseBy) {
				StartingFillAmountOutputTable += IncreaseBy
				if (StartingFillAmountOutputTable > InputAmountFilled) {
					StartingFillAmountOutputTable = InputAmountFilled
				}
			}
			
			let FillByteTableIndex_RecentlyFilled = 0n
			
			if (GraphicalBarLeftEndPiece > 0n) { //Left end
				RepeatedSubtractionDisplay({Max: GraphicalBarLeftEndPiece})
				IncreaseFillByteTable(GraphicalBarLeftEndPiece)
				RepeatedSubtractionFills(StartingFillAmountOutputTable)
				NextTile({Max: GraphicalBarLeftEndPiece})
			}
			for (let MiddleLeft = GraphicalBarMiddleLength; MiddleLeft > 0n; MiddleLeft--) {
				RepeatedSubtractionDisplay({Max: GraphicalBarMiddlePiece})
				IncreaseFillByteTable(GraphicalBarMiddlePiece)
				RepeatedSubtractionFills(StartingFillAmountOutputTable)
				NextTile({Max: GraphicalBarMiddlePiece})
			}
			if (GraphicalBarRightEndPiece > 0n) {
				RepeatedSubtractionDisplay({Max: GraphicalBarRightEndPiece})
				IncreaseFillByteTable(GraphicalBarRightEndPiece)
				RepeatedSubtractionFills(StartingFillAmountOutputTable)
				NextTile({Max: GraphicalBarRightEndPiece})
			}
		}
	}
	function createSVGElement(tag) { //https://stackoverflow.com/questions/57894500/why-is-it-necessary-to-use-document-createelementns-when-adding-svg-tags-to
		return document.createElementNS('http://www.w3.org/2000/svg', tag)
	}
</script>