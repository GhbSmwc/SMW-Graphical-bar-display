<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
			img.img-hor {
				-moz-transform: scaleX(-1);
				-o-transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
				transform: scaleX(-1);
				filter: FlipH;
				-ms-filter: "FlipH";
			}
		</style>
	</head>
<body>
<center><h1>Graphical Bar ELITE</h1><br>
By <a href="https://www.smwcentral.net/?p=profile&id=18802">GreenHammerBro</a><br>
See <a href="https://github.com/GhbSmwc/SMW-Graphical-bar-display">github</a>.</center>

<h2>Introduction</h2>
<p>This is a guide on how to setup a display of a value of something as a graphical bar (or progress bar) that you see in many games. Unlike some hacks like
SMWCP2 and brutal Mario (both as health bars), which are 1-unit (or piece) per tile being displayed, this package contains code to display multiple units
per tile (8 units normally), as well as representing a ratio of something with any number (1-65535) as the max. This means that this can have more accurate
representation of a value (say it approximate to the nearest pixel instead of 8x8 tile) as a percentage and have any maximum amount without affecting the
length of the bar.</p>

<p>Make sure you read the comments at the top in the ASM files to fully understand them. This readme covers most of those info.</p>

<p>It supports both layer 3 and sprite OAM.</p>


<h2>Notes</h2>
<ul>
<li>This HTML uses <a href="https://en.wikipedia.org/wiki/ASCII_art">ASCII art</a> to represent something in few areas, so make sure you have your browser setting for <a href="https://en.wikipedia.org/wiki/Monospaced_font">fixed-width font</a> such as
&ldquo;Consolas&rdquo; so it displays properly.</li>
<li>You must have at least some ASM knowledge. See this ASM tutorial <a href="https://www.smwcentral.net/?p=section&a=details&id=14268">here.</a></li>
<li>If you want to easily select and copy text inside of boxes, hold down CTRL and double-click them.</li>
</ul>
<hr>
<h2>Quick jumps:</h2>
<ul>
<li><a href="#Installation" id="InstallationBack">Installation (test run, uberasm tool)</a></li>
<li><a href="#OwnGraphicalBar" id="OwnGraphicalBarBack">Displaying your own value as a graphical bar (Uberasm tool, Layer 3)</a></li>
<li><a href="#CustomSprites" id="CustomSprites_Back">Drawing OAM (Normal sprites (SMW sprites or pixi), not cluster, extended, minor extended, etc.)</li>
	<ul>
		<li><a href="#ProgrammingOtherCustomSprites" id="ProgrammingOtherCustomSprites_back">Programming with other sprites.</a></li>
		<li><a href="readme_files/GMKBossSummary.html" id="GMKBossSummary_TOCBack">Giant Masked Koopa boss editing example summary/tutorial</li>
	</ul>
<li><a href="#DrawOamPatch" id="DrawOamPatch_Back">Drawing OAM (not using sprite slots, but patch using OAM).</a></li>
<li><a href="#AsmDocumentation" id="AsmDocumentationBack">ASM Documentation</a></li>
<ul>
	<li><a href="#GraphicalBarELITE" id="GraphicalBarELITEBack"><kbd>GraphicalBarELITE.asm</kbd></a></li>
	<ul>
		<li><a href="#CalculateGraphicalBarPercentage" id="CalculateGraphicalBarPercentage_Back"><kbd>CalculateGraphicalBarPercentage</kbd></a></li>
		<li><a href="#DrawGraphicalBar" id="DrawGraphicalBar_Back"><kbd>DrawGraphicalBar</kbd></a></li>
		<li><a href="#DrawGraphicalBarSubtractionLoopEdition" id="DrawGraphicalBarSubtractionLoopEdition_Back"><kbd>DrawGraphicalBarSubtractionLoopEdition</kbd></a></li>
		<li><a href="#TOCRoundAwayFromComplete" id="TOCRoundAwayFromComplete_Back"><kbd>Round away from empty/full/both</kbd></a></li>
	</ul>
	<li><a href="#GraphicalBarConvertToTile" id="GraphicalBarConvertToTileBack"><kbd>GraphicalBarConvertToTile.asm</kbd></a></li>
	<ul>
		<li><a href="#ConvertBarFillAmountToTiles" id="ConvertBarFillAmountToTiles_Back"><kbd>ConvertBarFillAmountToTiles</kbd></a></li>
		<li><a href="#ConvertBarFillAmountToTilesDoubleBar" id="ConvertBarFillAmountToTilesDoubleBar_Back"><kbd>ConvertBarFillAmountToTilesDoubleBar</kbd></a></li>
		<li><a href="#ConvertBarFillAmountToTilesEdgeOverMultipleTiles" id="ConvertBarFillAmountToTilesEdgeOverMultipleTiles_Back"><kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTiles</kbd></a></li>
		<li><a href="#ConvertBarFillAmountToTilesIndirectAddressTable" id="ConvertBarFillAmountToTilesIndirectAddressTable_Back"><kbd>ConvertBarFillAmountToTilesIndirectAddressTable</kbd></a></li>
		<li><a href="#ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable" id="ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable_Back"><kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable</kbd></a></li>
	</ul>
	<li><a href="#GraphicalBarWriteToStatusBar" id="GraphicalBarWriteToStatusBarBack"><kbd>GraphicalBarWriteToStatusBar.asm</kbd></li>
	<ul>
		<li><a href="#WriteBarToHUD" id="WriteBarToHUD_Back"><kbd>WriteBarToHUD</kbd></a></li>
		<li><a href="#WriteBarToHUDLeftwards" id="WriteBarToHUDLeftwards_Back"><kbd>WriteBarToHUDLeftwards</kbd></a></li>
		<li><a href="#WriteBarToHUDVertically" id="WriteBarToHUDVertically_Back"><kbd>WriteBarToHUDVertically</kbd></a></li>
		<li><a href="#BarExtendLeft" id="BarExtendLeft_Back"><kbd>BarExtendLeft</kbd></a></li>
		<li><a href="#WriteBarStaticTileToHUD" id="WriteBarStaticTileToHUD_Back"><kbd>Write static tiles</kbd></a></li>
		<li><a href="#CountNumberOfTiles" id="CountNumberOfTiles_Back"><kbd>CountNumberOfTiles</kbd></a></li>
		<li><a href="#WriteDoubleEndedBar" id="WriteDoubleEndedBar_Back"><kbd>WriteDoubleEndedBar</kbd></a></li>
		<li><a href="#SetupStripe" id="SetupStripe_Back"><kbd>SetupStripe</kbd></a></li>
	</ul>
	<li><a href="#GraphicalBarOtherRoutines" id="GraphicalBarOtherRoutinesBack"><kbd>GraphicalBarOtherRoutines.asm</kbd></a></li>
	<ul>
		<li><a href="#MapRangeToStartAt0" id="MapRangeToStartAt0_Back"><kbd>MapRangeToStartAt0</kbd></a></li>
		<li><a href="#InvertQuantity" id="InvertQuantity_Back"><kbd>InvertQuantity</kbd></a></li>
	</ul>
	<li><a href="#RoutinesInDrawOamPatch" id="RoutinesInDrawOamPatch_Back">Routines in <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd> and <kbd>Pixi_CustomSprite/Pixi Routines</kbd></a></li>
	<ul>
		<li><a href="#DrawOamGraphicalBarHorizVert" id="DrawOamGraphicalBarHorizVert_Back"><kbd>DrawOamGraphicalBarHoriz</kbd> and <kbd>DrawOamGraphicalBarVert</kbd></a></li>
		<li><a href="#FindNFreeOAMSlot" id="FindNFreeOAMSlot_Back"><kbd>FindNFreeOAMSlot</kbd></a></li>
		<li><a href="#DrawSpriteGraphicalBarHorizVert" id="DrawSpriteGraphicalBarHorizVert_Back"><kbd>DrawSpriteGraphicalBarHoriz</kbd> and <kbd>DrawSpriteGraphicalBarVert</kbd></a></li>
	</ul>
</ul>
<li><a href="#Notes" id="NotesBack">Notes</a></li>
<li><a href="#Credits" id="CreditsBack">Credits</a></li>


</ul>
<hr>
<h2>The resources you need</h2>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=18113">Uberasm tool</a>, needed for codes to run every frame.</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=18716">Lunar Magic</a>, for level testing purposes.</li>
</ul>
<h2>Stuff you MAY need</h2>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=19545">Shared subroutines patch</a>, if you wanted to not have duplicate subroutines in your game.</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=25953">Asar</a></li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=26026">pixi</a></li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=15222">Overworld Border plus</a>, required if you want to display a graphical bar on the overworld border
(i.e <kbd>UberasmTool_ExampleUsage/Gamemode0E_OWBorderTest.asm</kbd>)</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=24816">No More Sprite Tile limits</a>, if you are going to use the pixi custom sprite that draw a bar on OAM.</li>
</ul>
<h3>Recommended resources</h3>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=16031">Super Status Bar patch</a>, SMW's status bar (or, heads-up display (HUD)) space is really small.</li>
<li>
	<a href="https://www.smwcentral.net/?p=section&a=details&id=29064">Address tracker v4+</a>, if you already have inserted other ASM stuff that occupies freeram, I made it so it sets the RAM for you to avoid conflicts:
<table><tr><td><pre>
GraphicalBar	!Scratchram_GraphicalBar_LeftEndPiece	1	-	-
GraphicalBar	!Scratchram_GraphicalBar_MiddlePiece	1	-	-
GraphicalBar	!Scratchram_GraphicalBar_RightEndPiece	1	-	-
GraphicalBar	!Scratchram_GraphicalBar_TempLength	1	-	-
GraphicalBar	!Scratchram_GraphicalBar_FillByteTbl	12	-	-
GraphicalBar	!Freeram_RangeBasedValue	2	-	-
GraphicalBar	!Scratchram_WhatRange	2	-	-</pre></td></tr></table>
	After getting the results, just place it at the bottom after ALL the free/scratch RAM defines (will override the previous default values).
</li>
</ul>
<h2>Javascript tools</h2>
<p>Note many of these uses <kbd><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</a></kbd>, to avoid potential precision issues with double-precision. Make sure your browser
supports it.</p>
<ul>
	<li><a id="TopJSLink" href="readme_files/JS_GraphicalBarCalculator3.html">Calculate the graphical bar's memory usage</a></li>
	<li><a id="CalculatePercentageRoundBounds" href="readme_files/Js_GraphicalBar_PercentageRoundBounds.html">CalculateGraphicalBarPercentage's range of inputs to amount of pieces filled</li>
	<li><a id="OAMNotes" href="readme_files/JS_OAM_Side_notes.html">OAM table and conversion sheet</a></li>
	<li>Tile property converters. Note they're not the same, rather similar, layer 3 has 2-bits (0-3) for page number and 1-bit (0-1) for priority, while sprites
have 1-bit for page number and 2-bits of priority:</li>
<ul>
	<li><a id="Layer3Props" href="readme_files/JS_YXPCCCTT.html">Layer 3 properties (YXPCCCTT) converter</a></li>
	<li><a id="SpriteProps" href="readme_files/JS_YXPPCCCT.html">Sprite properties (YXPPCCCT) converter</a></li>
</ul>
	<li><a id="StripeHeaderConverter" href="readme_files/JS_StripeHeaderConverter.html">Stripe header converter</a></li>
	<li><a id="CenterBar" href="readme_files/JS_BarOAMCenterPos.html">Getting the sprite graphical bar to center with the sprite</a></li>
</ul>

<hr>
<h2><a href="#InstallationBack" id="Installation">^</a>Installation (test run, uberasm tool)</h2>
<ol>
<li>First make any necessary changes to the defines in <kbd>GraphicalBarDefines</kbd>. Assuming you testing this out on a clean ROM with nothing
else besides LM making modifications, it is likely you don't have to edit anything. However, if you're planning to use the Super Status Bar patch, open
<kbd>StatusBarSettings.asm</kbd> and change <span class="NoLineBreak"><kbd>!StatusBarFormat</kbd></span> to <kbd>$02</kbd> and <span class="NoLineBreak"><kbd>!StatusBar_UsingCustomProperties</kbd></span>
to <kbd>1</kbd> so that it displays properly.<br><br>
<ul>
<li>Don't forget, if you want to display a graphical bar on the overworld, you need to install the Overworld Border Plus patch (using the vanilla OWB is very difficult
to modify, and that codes here only supports the OWB+ patch). Remember that this have the same tile data format as the super status bar patch, don't worry about
<kbd>!StatusBarFormat</kbd> (this only influences the status bar-related code and not the border) as the routines support hybrid tile formats (you can have status
bar's &ldquo;each next tile is next byte&rdquo; format and OWB+'s &ldquo;each next tile is next 2 bytes over, provided you have set <kbd>!OWPlusAndSSBSameFormat</kbd> to <kbd>0</kbd>).</li><br>

<li>Another thing to note is the define <kbd>!StatusBar_UsingCustomProperties</kbd>, this applies to <span sty;e="font-weight: bold;">both</span> the status bar and the overworld border plus patch. This is because both
writes to the status bar and the border reuses the same &ldquo;write tile&rdquo; routine to save space. Thankfully, most status bar patches that are layer 3-based,
regardless of the formats, will likely enable you to edit their tile properties, so its more likely you have to set this define to 1 (its 0 by default).</li><br>
</ul>

</li>
<li>Now paste the folders:
<ul>
<li><kbd>GraphicalBarDefines</kbd> (the folder itself) &rightarrow; Uberasm tool's main directory (same area as the .exe)</li>
<li>Inside <kbd>Routines</kbd> folder*, <kbd>GraphicalBarELITE.asm</kbd>, <kbd>GraphicalBarOtherRoutines</kbd>, <kbd>GraphicalBarConvertToTile.asm</kbd>, and <kbd>GraphicalBarWriteToStatusBar.asm</kbd> &rightarrow; Uberasm tool's <kbd>library</kbd>.</li>
<li><span style="font-weight: bold;">Inside</span> the folder <kbd>UberasmTool_ExampleUsage</kbd>, they go to their respective locations based on their filename.</li>

<p>*Please note that if you wish to test <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd>, only copy these files, don't move (&ldquo;cut&rdquo;) to the parent/subdirectory or rename them, else you get errors upon patching.</p>
</ul></li>
<li>Open uberasm tool's <kbd>list.txt</kbd>, and paste these so that the codes get inserted:
<table><tr><td><pre>; Level list. Valid values: 000-1FF.
level:
104		Level_DoubleBar.asm
105		Level_Simple.asm
106		Level_RoundAwayFromComplete.asm

;[...]

gamemode:
; Insert files here
;0E		Gamemode0E_OWBorderTest.asm ;&gt;Need OWB+ patch to function!</pre></td></tr></table><br>
</li>
<li>Insert the graphics by:
<ol>
<li>Create the &ldquo;ExGraphics&rdquo; if you haven't done so by clicking on the blue mushroom in Lunar Magic.</li>
<li>Paste the graphic bin files (from this package's <kbd>ExGraphics/Layer3/Level</kbd>) of your choice. The graphics include but not limited to:
<ul>
	<li>Transparent background: <img src="readme_files/TransperentBackground.png"></li>
	<li>Black background: <img src="readme_files/BlackBackground.png"></li>
	<li>Megaman-styled: <img src="readme_files/MegamanHPBar.png"> Note: make sure you follow the instructions provided in the html file (<kbd>TileTable.html</kbd>) it came with it in the same directory as the graphics file, because
	the amount of units per tile are different as well as the tile table.</li>
</ul>
Please note that there are huge combinations of this due to how many variations there are (<a href="readme_files/DoubleBarInfo.html">double bar</a>, <a href="readme_files/FillEdgeCrossingTileBorder.html">custom fill-edges</a> etc).
Then, take out the appended characters after the &ldquo;<kbd>ExGFX&lt;number&gt;</kbd>&rdquo; but before the &ldquo;<kbd>.bin</kbd>&rdquo;.<br><br>

Note: If you're using the minimalistic status bar patch, I recommend using &ldquo;BlackBackground&rdquo; to be able to see the entire bar (including a part that is empty); since
the outlines on &ldquo;TransperentBackground&rdquo; would camouflage and you only see the fill amount, unless you change the minimalistic status bar patch's background color.<br><br>

This readme assumes you're using &ldquo;TransperentBackground&rdquo;.</li><br>
<li>Now in your level editor, click on the green poision mushroom to open a dialog about Layer 3 GFX bypass. On LG1, set that
to use the graphic files (obviously the bin files are conveniently named to tell you what slot uses what file). Level 105
and 106 LG1s to be slot 80, but for 104, it needs LG1 to be slot 81 and LG2 to be slot 82 to accommodate the large number of
tiles. Then hit OK and save to apply the changes.
</li>
</ol>
</li>
<li>Now you are done, although there are more example codes than provided here, given that you can play up to 3 levels from the get-go without beating them and without editing the overworld. If you want to test
thats not listed here, read the comments at the top in the ASM files, the filenames should be obvious on where to insert (and don't forget to edit the list again). The examples follows:
<ul>
<li>Level 104 (Yoshi's house) is a double-bar, which can display two &ldquo;fills&rdquo; overlapping each other (<img width="96" src="readme_files/DoubleBarFills_AnotherColor.png">). Press and hold right, then
press and hold up to see. If you're using the Super Status Bar patch (and have modified the defines so that the code adopts to it), it will display 4 hex numbers at the top right, displaying the first column the amount and fill-percentage amount of FirstFill
and the other column for SecondFill.</li>
<li>Level 105 (Yoshi's island 1) is a progress meter, keep heading right to see it fills up.</li>
<li>Level 106 (Yoshi's island 2) is a coin meter, once 99 is reached, it should be full. It also avoids displaying 0% if if not 0 coins and 100% less than 99 coins,
a failsafe measure to avoid misleading value displays.</li>
<li>On the overworld border, measures Mario's Bonus Stars (does not measure Luigi's if 2-player mode).</li>
</ul>

If you're not using the Super Status Bar patch, the bar will be displayed over the word &ldquo;TIME&rdquo; and the coin symbol. The palette will be yellow on some areas,
but thats intentional as SMW's status bar is very limited.
</li>
</ol>
<hr>
<h2><a href="#OwnGraphicalBarBack" id="OwnGraphicalBar">^</a>Displaying your own value as a graphical bar (Uberasm tool, Layer 3)</h2>
Perhaps if you want to display something other than the provided examples above, here are the templates:

<ul>
<li>A simple graphical bar.
<table><tr><td><pre>incsrc "../GraphicalBarDefines/GraphicalBarDefines.asm"
incsrc "../GraphicalBarDefines/StatusBarSettings.asm"
;^These are needed so the defines relating to the graphical bars work.

main:		;&gt;You DO need this if using uberasm tool.
.InputRatio
	LDA <span style="color: red">$0DBF|!addr</span>						;\Quantity low byte (example: current HP). Use RAM here.
	STA !Scratchram_GraphicalBar_FillByteTbl		;/
	LDA <span style="color: red">#$00</span>						;\High byte of above. Should your value here is 8-bit or only 1 byte long,
	STA !Scratchram_GraphicalBar_FillByteTbl+1		;/use [LDA #$00 : STA !Scratchram_GraphicalBar_FillByteTbl+1].
	LDA <span style="color: red">#$63</span>						;\Max quantity low byte (example: max HP). Can be a fixed value (#$) or adjustable RAM in-game.
	STA !Scratchram_GraphicalBar_FillByteTbl+2		;/
	LDA <span style="color: red">#$00</span>						;\High byte of above, same format as &lt;Value_high_byte&gt;, so do the same
	STA !Scratchram_GraphicalBar_FillByteTbl+3		;/as that if your value is 8-bit.
.InputGraphicalBarAttributes
	LDA.b <span style="color: green">#!Default_LeftPieces</span>				;\Left end normally have 3 pieces.
	STA !Scratchram_GraphicalBar_LeftEndPiece		;/
	LDA.b <span style="color: green">#!Default_MiddlePieces</span>				;\Number of pieces in each middle byte/8x8 tile
	STA !Scratchram_GraphicalBar_MiddlePiece		;/
	LDA.b <span style="color: green">#!Default_RightPieces</span>				;\Right end
	STA !Scratchram_GraphicalBar_RightEndPiece		;/
	LDA.b <span style="color: green">#!Default_MiddleLength</span>				;\length (number of middle tiles)
	STA !Scratchram_GraphicalBar_TempLength			;/
.ConvertToBar
	JSL GraphicalBarELITE_CalculateGraphicalBarPercentage		;&gt;Get percentage
	<span style="color: orange">JSL GraphicalBarELITE_RoundAwayEmptyFull</span>
	JSL GraphicalBarELITE_DrawGraphicalBar				;&gt;get bar values.
	STZ $00								;&gt;Use Level-layer3 tileset
	JSL GraphicalBarConvertToTile_ConvertBarFillAmountToTiles	;&gt;Convert tiles.
	LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Tile</span>				;\Setup address to where to draw the bar.
	STA $00								;|
	LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Tile>>8</span>			;|
	STA $01								;|
	LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Tile>>16</span>			;|
	STA $02								;/
	if !StatusBar_UsingCustomProperties != 0
		LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Properties</span>				;\Same as above but properties
		STA $03								;|
		LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Properties>>8</span>			;|
		STA $04								;|
		LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Properties>>16</span>			;|
		STA $05								;/
		if !Default_LeftwardsBar == 0
			LDA.b <span style="color: green">#!Default_StatusBar_TilePropertiesSetting</span>			;\Properties
		else
			LDA.b <span style="color: green">#(!Default_StatusBar_TilePropertiesSetting|(!Default_LeftwardsBar<<6))</span>
		endif
		STA $06								;/
	endif
	if !Default_LeftwardsBar == 0
		if !StatusBarFormat = $01
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUD			;&gt;Write to status bar
		else
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUDFormat2		;&gt;Write to status bar
		endif
	else
		if !StatusBarFormat = $01
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUDLeftwards
		else
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUDLeftwardsFormat2
		endif
	endif
	RTL
	</pre></td></tr></table><br>
Font colored in <span style="color: red">red</span> is the things you change, while the <span style="color: green">green</span>, you edit values in the defines via opening up
<kbd>GraphicalBarDefines/StatusBarSettings.asm</kbd> and changing those, and yes, you can safely redefine them when you have multiple bars for advanced use. <span style="color: yellow">Yellow</span>
is the same as green, but it has to be a 3-byte (24-bit) address. <span style="color: orange">Orange</span> means you can remove the rounding away code if you want the bar to be able to round
towards empty or full. Of course, the <kbd>#</kbd> symbol means a fixed number instead of a RAM address.<br><br>

Also if you are handling 16-bit mode quantity while on 8-bit accumulator, you write the 16-bit number <kbd>#$1234</kbd> (a fixed value not stored in RAM) as
storing the <kbd>#$34</kbd> onto the low byte and <kbd>#$12</kbd> on the high byte (if it was RAM, it should be obvious, low byte written to low byte and high to high). Remember that
the SNES is <a href="https://en.wikipedia.org/wiki/Endianness">little-endian</a> when the number stored as bytes are adjacent from one another in memory.</li><br>

<li>Double Bar. Displays 2 fills like this: <img src="readme_files/GraphicalBarFillsAnimation.gif">, which is useful for displaying changes such as how much HP was lost. See
<a id="DoubleBar" href="readme_files/DoubleBarInfo.html">this information</a>. The colored fonts last mentioned above code also applies on codes here as well.</li>

</ul>
<hr>
<h2><a href="#CustomSprites_Back" id="CustomSprites">^</a>Drawing OAM (Normal sprites (SMW sprites or pixi), not cluster, extended, minor extended, etc.)</h2>
<p>While this code library was originally meant to be used with layer 3 status bar on uberasm tool, I added new features that would support sprite OAM.<p>

<p>Due to the limitation of pixi that you cannot have multiple subroutines in a single ASM file with sprites calling other than the first subroutine (call
via a subroutine label), they have to be seperated into multiple ASM files.</p>

<p>Also, for the sake of making it easier to find graphical bar-related routines in pixi's routines folder, I prepended their filenames with
&ldquo;<kbd>GraphicalBar</kbd>&rdquo; so that when sorted alphabetically, they are all together. (at the moment, all routine ASM files must be in the routines folder, not in any subdirectory).</p>

<p>Please note that while I did have pixi versions of graphical bar-related routines in <kbd>Pixi_CustomSprite/Pixi Routines</kbd>, I did not include all the subroutines:
<ul>
	<li>Mainly routines in <kbd>GraphicalBarConvertToTile</kbd>, such as <kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTiles</kbd>, this is because that would mean even more tiles are needed, and sprite tiles are very limited
	espically if you have other custom sprites in your hack (such as the Giant Masked Koopa Boss)</li>
	<li>It does not include <kbd>DrawGraphicalBar</kbd> but it does include <kbd>DrawGraphicalBarSubtractionLoopEdition</kbd> as an alternative. This is because the former needed to use the multiplication and division routines,
	which results having longer code, while the latter does not use <b>any</b> external subroutines at all. And sprites are often the culprit of slowdown, so a simpler code is a viable option.</li>
</ul>
</p>
<p>To get started, you'll need pixi, obviously. I also strongly recommend using the &ldquo;No more sprite tile limits&rdquo; patch, as obviously you can easily run into tile limitations and also OAM tiles could be in front or behind
another when they shouldn't.

I recommend having the knowledge of how sprites work before doing this. Here is a <a href="https://www.smwcentral.net/?p=viewthread&t=92218">tutorial</a>.
<h3>Insertion process (test sprite)</h3>
<ol>
	<li>Defines: Same as uberasm tool, make sure you make necessary changes and have the up-to-date information (if you have multiple copies of this, they must all have the latest editions on it). Then have the <b>folder</b>
	<kbd>GraphicalBarDefines</kbd> in the main directory of pixi (where the <kbd>.exe</kbd> program is at).</li>
	<li>
		Sprite insertion: In, <kbd>Pixi_CustomSprite</kbd>, choose a folder of which sprite you want to test, copy the <b>asm</b> and <b>json</b> or <b>cfg</b> file they contain (don't copy the folder itself), and paste them directly in pixi's sprites folder.
	</li>
	<li>
		Routines insertion: Obviously you should find <kbd>Pixi Routines</kbd> folder, open that, copy all the ASM files (not the folder itself), and paste that in pixi's <kbd>routines</kbd> folder.
	</li>
	<li>
		Tile table modification of <kbd>GraphicalBarConvertBarFillAmountToTiles.asm</kbd>: Because the sprites had to have a different tile numbers for the graphical bar tiles, they have to have different fill&rightarrow;TileNumber conversions.
		By default, it uses <kbd>GraphicalBarSimpleTest/SpriteGraphicalBarTest.asm</kbd> and <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd>. The included graphics for pixi sprites have <kbd>TileTable.html</kbd>, follow the instructions in those,
		copy the table, then open <kbd>GraphicalBarConvertBarFillAmountToTiles.asm</kbd> in pixi's routines, and replace the sprite tile table with what you copied.
	</li>
	<li>
		Now open or create <kbd>list.txt</kbd>, and have the following text written (for sprites you didn't pasted in the sprites folder, remove them off the list):
<table><tr><td><pre>00 SpriteGraphicalBarTest.json
01 giant_masked_koopa.cfg
02 masked_koopa_fireball.cfg
03 masked_koopa_rock.cfg</pre></td></tr></table>
		And now save. If you have the fireball and rock sprite at a different sprite ID number, you have to edit <kbd>giant_masked_koopa.asm</kbd>'s defines to spawn the correct sprite.
	</li>
	<li>Now run pixi.exe to insert.</li>
	<li>
		Go to <kbd>ExGraphics/Sprite</kbd> and choose either or both: <kbd>GiantMaskedKoopaTest</kbd> and <kbd>SimpleTest</kbd>, depending on what sprite you want to test. copy one of those files
		(it depends if you want a horizontal bar or a vertical bar, but the GMK boss only supports horizontal), paste it in your ExGraphics folder. If you do not have them, press &ldquo;Quick Extract ExGFX from ROM&rdquo;, which is the blue
		mushroom to make the Exgraphics folder appear.
	</li>
	</li>
	<li>And you are done. If you are planning to use this code within the custom sprite's code, continue doing the steps below.</li>
</ol>
<p><kbd>SpriteGraphicalBarTest.asm</kbd> will show a 16x16 egg sprite (or some other 16x16 tile depending on your graphic settings), along with the bar graphic. The 16x16 tile is meant to show the origin position
of the sprite and how the bar is position in relation to it.</p>

<p>The GMK boss is an example boss sprite that draws a HP bar underneith it.</p>

<h3><a href="#ProgrammingOtherCustomSprites_back" id="ProgrammingOtherCustomSprites">^</a>Programming with existing custom sprites</h3>
<p>Note: You must have some mid-level of knowledge of ASM, as here you must learn how to:
<ul>
<li>Know which scratch RAM is currently used for other purpose during code execution, and be able to relocate them to another RAM should they conflict (2+ different data using the same address(es)) or use
the stack (PHA...PLA)</li><br>
<li>Finding an appropriate place or rearranging to insert the code, due to certain values like indexes and scratch RAM are still being used for a specified purpose (for example: if scratch RAM is used for indirect addressing to write an array of sprite tiles,
we don't want to put our code there, instead we place it at a location that is <i>before</i> (or <i>after</i>, depending on the code structure of the sprite) scratch RAM becomes reserved for addressing).</li><br>
<li>Preserve sprite index (usually on the X index register), often by doing push/pull them (like <kbd>PHX</kbd> (before X is being used for something else)...<kbd>PLX</kbd> (after done using X for something else)) them (or just <kbd>LDX $15E9|!addr</kbd> after done using X for something else), as many stuff and subroutines (including ones here) uses the X register for other things.</li><br>
</ul>
Many sprites on the sprite section on SMWC can be complex and have different coding structures, but following the principals above should make it possible to implement on any sprite.<br>
Another important note is that the routine <kbd>%GetDrawInfo()</kbd> uses <span style="font-weight: bold;">a destroy-return-address</span>-- A stack-manipulation technique to &ldquo;double-exit&rdquo; the subroutine upon returning (RTS/RTL), consider this simple example shown below:
<table>
<tr><td><pre>	JSR Subroutine
	STZ $00
	RTL
	
	Subroutine:
	JSR InnerSubroutine		
	NOP		;\Just for demonstration purposes, it does nothing.
	NOP		;|These will not be executed
	NOP		;/
	RTS
	
	InnerSubroutine:
	PLA		;\Pull 2 bytes out (the amount of bytes pushed when JSR'ing)
	PLA		;/This destroys the return address to where the 3 NOPs are at in the stack.
	RTS		;&gt;Upon executing this, instead of going to where the 3 NOPs are at, it goes to the STZ $00 after "JSR Subroutine".
	
	;What it executes, it performs in this order:
	;[] = a byte in memory
	;[--] = other stuff in the stack or potentially garbage
	;[SS] = Return address location after JSR Subroutine
	;[II] = Return address location after JSR InnerSubroutine
	;(1) JSR Subroutine		;&gt;stack: [--][--][--][--][SS][SS]
	;(2) JSR InnerSubroutine	;&gt;stack: [--][--][II][II][SS][SS]
	;(3) PLA			;\stack: [--][--][--][--][SS][SS] (we destroyed [II][II])
	;(4) PLA			;/
	;(5) RTS			;&gt;stack: [--][--][--][--][--][--] (jumps to after "JSR Subroutine" ([SS][SS]))
	;(6) STZ $00
	;(7) RTL
	;JSR pushes 2 bytes of address into the stack (more specifically, the next instruction's location, minus 1 into the stack)
	;RTS pulls 2 bytes of address out of the stack (specifically, the location address in the stack. Takes that, add 1, and sets the program counter to jump there)
	;The same applies to JSL and RTL, but 3 bytes instead.
</pre></td></tr>
</table>
Therefore, if you push something, you must pull before calling <kbd>%GetDrawInfo()</kbd> as the game will crash upon the sprite going offscreen (it doubles-out if the sprite goes offscreen, else it keeps the return address).
</p>
<ol>
	<li>Go to the graphics portion of the code (thankfully, they are conveniently named and 99.99% of the time use <kbd>%GetDrawInfo()</kbd>). You want to know these informations
		<ul>
			<li>The total number of tiles it uses. Before calling the &ldquo;finish OAM write&rdquo; (done by calling <kbd>JSL $01B7B3</kbd> or <kbd>%FinishOAMWrite()</kbd>), you'll need
			to find out the total number of tiles, including the bar itself, and subtract by 1. A common method, is by taking the number of tiles on the sprite's body, minus 1, and then
			add by number of tiles of the bar, without the minus 1 on that itself (<kbd>(SpriteBodyTileCount - 1) + BarTileCount</kbd>), Another method to do so is by getting the total
			(sprite's body + graphical bar) first, and then subtract by 1, and avoid subtracting
			by 1 again for the graphical bar (you'll subtract by 2 which isn't what you want) therefore resulting <kbd>(SpriteBodyTileCount + BarTileCount) - 1</kbd>.</li><br>
			
			<li>The tile sizes. Most sprites on SMWC are composed of 16x16 tiles, so you'll likely need to manually set the tile size</li><br>
		</ul>
	</li>
	<li>If you happen to want a graphical bar on a sprite that is composed of at least 1 16x16 OAM tile (most sprites are like that, by the way), you'll have to
	manually handle the size of editing <kbd>$0460</kbd> in the sprite code (a mixture of 8x8s and 16x16, like the timed lift sprite (the platform itself is 2 16x16s and the number graphic in the center is a single 8x8.)):
<table><tr><td><pre>;Manually set sprite tile size to 16x16 (this is for the main body of the sprite).

;Note: This may different depending on the sprite being used, for example, the Giant
;Masked Koopa Boss uses the X as the OAM index instead of Y because of indirect
;addressing opcode limitations (There is no [&lt;Opcode&gt; ($xx),x], and Y is
;used for its image state).

	PHY			;&gt;Push OAM index (You'll need this if you are still using the Y OAM index afterwards, especially if you are writing multiple tiles via a loop).
	TYA			;\Convert index to OAM slot numbering
	LSR #2			;|
	TAY 			;/
	LDA $0460|!addr,y	;\Manually set the size bit to 16x16
	ORA.b #%00000010	;|
	STA $0460|!addr,y	;/
	PLY			;&gt;Restore OAM index
	;[...]
;Finish OAM write:
	LDY #$FF		;&gt;The graphical bar tiles are always 8x8, but the sprite's body isn't always 8x8 or 16x16. Y=$FF means mixture
	;A = total number of tiles to write, -1
	&lt;instruction to get the number of tiles, minus 1, into the A register&gt;
	&lt;Either call using JSL $01B7B3, or use %FinishOAMWrite().&gt;</pre></td></tr></table>
	</li>
</ol><br></p>

<p>The GMK boss that I edited, is <a href="readme_files/GMKBossSummary.html" id="GMKBossSummary_Back">explained here</a> as an example.</p>

<p>I conveniently named the folders, so it shouldn't be difficult. The ASM and graphics are separated, however (graphics are in <kbd>ExGraphics/Sprite/GiantMaskedKoopaTest</kbd>). Everything is effectively the same as
<kbd>GraphicalBarSimpleTest</kbd> except the bar having an actual purpose and the sprite is a boss sprite. Open the ASM file <kbd>giant_masked_koopa.asm</kbd>, and there will be comments I added to show an example
on how to implement a sprite graphical bar (in this example, a HP bar).</p>

<p>Don't forget: Because the boss sprite takes a considerable amount of 8x8 tiles, the bar tile numbers table for <kbd>ConvertBarFillAmountToTiles</kbd> had to be relocated. Open <kbd><a href="ExGraphics/Sprite/GiantMaskedKoopaTest/TileTable.html" target="_blank">ExGraphics/Sprite/GiantMaskedKoopaTest/TileTable.html</a></kbd>, copy the table,
open <kbd>GraphicalBarConvertBarFillAmountToTiles</kbd> and paste the table under &ldquo;sprite&rdquo;.

alternatively, you could just use <kbd>ConvertBarFillAmountToTilesIndirectAddressTable</kbd>/<kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable</kbd> instead and edit the code so that it supplies the table. This is good for situations where you have 2 sprites
in your game that have different tile layouts that you want them to display a bar.</p>
<hr>
<h2><a href="#DrawOamPatch_Back" id="DrawOamPatch">^</a>Drawing OAM (not using sprite slots, but patch using OAM).</h2>
<p>This is similar to the sprite version, but written using a patch. Using a hijack at <kbd>$00A2E6</kbd> and running the patch's OAM handler AFTER processing all sprites (including after $028AB1), gives
the benefit of tile priority so that no other sprite will overlap the bar (OAM is handled so that the lower indexes have higher priority and is rendered in front of the high-indexed OAM slots).</p>
What you need is Asar, a patching tool.
To install:
<ol>
	<li>ASM:
		<ol>
			<li>Again and again with the defines, make necessary changes to it, and make sure it is up to date</li>
			<li>Simply patch <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd> to your game. Please note that this ASM file refers to the defines and routines folder on the main directory of this pack, so don't move or rename
			the files it is referring to. Just use asar on this file directly.</li>
			<li>Make sure the tile table to convert from fill amounts to tiles are correct, by default, it is using the correct graphics, unless you replaced it with the GMK graphics, a backup exists in <kbd><a href="ExGraphics/Sprite/SimpleTest/TileTable.html" target="_blank">ExGraphics/Sprite/SimpleTest/TileTable.html</a></kbd>.</li>
		</ol>
	</li>
	<li>Graphics:
		<ol>
			<li>Insert the graphics, use this one: <kbd>ExGraphics/Sprite/SimpleTest</kbd>, not the GMK boss.</li>
		</ol>
	</li>
	<li>And you are done. Feel free to take a look at the contents of <kbd>DrawOamPatch.asm</kbd> to learn how it works. Most of the codes are the same as the layer 3 version, but writes to OAM instead.</li>
</ol><br>

You can uninstall it by simply opening <kbd>GraphicalBarDefines/SpriteOAMSettings.asm</kbd>, and set <kbd>!PatchSprite_Uninstall</kbd> to <kbd>1</kbd>, and then re-apply the patch.
<hr>
<h2><a href="#AsmDocumentationBack" id="AsmDocumentation">^</a>ASM Documentation</h2>
Note: All values here are unsigned. Routine information follows:
<ol>
<li><a href="#GraphicalBarELITEBack" id="GraphicalBarELITE">^</a>Inside <kbd>GraphicalBarELITE.asm</kbd></li>
<ul>
<li><a href="#CalculateGraphicalBarPercentage_Back" id="CalculateGraphicalBarPercentage">^</a><kbd>CalculateGraphicalBarPercentage</kbd>: Calculates the ratio of <kbd>Quantity/MaxQuantity</kbd> to convert to X over the number of pieces (the whole bar).
For example: 50/100 on a 62-pieced bar outputs value of 31.</li>
<table>
<tr>
<th>RAM input</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl</span></span></kbd> to
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl+1</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">2</td>
<td>The number (16-bit unsigned) or amount of something out of the maximum (known as the &ldquo;<kbd>Quantity</kbd>&rdquo;).</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl+2</span></span></kbd> to
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl+3</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">2</td>
<td>The maximum amount (16-bit unsigned) something (known as &ldquo;<kbd>MaxQuantity</kbd>&rdquo;).</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_LeftEndPiece</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td rowspan="4">Graphical bar attributes. The ones with the word &ldquo;piece&rdquo; refer to the number of pieces
or units in their respective byte or 8x8 tile. When 0, they are not included in the table. <kbd>!Scratchram_GraphicalBar_TempLength</kbd>
is the number of repeated middle tile bytes between the left and right end tile bytes.<br><br>

The reason why the pieces setup is RAM-based is so you can have different number of pieces in any bar part (left, middle, and right), for example,
<a href="readme_files/LeftEndMorePieces.png" target="_blank"> 6 pieces for left end</a> along with 3 in the same routine. However, you have to have
both tables in the tile converter in <kbd>GraphicalBarConvertToTile.asm</kbd> to avoid glitched tiles.</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_MiddlePiece</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_RightEndPiece</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_TempLength</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
</table>
Result:
<table>
<tr>
<th>Output</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$01</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">2</td>
<td>The amount of fill as a &ldquo;percentage&rdquo; (known as &ldquo;<kbd>FillAmount</kbd>&rdquo;). Calculated by <kbd>FillAmount = <abbr title="During division, if the remainder is less than half the divisor, would round down to nearest integer, otherwise if greater than or equal to, rounds up to nearest integer.">RoundHalfUp</abbr>(Quantity * TotalNumberOfPiecesInBar / MaxQuantity)</kbd>
If max quantity is 0, a division by zero occurs, and outputs <kbd>$FFFF</kbd>. If you are familiar with what that is, that is <a href="https://en.wikipedia.org/wiki/Cross-multiplication">cross-multiplying</a> to convert fractions.<br><br>

Because we are dealing with integer values and rounding after division, if you have more MaxQuantity than MaxFill, then several quantity values may result in the same number of pieces filled. See <a href="readme_files/Js_GraphicalBar_PercentageRoundBounds.html" id="CalculateGraphicalBarPercentage_Discription">this</a> to view the distribution of values to each fill amount<br><br>

Note that this is not capped at total pieces in the bar, meaning that if <kbd>Quantity</kbd> is greater than <kbd>MaxQuantity</kbd>, this routine will output the number of pieces in the bar greater than its maximum, although <kbd>DrawGraphicalBar</kbd> and
<kbd>DrawGraphicalBarSubtractionLoopEdition</kbd> will treat it as capped.<br><br>

As a side note to most programmers, yes, I could alternatively perform <kbd>FillAmount = (Quantity / MaxQuantity) * TotalNumberOfPiecesInBar</kbd>, but we are dealing with integers, not floating points. Performing that
causes problem where the value could output only 0 or any number that is a multiple of n pieces in the bar (will display 0% or 100% but not in between when displayed) due to division rounding the quotient to the nearest
integer, which the error is between 0 and 1, before multiplying by <kbd>TotalNumberOfPiecesInBar</kbd> and scaling that error by an enormous amount:
<table><tr><td><pre>1 out of 3 HP = 20.[6] out of 62 pieces (bracket means repeating digits)

The correct way: (1 * 62) / 3

	1 * 62 = 62, multiplying 2 integers always results in the correct number assuming no overflows. However since the
	multiplication routine used here is 16-bit * 16-bit = 32-bit, overflows are not possible
	(65,535 * 65,535 = 4,294,836,225) is less than 4,294,967,295, the maximum unsigned 32-bit integer (close though).
	
	62 / 3 = 20.[6] the routine would've round this number to 21, making the error tiny off by 0.[3]

The incorrect way: (1 / 3) * 62

	1/3 = 0.[3], the routine would've round this number to 0, making the error 0.[3]
	
	0 * 62 = 0, the routine is now off by a huge 20.[6] units.
</pre></td></tr></table>
Therefore it's best to perform calculations in a way that rounding to only be applied on the final operator (in this case, integer division).
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">Y register</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">1 (not stored)</td>
<td>Rounding towards empty and full indicator:
<ul>
<li><kbd>Y = $00</kbd> if not rounded to empty or full (if exact empty, rounded to any number besides 0 or maximum, or full (or higher))</li>
<li><kbd>Y = $01</kbd> if rounded to empty.</li>
<li><kbd>Y = $02</kbd> if rounded to full.</li>
See more information <a id="RoundAwayFromComplete" href="readme_files/RoundAwayFromComplete.html">here</a>.
</ul></td>
</tr>
</table>
Destroyed:
<table>
<tr><th>Destroyed</th><th>Number of Bytes</th><th>Description</th></tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$02</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$09</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">8</td>
<td>Overwritten by math routines. Contains garbage values.</td>
</tr>
</table>

<li><a href="#DrawGraphicalBar_Back" id="DrawGraphicalBar">^</a><kbd>DrawGraphicalBar</kbd>: it takes a value representing how much fill in the entire bar, and divides them into a byte-array of numbers that are addends of the fill amount,
in this order: N (can be zero) bytes being at their set maximums, 0 or 1 fraction byte (no fraction if bar is full), and then N bytes (can be zero) empty, while keeping
the order of their maximums (3, 8, 8, 8, 8...), stored in a RAM defined <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd>:<br>
<img src="readme_files/FillAmountDividedUnevenlyToTileBytes.png"><br>

As an analogy, there are N cups, arranged in a row, and starting at the first cup, you fill that cup with water until it's full, or you run out of water, and you repeat the process on the next
cup finishing once you reached the last one. The reason for this being treated as segmented parts is because the SNES' graphics are all tile-based, (most modern games rely on texture-based rendering
often drawing polygons that get the width of the fill region, or simply have one number representing a fill for the entire bar) so we have to deal with them tile-by-tile. <br><br>

<table>
<tr>
<th>Input</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$01</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">2</td>
<td>The amount of fill in the bar, as in, the total number of pieces filled.<br><br>

The total number of pieces (full amount) in the bar is calculated as: <kbd>[FullAmount = LeftEndPiece + (MiddlePiece * MiddleLength) + RightEndPiece]</kbd>,
for example: 62 = 3 + (7 * 8) + 3</td>
</tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Graphical bar attributes, same as <kbd>CalculateGraphicalBarPercentage</kbd></td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table>
Result:
<table>
<tr>
<th>Output</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl + ((<abbr title="0 if no left end, 1 if set to any nonzero number of pieces">LeftEnd</abbr> +
<abbr title="Equals to !Scratchram_GraphicalBar_TempLength if middle pieces is nonzero, 0 otherwise">MiddleLength</abbr> + <abbr title="0 if no right end, 1 if set to any nonzero number of pieces">RightEnd</abbr>) - 1)</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td>
<td>
The table containing N &ge; 0 bytes ordered from full, then zero or one byte containing a fraction (fill amount ranges from <kbd>0</kbd> to <kbd>max-1</kbd>), then  N &ge; 0 empty bytes.
If the bar's fill amount be greater than maximum (say, 63 out of 62 pieces), the values stored in this table will act as if the bar is full and does not write additional bytes.<br><br>

Number of bytes taken is <kbd>LeftEnd + Middle + RightEnd</kbd> where LeftEnd and RightEnd equals to 1 when set to nonzero number of pieces or 0 otherwise, and middle is equal to <kbd>!Scratchram_GraphicalBar_TempLength</kbd>
if MiddlePieces (number of pieces in each middle tile) is nonzero, otherwise it is 0. The JavaScript file linked previously will show how many bytes and memory address range it will occupy.<br><br>

Because the SNES screen is 32 8x8 tiles wide, there is no need to have a bar more than 32 tiles wide (the bar will extend past the border of the screen).

If you are using &ldquo;DoubleBar&rdquo;, it is the duplicate table of above, just located
nth bytes after depending on what you set <span class="NoLineBreak"><kbd>!Setting_GraphicalBar_SecondFillByteTableOffset</kbd></span>.
See <a href="readme_files/DoubleBarInfo.html#SecondTable" target="_blank">this information</a> for what I mean.
</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">$08</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$09</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">2</td>
<td>
The amount of fill that was <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$01</span></span></kbd> was originally before calling this routine, the value is not
capped, so inputting a number 63 when there are 62 pieces will have this RAM address storing the value 63. Can be used on such things like &ldquo;multi-bars&rdquo; that multiple bars are shown, and the
fills advances to the next bar: <img src="readme_files/MultiBar.gif">
</td>
</tr>
</table><br>

<table>
<th>Destroyed</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$07</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">8</td>
<td>
Garbage:
<ul>
<li><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$01</span></span></kbd>:</li>
<ul>
<li>If the right end exist without regards of the middle and left end, will contain the right end amount.</li>
<li>#$00 if right end does not exist and middle exist.</li>
<li>If the left end only exist and middle and right are not, contains the left end amount.</li>
</ul>

<li><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$02</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$07</span></span></kbd>: Needed to move the values to another
address due to subroutines as well as outputs of the subroutines.</li>
</ul>
</td>
</tr>
</table>

Here are the formulas on how each are calculated:<br><br>

<ul>
<li>Left end:</li>
<ul>
<kbd>LeftEndFill = clamp(TotalFilled, 0, LeftEndMax)</kbd>
</ul>
<li>Middle:</li>
<ul>
<li><kbd>TotalMiddleMax = MiddleLength * MiddleMaxEachTile</kbd> (total number of pieces in the middle part of the bar)</li>
<li><kbd>MiddleFill = clamp((TotalFilled - LeftEndMax), 0, TotalMiddleMax)</kbd> (excluding the left end, how many pieces filled in the whole middle)</li>
<li><kbd>NumberOfFullMiddleTiles = clamp(floor(MiddleFill/MiddleMaxEachTile), 0, MiddleLength)</kbd> (<a href="https://en.wikipedia.org/wiki/Euclidean_division">euclidean division</a>)</li>
<li><kbd>MiddleFractionFill = MiddleFill MOD MiddleMaxEachTile</kbd> (euclidean division), placed just after the last full middle tile or
on the first middle tile if there are no full middle tiles, if the entire middle tiles is full, fraction is not written at all.</li>
</ul>
<li>Right end:</li>
<ul>
<li><kbd>RightEndFill = clamp((TotalFilled - (LeftEndMax + TotalMiddleMax)), 0, RightEndMax)</kbd></li>
</ul><br><br>
<li>functions explanation:</li>
<ul>
<li><kbd>clamp(x, min, max)</kbd> returns x in between <kbd>min</kbd> and <kbd>max</kbd>, but returns <kbd>min</kbd> if at or below that number and <kbd>max</kbd> if at or above that number</li>
<li><kbd>floor(x)</kbd> returns the highest integer that is &le; x. Essentially this round down an integer (7/8 = 0.875 &rarr; 0, 9/8 = 1.125 &rarr; 1).</li>
</ul>
</ul><br>
<p>Another way is by taking the given fill amount, subtract by the tile byte maximum starting at the first byte going towards the last byte, if the subtraction was successful (subtracted without going in the negatives), would write
the maximum amount to the byte in the table and writes the difference back to the remaining fill amount, otherwise (if it fails) it would write the remaining fill amount (the last difference before going negative) into byte in the table and
set the remaining fill amount to 0. After this, this then repeats until all tile bytes are finished.<br><br>

<ul><li>For example: using the same attributes as examples above, [14 - 3 = 11]. Subtraction successful, write 3 (maximum)
for the left end, and then write 11 back to the remaining fill amount. Then [11 - 8 = 3], subtraction successful, so the first middle tile byte is 8 (maximum). Finally, [3 - 8 = (-5)]. Subtraction failed, write the remaining amount
(3) on the second middle tile byte. Set the remaining fill amount to 0, and repeat until all tile bytes processed (which results in [0 - MaxAmount], and repeatedly sets the following bytes to 0):
<table>
<tr><th><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> addresses</th><th>Tile byte type</th><th>Fill amount</th><th>Fill maximum</th><th>Calculation</th><th>Remaining fill amount changes</th></tr>
<tr><td><kbd>$7F844A</kbd> (<kbd>Address+0</kbd>)</td><td><span style="color: cyan">Left end</span></td><td style="background-color: orange"><kbd>3</kbd> (<kbd>$03</kbd>)</td><td style="text-align: center;"><kbd>3</kbd></td><td><kbd>14 - 3 = 11</kbd> subtraction successful!</td><td>14 &rightarrow; 11</td></tr>
<tr><td><kbd>$7F844B</kbd> (<kbd>Address+1</kbd>)</td><td><span style="color: #00FF00">Middle 1</span></td><td style="background-color: orange"><kbd>8</kbd> (<kbd>$08</kbd>)</td><td style="text-align: center;"><kbd>8</kbd></td><td><kbd>11 - 8 = 3</kbd> subtraction successful!</td><td>11 &rightarrow; 3</td></tr>
<tr><td><kbd>$7F844C</kbd> (<kbd>Address+2</kbd>)</td><td><span style="color: #00FF00">Middle 2</span></td><td style="background-color: yellow"><span style="color: black"><kbd>3</kbd> (<kbd>$03</kbd>)</span></td><td style="text-align: center;"><kbd>8</kbd></td><td><kbd>3 - 8 = (-5)</kbd> subtraction failed!</td><td>3 &rightarrow; 0</td></tr>
<tr><td><kbd>$7F844D</kbd> (<kbd>Address+3</kbd>)</td><td><span style="color: #00FF00">Middle 3</span></td><td style="background-color: grey"><kbd>0</kbd> (<kbd>$00</kbd>)</td><td style="text-align: center;"><kbd>8</kbd></td><td><kbd>0 - 8 = (-8)</kbd> subtraction failed!</td><td>0 &rightarrow; 0</td></tr>
<tr><td><kbd>$7F844E</kbd> (<kbd>Address+4</kbd>)</td><td><span style="color: #00FF00">Middle 4</span></td><td style="background-color: grey"><kbd>0</kbd> (<kbd>$00</kbd>)</td><td style="text-align: center;"><kbd>8</kbd></td><td><kbd>0 - 8 = (-8)</kbd> subtraction failed!</td><td>0 &rightarrow; 0</td></tr>
<tr><td colspan="6"style="text-align: center;">...</td></tr>
<tr><td><kbd>Address+(NumberOfBytes-1)</kbd></td><td><span style="color: red">Right end</span></td><td style="background-color: grey"><kbd>0</kbd> (<kbd>$00</kbd>)</td><td style="text-align: center;"><kbd>3</kbd></td><td><kbd>0 - 3 = (-3)</kbd> subtraction failed!</td><td>0 &rightarrow; 0</td></tr>
</table></li></ul><br>
<img src="readme_files/RepeatedSubtraction.png">
<br><br>
This is known as repeated subtraction, it keeps subtracting until no more is left. Another version of <kbd>DrawGraphicalBar</kbd>, <a href="#DrawGraphicalBarSubtractionLoopEdition"><kbd>DrawGraphicalBarSubtractionLoopEdition</kbd></a> does this exact procedure.</p>


The inputs are similar to the previously mentioned routine (such as requiring the attributes), but you don't write to <span class="NoLineBreak"><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd></span> to
<span class="NoLineBreak"><kbd>!Scratchram_GraphicalBar_FillByteTbl+3</kbd></span>, as it is no longer needed. Just to keep in mind, the attributes are kept after running this routine, so you don't have to rewrite them again.
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$01</span></span></kbd> is the number of units (or pieces) filled as the input. It is important to note that this output table isn't tile numbers but rather
<i>fill amounts</i>, to be indexed into tile numbers (to allow different tile graphic locations for the same routine (such as different format on the overworld compared to level)). The only different
input here is <kbd>$00</kbd>:<br><br>

This is what it looks like as an example:
<ul>
<li><span style="color: cyan">Cyan</span> means the left end tile byte.</li>
<li><span style="color: #00C000">Green</span> means the middle tile byte(s).</li>
<li><span style="color: red">Red</span> means right end tile byte.</li>
<li><span style="color: orange">Orange </span> means the tile byte is full or reaches maximum.</li>
<li><span style="color: yellow">Yellow</span> means the tile byte is between 0 to max-1 inclusively (known as a fraction tile).</li>
<li><span style="color: grey">Grey</span> means the tile byte is empty.</li><br>
</ul>
<table>
<tr>
<td>
<pre>;These three are what sets the maximum fill values for the byte table.
 <span style="color: cyan">!Scratchram_GraphicalBar_LeftEndPiece:      $03</span>
 <span style="color: #00C000">!Scratchram_GraphicalBar_MiddlePiece:       $08</span>
 <span style="color: red">!Scratchram_GraphicalBar_RightEndPiece:     $03</span>
;This is how long the middle section.
 <span style="color: #00C000">!Scratchram_GraphicalBar_TempLength:        $07</span>
;The number of units or pieces filled:
 RAM address $00-$01:                        $0017 (23)</pre>
</td>
<td>


<pre>ASCII art depicting the byte table and how each byte correlates to the table.

                                     Table: <span style="background-color: orange">$03</span>,<span style="background-color: orange">$08</span>,<span style="background-color: orange">$08</span>,<span style="background-color: yellow"><span style="color: black">$04</span></span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>
                                             |   |   |   |   |   |   |   |   |
<span style="color: cyan">!Scratchram_GraphicalBar_FillByteTbl+0</span> ------/   |   |   |   |   |   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+1</span> ----------/   |   |   |   |   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+2</span> --------------/   |   |   |   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+3</span> ------------------/   |   |   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+4</span> ----------------------/   |   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+5</span> --------------------------/   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+6</span> ------------------------------/   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+7</span> ----------------------------------/   |
<span style="color: red">!Scratchram_GraphicalBar_FillByteTbl+8</span> --------------------------------------/
</pre><br>
Note: define <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> is an address, thus the above math (note the <kbd>+x</kbd>) means you add the value of the address (not the value stored in)
to get the relative location (so if <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> is being defined as <kbd>$7F844A</kbd> and you have <kbd>!Scratchram_GraphicalBar_FillByteTbl+1</kbd>,
that is <kbd>$7F844A + 1</kbd> which is address <kbd>$7F844B</kbd>).
</td>
</tr>
</table><br>

If any maximum was set to $00, they are excluded from the table and are skipped (all bytes with a nonzero maximum should not have a gap of unused bytes in between in any of them):
<table>
<tr>
<td>
<pre>
<span style="color: cyan"><s>!Scratchram_GraphicalBar_LeftEndPiece:       $00</s></span>
<span style="color: #00C000">!Scratchram_GraphicalBar_MiddlePiece:        $08</span>
<span style="color: red">!Scratchram_GraphicalBar_RightEndPiece:      $03</span>
<span style="color: #00C000">!Scratchram_GraphicalBar_TempLength:         $07</span>
RAM address $00-$01:                         $0017 (23)</pre>
</td>
<td>

<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address (index):</td>
<td style="background-color: #00C000"><kbd>+0</kbd></td>
<td style="background-color: #00C000"><kbd>+1</kbd></td>
<td style="background-color: #00C000"><kbd>+2</kbd></td>
<td style="background-color: #00C000"><kbd>+3</kbd></td>
<td style="background-color: #00C000"><kbd>+4</kbd></td>
<td style="background-color: #00C000"><kbd>+5</kbd></td>
<td style="background-color: #00C000"><kbd>+6</kbd></td>
<td style="background-color: red"><kbd>+7</kbd></td>
<td><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values:</td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: yellow"><span style="color: black"><kbd>$07</kbd></span></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td><kbd>(unused, garbage)</kbd></td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<pre>
<span style="color: cyan">!Scratchram_GraphicalBar_LeftEndPiece:       $03</span>
<span style="color: #00C000"><s>!Scratchram_GraphicalBar_MiddlePiece:        $00</s></span>
<span style="color: red">!Scratchram_GraphicalBar_RightEndPiece:      $03</span>
<span style="color: #00C000"><s>!Scratchram_GraphicalBar_TempLength:         $00</s></span>
RAM address $00-$01:                         $0004 (4)

Note: !Scratchram_GraphicalBar_MiddlePiece <u>and/or</u>
!Scratchram_GraphicalBar_TempLength is set to zero,
excludes the entire middle section.</pre>
</td>
<td>

<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address (index):</td>
<td style="background-color: cyan"><span style="color: black"><kbd>+0</kbd></span></td>
<td style="background-color: red"><kbd>+1</kbd></td>
<td><kbd>+2</kbd></td>
<td><kbd>+3</kbd></td>
<td><kbd>+4</kbd></td>
<td><kbd>+5</kbd></td>
<td><kbd>+6</kbd></td>
<td><kbd>+7</kbd></td>
<td><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values:</td>
<td style="background-color: orange"><kbd>$03</kbd></td>
<td style="background-color: yellow"><span style="color: black"><kbd>$01</kbd></span></td>
<td colspan="7"><kbd>(unused, garbage)</kbd></td>
</tr>
</table>
</td>
<tr>
<td>
<pre><span style="color: cyan">!Scratchram_GraphicalBar_LeftEndPiece:       $03</span>
<span style="color: #00C000">!Scratchram_GraphicalBar_MiddlePiece:        $08</span>
<span style="color: red"><s>!Scratchram_GraphicalBar_RightEndPiece:      $00</s></span>
<span style="color: #00C000">!Scratchram_GraphicalBar_TempLength:         $07</span>
RAM address $00-$01:                         $0017 (23)</pre>
</td>
<td>

<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address (index):</td>
<td style="background-color: cyan"><span style="color: black"><kbd>+0</kbd></span></td>
<td style="background-color: #00C000"><kbd>+1</kbd></td>
<td style="background-color: #00C000"><kbd>+2</kbd></td>
<td style="background-color: #00C000"><kbd>+3</kbd></td>
<td style="background-color: #00C000"><kbd>+4</kbd></td>
<td style="background-color: #00C000"><kbd>+5</kbd></td>
<td style="background-color: #00C000"><kbd>+6</kbd></td>
<td style="background-color: #00C000"><kbd>+7</kbd></td>
<td><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values:</td>
<td style="background-color: orange"><kbd>$03</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: yellow"><span style="color: black"><kbd>$04</kbd></span></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td><kbd>(unused, garbage)</kbd></td>
</tr>
</table>
</td>
</tr>
</tr>
</table><br>

<span id="StaticEndTiles"></span>Because of this, it also means that the <a href="#ConvertFillToTile"><kbd>FillAmount &rightarrow; TileNumber</kbd></a> and <a href="#StatusBarWrite"><kbd>tile write</kbd></a> routine themselves <span style="font-weight: bold;">will not write static
tiles as end tiles</span>. Static end tiles are unchanging tiles that only serve to draw a border graphic at the ends of the bar (which is useful to avoid cutoff at those ends without needing a border for <i>every</i> tile which gives it a segmented look),
here is what I mean as an example:<br>
<img src="readme_files/StaticEndTiles.png"><br>
You have to manually write the tiles at either side of the bar yourself:
<table><tr><td><pre>	LDA #&lt;LeftEndTileNumber&gt;
	STA &lt;LeftEndTilePosition&gt;
	LDA #&lt;LeftEndTileProps&gt;
	STA &lt;LeftEndTilePropsPosition&gt;

	LDA #&lt;RightEndTileNumber&gt;
	STA &lt;RightEndTilePosition&gt;
	LDA #&lt;RightEndTileProps&gt;
	STA &lt;RightEndTilePropsPosition&gt;
	
	;Remove any line with the words &ldquo;props&rdquo; if the status bar
	;you're working on does not allow modifying the tile properties.
</pre></td></tr></table>
If you have variable-length bar, I've <a href="#StaticEndRoutine">provided routines</a> that would automatically calculate where to write the static end tiles. Also note that this readme
assumes you never used static end tiles, most of the info provided about status bar write ranges only include the tiles affected based on fill amount, not static end tiles.
<br><br>

Of course, I made a <a id="ComputeGraphicalBarData" href="readme_files/JS_GraphicalBarCalculator3.html">javascript code page</a> that calculates memory statistics
without the need of manually calculating the values.</li><br>

<li><a href="#DrawGraphicalBarSubtractionLoopEdition_Back" id="DrawGraphicalBarSubtractionLoopEdition">^</a><kbd>DrawGraphicalBarSubtractionLoopEdition</kbd> An alternative routine to <kbd>DrawGraphicalBar</kbd>,
it does the same thing, but the method is different. Instead of using any form of division, it simply uses repeated subtraction, and in fact, does not use any other subroutines (this is a standalone). Almost all the inputs and outputs the
same, except that the output <kbd>$00-$01</kbd> acts as the remaining fill when the bar is full or higher and 0 otherwise (<kbd>RemainingFill = <abbr title="Picks what number in the parameter is the highest value. If the fill amount is less than 0, it results things like max(-5, 0) which returns 0 and not -5">max</abbr>((InputFillAmount - BarMaximumFull), 0)</kbd>), while <kbd>$02-$09</kbd> aren't destroyed.<br><br>

<table>
<tr><th>Input</th><td>Number of bytes</td><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The amount of fill</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Graphical bar attributes, same as <kbd>CalculateGraphicalBarPercentage</kbd></td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of Bytes</th><th>Description</th></tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl + ((<abbr title="0 if no left end, 1 if set to any nonzero number of pieces">LeftEnd</abbr> +
<abbr title="Equals to !Scratchram_GraphicalBar_TempLength if middle pieces is nonzero, 0 otherwise">MiddleLength</abbr> + <abbr title="0 if no right end, 1 if set to any nonzero number of pieces">RightEnd</abbr>) - 1)</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td>
<td>The table array containing each tile byte fill amount, same as <kbd>CalculateGraphicalBarPercentage</kbd>.</td>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The leftover remaining amount of fill, if the fill amount is greater than the maximum/total, 0 otherwise (calculated via <kbd>RemainingFill = max((InputFillAmount - BarMaximumFull), 0)</kbd>)</td></tr>
</tr>

</table>
</li>


<li><a href="#TOCRoundAwayFromComplete_Back" id="TOCRoundAwayFromComplete">^</a><kbd>RoundAwayEmpty</kbd>, <kbd>RoundAwayFull</kbd>, and <kbd>RoundAwayEmptyFull</kbd>: After getting the Y register value from <kbd>CalculateGraphicalBarPercentage</kbd>, this increments or
decrements the fill amount <kbd>$00-$01</kbd> by 1 so it will display 1 and/or <kbd>MaxFill-1</kbd> instead of showing 0 and/or <kbd>MaxFill</kbd> when the value is rounded towards them. The names
of the routine should be obvious (e.g. <kbd>RoundAwayEmpty</kbd> means round away from empty). See explanation <a href="readme_files/RoundAwayFromComplete.html">here</a>.</li><br>
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td>Y register</td><td style="text-align: center; vertical-align: middle;">1 (not stored)</td><td>Rounding modes, as explained when using <kbd>CalculateGraphicalBarPercentage</kbd>.</td></tr>
</table><br><br>

<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>Rounded percentage value.</td></tr>
</table><br><br>

</ul>
</ul>
<li><span id="ConvertFillToTile"><a href="#GraphicalBarConvertToTileBack" id="GraphicalBarConvertToTile">^</a>Inside <kbd>GraphicalBarConvertToTile.asm</kbd></span></li>
<ul>
<li><a href="#ConvertBarFillAmountToTiles_Back" id="ConvertBarFillAmountToTiles">^</a><kbd>ConvertBarFillAmountToTiles</kbd>: converts the bar fill table into tile numbers via indexing (inputs the same as above and don't
need to be rewritten). Note that this DOES modifies the values in <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> (replacing them with tile numbers):
<table>
<tr>
<th>Input</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td><td>The fill amount array to be converted to tile numbers.</td></tr>
<tr>
<td><kbd>$00</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td>Determines what sets of fill graphic tiles to use based on:<br>
<ul>
<li><kbd>#$00</kbd> = Level, layer 3</li>
<li><kbd>#$01</kbd> = Level, sprite</li>
<li><kbd>#$02</kbd> = Overworld, layer 3</li>
</ul></td>
</tr>
<tr>
<td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td rowspan="4">Needed to convert each tile by identifying the left end, middle (and how many middle tiles), and right end.</td>
</tr>
<tr>
<td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
<tr>
<td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
<tr>
<td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
</table>
Output:
<table>
<tr>
<th>Output</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl + ((<abbr title="0 if no left end, 1 if set to any nonzero number of pieces">LeftEnd</abbr> +
<abbr title="Equals to !Scratchram_GraphicalBar_TempLength if middle pieces is nonzero, 0 otherwise">MiddleLength</abbr> + <abbr title="0 if no right end, 1 if set to any nonzero number of pieces">RightEnd</abbr>) - 1)</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td>
<td>Tile array containing tile numbers.</td>
</tr>
</table>
Destroyed:
<table>
<tr><th>Destroyed</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>$01</kbd></td><td style="text-align: center;">1</td><td>Used to keep track if all the middle tiles are processed.</td></tr>
</table>
What it looks like:
<table>
<tr>
<th>Left end</th>
<th>Middle</th>
<th>Right end</th>
</tr>
<tr>
<td><ul>
<li><kbd>Fill amount $00 &rightarrow; tile number $36</kbd> <img src="readme_files/GraphicalBarFills/LeftEnd_0_of_3.png"></li>
<li><kbd>Fill amount $01 &rightarrow; tile number $37</kbd> <img src="readme_files/GraphicalBarFills/LeftEnd_1_of_3.png"></li>
<li><kbd>Fill amount $02 &rightarrow; tile number $38</kbd> <img src="readme_files/GraphicalBarFills/LeftEnd_2_of_3.png"></li>
<li><kbd>Fill amount $03 &rightarrow; tile number $39</kbd> <img src="readme_files/GraphicalBarFills/LeftEnd_3_of_3.png"></li>
</ul></td>
<td><ul>
<li><kbd>Fill amount $00 &rightarrow; tile number $55</kbd> <img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></li>
<li><kbd>Fill amount $01 &rightarrow; tile number $56</kbd> <img src="readme_files/GraphicalBarFills/Middle_1_of_8.png"></li>
<li><kbd>Fill amount $02 &rightarrow; tile number $57</kbd> <img src="readme_files/GraphicalBarFills/Middle_2_of_8.png"></li>
<li><kbd>Fill amount $03 &rightarrow; tile number $58</kbd> <img src="readme_files/GraphicalBarFills/Middle_3_of_8.png"></li>
<li><kbd>Fill amount $04 &rightarrow; tile number $59</kbd> <img src="readme_files/GraphicalBarFills/Middle_4_of_8.png"></li>
<li><kbd>Fill amount $05 &rightarrow; tile number $65</kbd> <img src="readme_files/GraphicalBarFills/Middle_5_of_8.png"></li>
<li><kbd>Fill amount $06 &rightarrow; tile number $66</kbd> <img src="readme_files/GraphicalBarFills/Middle_6_of_8.png"></li>
<li><kbd>Fill amount $07 &rightarrow; tile number $67</kbd> <img src="readme_files/GraphicalBarFills/Middle_7_of_8.png"></li>
<li><kbd>Fill amount $08 &rightarrow; tile number $68</kbd> <img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"></li>
</ul></td>
<td><ul>
<li><kbd>Fill amount $00 &rightarrow; tile number $50</kbd> <img src="readme_files/GraphicalBarFills/RightEnd_0_of_3.png"></li>
<li><kbd>Fill amount $01 &rightarrow; tile number $51</kbd> <img src="readme_files/GraphicalBarFills/RightEnd_1_of_3.png"></li>
<li><kbd>Fill amount $02 &rightarrow; tile number $52</kbd> <img src="readme_files/GraphicalBarFills/RightEnd_2_of_3.png"></li>
<li><kbd>Fill amount $03 &rightarrow; tile number $53</kbd> <img src="readme_files/GraphicalBarFills/RightEnd_3_of_3.png"></li>
</ul></td>
</tr>
</table><br>

So if <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> contains these values and gets converted, this happens:
<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address (index):</td>
<td style="background-color: cyan"><span style="color: black"><kbd>+0</kbd></span></td>
<td style="background-color: #00C000"><kbd>+1</kbd></td>
<td style="background-color: #00C000"><kbd>+2</kbd></td>
<td style="background-color: #00C000"><kbd>+3</kbd></td>
<td style="background-color: #00C000"><kbd>+4</kbd></td>
<td style="background-color: #00C000"><kbd>+5</kbd></td>
<td style="background-color: #00C000"><kbd>+6</kbd></td>
<td style="background-color: #00C000"><kbd>+7</kbd></td>
<td style="background-color: red"><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values...:</td>
<td style="background-color: orange"><kbd>$03</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: yellow"><span style="color: black"><kbd>$04</kbd></span></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
</tr>
<tr>
<td>...converted to tile number:</td>
<td style="background-color: orange"><kbd>$39</kbd></td>
<td style="background-color: orange"><kbd>$68</kbd></td>
<td style="background-color: orange"><kbd>$68</kbd></td>
<td style="background-color: yellow"><span style="color: black"><kbd>$59</kbd></span></td>
<td style="background-color: grey"><kbd>$55</kbd></td>
<td style="background-color: grey"><kbd>$55</kbd></td>
<td style="background-color: grey"><kbd>$55</kbd></td>
<td style="background-color: grey"><kbd>$55</kbd></td>
<td style="background-color: grey"><kbd>$50</kbd></td>
</tr>
<tr>
<td>Tile image:</td>
<td><center><img src="readme_files/GraphicalBarFills/LeftEnd_3_of_3.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_4_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/RightEnd_0_of_3.png"></center></td>
</tr>
<tr>
<td>
Result:
</td>
<td colspan="9">
<center>
<span class="NoLineBreak">
<img src="readme_files/GraphicalBarFills/LeftEnd_3_of_3.png"><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_4_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/RightEnd_0_of_3.png">
</span>
</center>
</td>
</tr>
</table><br>
If you changed the number of pieces in any tile bytes (left, middle (each middle), and right), the number of pieces must equal to the number of values, plus 1.
For example, by making left end have 4 pieces instead of 3, you must have 5 values in the left end tile table. Else your tiles will glitch:
<table><tr><td><pre>
;This is an example, therefore the numbers in this table may
;be different to you.

			GraphicalBar_LeftEnd8x8s_Lvl_L3:
			;Left end fill amount tile numbers:
			db $36		;&gt;Fill amount/index: $00
			db $37		;&gt;Fill amount/index: $01
			db $38		;&gt;Fill amount/index: $02
			db $39		;&gt;Fill amount/index: $03

	;4 pieces, now values are 0-4:
			GraphicalBar_LeftEnd8x8s_Lvl_L3:
			;Left end fill amount tile numbers:
			db $36		;&gt;Fill amount/index: $00
			db $37		;&gt;Fill amount/index: $01
			db $38		;&gt;Fill amount/index: $02
			db $39		;&gt;Fill amount/index: $03
			db <span style="color: red">$xx</span>		;&gt;Fill amount/index: $04</pre></td></tr></table>

<br><br>

Note that scratch RAM <kbd>$00</kbd> and <kbd>$01</kbd> is overwritten to determine should it use overworld border version and handle a loop that translates the middle tiles.<br><br>

The table of tile numbers in the routine are ordered from empty to full in the tile array, I left the comments on there to show what fill amount for every byte for easier editing.<br><br>

</li>
<li><a href="#ConvertBarFillAmountToTilesDoubleBar_Back" id="ConvertBarFillAmountToTilesDoubleBar">^</a><kbd>ConvertBarFillAmountToTilesDoubleBar</kbd>: Same as above, but handles a
<a href="readme_files/DoubleBarInfo.html">double-filled bar (aka double-bar)</a> using a separate graphics. Tiles are formated <a href="readme_files/DoubleBarFills.png" target="_blank">like this</a>.
Also like above, make sure you have the number of pieces equal to <kbd>(NumberOfPieces+1)^2</kbd> number of values in table (for example, left end have 4 pieces, therefore you must have 25 values;
<kbd>(4+1)^2 = 25</kbd>). I recommend to have the table to form a perfect square so that the fill values are visually organized.<br>

Of course, the default graphics included here are pixel-column-based, meaning each column of pixels is 1 piece of a bar.<br><br>

Note that this does not support overworld graphics unlike above, as there are even more tiles used than the status bar.</li><br><br>

<table>
<tr><th>Input</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td><kbd>LeftEnd + MiddleLength + RightEnd</kbd></td><td>The fill amount array to be converted to tile numbers. (SecondFill).</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl + !Setting_GraphicalBar_SecondFillByteTableOffset</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + (((LeftEnd + MiddleLength + RightEnd) - 1) + !Setting_GraphicalBar_SecondFillByteTableOffset)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd></td><td>The fill amount array to be converted to tile numbers. (FirstFill).</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Graphical bar attributes, same as <kbd>CalculateGraphicalBarPercentage</kbd></td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td><kbd>LeftEnd + MiddleLength + RightEnd</kbd></td><td>Tile array containing tile numbers representing both first and second fills.</td></tr>
</table><br>

<table>
<tr><th>Overwritten</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd></td><td style="text-align: center;">1</td><td>Used to keep track if all the middle tiles are processed.</td></tr>
</table><br>

<li><a href="#ConvertBarFillAmountToTilesEdgeOverMultipleTiles_Back" id="ConvertBarFillAmountToTilesEdgeOverMultipleTiles">^</a><kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTiles</kbd>: Due to the way <kbd>DrawGraphicalBar</kbd>'s format of having only up to a single fraction tile byte exist, this subroutine makes having
the fill edge covering multiple 8x8 tiles possible. This is useful for slanted, rounded, or outlined fill edged graphics:<br>
<img src="readme_files/MultiPartiallyFilled.png"><br>
See explanation <a href="readme_files/FillEdgeCrossingTileBorder.html" id="FillEdgeCrossingTileBorder">here</a> Inputs and outputs are the same as <kbd>ConvertBarFillAmountToTiles</kbd>.
</li>

<li><a href="#ConvertBarFillAmountToTilesIndirectAddressTable_Back" id="ConvertBarFillAmountToTilesIndirectAddressTable">^</a><kbd>ConvertBarFillAmountToTilesIndirectAddressTable</kbd>: Does the same thing as <kbd><a href="#ConvertBarFillAmountToTiles">ConvertBarFillAmountToTiles</a></kbd>, but tile
tables are no longer &ldquo;fixed&rdquo; (no need to edit the routine's code to check $00's newer values and adding new tables around that area), which is useful for things like sprite tile remapping.
<table>
<tr><th>Input</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td><td>The fill amount array to be converted to tile numbers.</td></tr>
<tr><td><kbd>$00</kbd> to <kbd>$02</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for left end.</td></tr>
<tr><td><kbd>$03</kbd> to <kbd>$05</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for middles.</td></tr>
<tr><td><kbd>$06</kbd> to <kbd>$08</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for right end.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center;">1</td><td rowspan="4">Needed to convert each tile by identifying the left end, middle (and how many middle tiles), and right end.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center;">1</td></tr>
</table><br>
<table>
<tr><th>Output</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td>
<td>Tile array containing tile numbers.</td></tr>
</table><br>
Destroyed:
<table>
<tr><th>Destroyed</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$09</kbd></td><td style="text-align: center;">1</td><td>Used to track the middle tiles if all of them are done.</td></tr>
</table><br>

<p>In case if you don't know how input an address into scratch RAM, you label your table like this (this is an example from the tile table for the Giant Masked Koopa Boss):
<table><tr><td><pre>			GraphicalBar_LeftEnd8x8s_Lvl_Spr:
			;Left end fill amount tile numbers:
			db $88		;&gt;Fill amount/index: $00
			db $89		;&gt;Fill amount/index: $01
			db $8A		;&gt;Fill amount/index: $02
			db $8B		;&gt;Fill amount/index: $03
			GraphicalBar_Middle8x8s_Lvl_Spr:
			;Middle fill amount tile numbers
			db $8C		;&gt;Fill amount/index: $00
			db $8D		;&gt;Fill amount/index: $01
			db $8E		;&gt;Fill amount/index: $02
			db $8F		;&gt;Fill amount/index: $03
			db $98		;&gt;Fill amount/index: $04
			db $99		;&gt;Fill amount/index: $05
			db $9A		;&gt;Fill amount/index: $06
			db $9B		;&gt;Fill amount/index: $07
			db $9C		;&gt;Fill amount/index: $08
			GraphicalBar_RightEnd8x8s_Lvl_Spr:
			;Right end fill amount tile numbers:
			db $9D		;&gt;Fill amount/index: $00
			db $9E		;&gt;Fill amount/index: $01
			db $9F		;&gt;Fill amount/index: $02
			db $A8		;&gt;Fill amount/index: $03</pre></td></tr></table><br>
The labels are <kbd>GraphicalBar_LeftEnd8x8s_Lvl_Spr</kbd>, <kbd>GraphicalBar_Middle8x8s_Lvl_Spr</kbd>, and <kbd>GraphicalBar_RightEnd8x8s_Lvl_Spr</kbd> are labels, and points to an array of bytes (starting at the first byte of the array).<br><br>

To write such address into RAM with the labels in existence, you do this:
<table><tr><td><pre>;Remember, little endian (lowest byte comes first)!
	LDA.b #GraphicalBar_LeftEnd8x8s_Lvl_Spr			;\$00-$02 contains the address of GraphicalBar_LeftEnd8x8s_Lvl_Spr
	STA $00							;|
	LDA.b #GraphicalBar_LeftEnd8x8s_Lvl_Spr&gt;&gt;8		;|
	STA $01							;|
	LDA.b #GraphicalBar_LeftEnd8x8s_Lvl_Spr&gt;&gt;16		;|
	STA $02							;/
	LDA.b #GraphicalBar_Middle8x8s_Lvl_Spr			;\$03-$05 contains the address of GraphicalBar_Middle8x8s_Lvl_Spr
	STA $03							;|
	LDA.b #GraphicalBar_Middle8x8s_Lvl_Spr&gt;&gt;8		;|
	STA $04							;|
	LDA.b #GraphicalBar_Middle8x8s_Lvl_Spr&gt;&gt;16		;|
	STA $05							;/
	LDA.b #GraphicalBar_RightEnd8x8s_Lvl_Spr		;\$06-$08 contains the address of GraphicalBar_RightEnd8x8s_Lvl_Spr
	STA $06							;|
	LDA.b #GraphicalBar_RightEnd8x8s_Lvl_Spr&gt;&gt;8		;|
	STA $07							;|
	LDA.b #GraphicalBar_RightEnd8x8s_Lvl_Spr&gt;&gt;16		;|
	STA $08							;/
	
	;Labels represents the address (or position) in the ROM. LDA.w #Label when Label is at location $1234, that means it will
	;be LDA #$1234. If you don't have that hash symbol, it would be LDA Label -&gt; LDA $1234 (which loads RAM instead of &ldquo;Immediate&rdquo;)</pre></td></tr></table><br>
</p>
</li>
<li><a href="#ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable_Back" id="ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable">^</a><kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable</kbd>: same as <kbd><a href="#ConvertBarFillAmountToTilesEdgeOverMultipleTiles">ConvertBarFillAmountToTilesEdgeOverMultipleTiles</a></kbd>
and just like <kbd><a href="#ConvertBarFillAmountToTilesIndirectAddressTable">ConvertBarFillAmountToTilesIndirectAddressTable</a></kbd>, have a relocatable table that you can manually set.
<table>
<tr><th>Input</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td><td>The fill amount array to be converted to tile numbers.</td></tr>
<tr><td><kbd>$00</kbd> to <kbd>$02</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for left end.</td></tr>
<tr><td><kbd>$03</kbd> to <kbd>$05</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for middles.</td></tr>
<tr><td><kbd>$06</kbd> to <kbd>$08</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for right end.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center;">1</td><td rowspan="4">Needed to convert each tile by identifying the left end, middle (and how many middle tiles), and right end.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center;">1</td></tr>
</table><br>
<table>
<tr><th>Output</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td>
<td>The tile number array that was previously the fill amounts.</td></tr>
</table><br>

Destroyed:
<table>
<tr><th>Destroyed</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$09</kbd></td><td style="text-align: center;">1</td><td>Used to track the middle tiles if all of them are done.</td></tr>
<tr><td><kbd>$0A</kbd></td><td style="text-align: center;">1</td><td>Needed to prevent taking the last tile, and adding by an invalid data after that.</td></tr>
</table>
</li>

</ul><br>

<li><span id="StatusBarWrite"><a href="#GraphicalBarWriteToStatusBarBack" id="GraphicalBarWriteToStatusBar">^</a>Inside <kbd>GraphicalBarWriteToStatusBar.asm</kbd>. Note that there are two similar subroutines main labels with one that have &ldquo;<kbd>Format2</kbd>&rdquo; (such as <kbd>WriteBarToHUD</kbd> and
<kbd>WriteBarToHUDFormat2</kbd>) appended are the same as the other but handles a different status bar/OWB format. See <a href="readme_files/Layer3TileFormat/Layer3TileFormat.html" target="_blank">this information</a>
regarding the tile formats.
</li>
<ul>
<li><a href="#WriteBarToHUD_Back" id="WriteBarToHUD">^</a><kbd>WriteBarToHUD</kbd>: Copies the tile numbers in the table to paste to (writes) the status bar, in the direction of filling left to right.
Inputs are again, similar to <kbd>CalculateGraphicalBarPercentage</kbd> with only the attributes being used, but a new input is required:

<table>
<tr>
<th>Input</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$02</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">3</td>
<td>The starting address (left end, extends rightwards, even when the bar is set to fill leftwards) location to write the tile numbers to the status bar.</td>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$03</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$05</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">3</td>
<td>The starting address (left end, extends rightwards, even when the bar is set to fill leftwards) location to write the tile properties to the status bar.
(This only works if you installed status bar patches that enable editing the properties in-game, and set <kbd>!StatusBar_UsingCustomProperties</kbd> to <kbd>1</kbd>,
else this is no longer needed to write values to this input). I deliberately used the if statement around this to prevent writing to an arbitrary address (the <span class="NoLineBreak"><kbd>STA [$03],y</kbd></span> could write to an invalid address).</td>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$06</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td>The tile properties (YXPCCCTT) for each tile. Same as above, if you have it disabled, this is not used.</td>
</tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Needed to find how many total tiles to write.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table><br>
<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr>
<td><kbd><span style="font-weight: bold;">RAMAddressIn00</span></kbd> to <span class="NoLineBreak"><kbd><span style="font-weight: bold;">RAMAddressIn00 + ((NumberOfTiles-1)*<a href="readme_files/Layer3TileFormat/Layer3TileFormat.html" target="_blank">TileFormat</a>)</span></kbd></span></td>
<td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td>
<td>Location to write to the status bar/OWB+ patch(es). Note: if using SSB-format, will write every other tile, starting at <kbd>RAMAddressIn00</kbd>, otherwise all the bytes in between
are written.</td>
</tr>
<tr>
<td><kbd><span style="font-weight: bold;">RAMAddressIn03</span></kbd> to <span class="NoLineBreak"><kbd><span style="font-weight: bold;">RAMAddressIn03 + ((NumberOfTiles-1)*!StatusBarFormat)</span></kbd></span></td>
<td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td>
<td>Same as above, but for tile properties (should you enable the tile properties to be writable via <span class="NoLineBreak"><kbd>!StatusBar_UsingCustomProperties</kbd></span>)</td>
</tr>
</table>
Remember that all numbers are little endians (The address <kbd>$7E0F09</kbd>, for example are stored in each bytes as
<pre>$7E0000: $09
$7E0001: $0F
$7E0002: $7E</pre>

so be careful on that.).
Of course, because the <a href="https://www.smwcentral.net/?p=section&a=details&id=15222">Overworld Border Plus</a> patch have the same format as the Super Status Bar patch,
it will work on that as well (if <kbd>!StatusBarFormat</kbd> set to $02 and you make a different version of the routine <kbd>ConvertBarFillAmountToTiles</kbd> to use a different
table to use OW layer 3 tiles).<br><br>

As a side note, the <kbd>Format2</kbd> version of this also works stripe image both horizontal and vertical, since SSB, OWB+ and stripe uses the same <kbd>TTTTTTTT YXPCCCTT TTTTTTTT YXPCCCTT...</kbd> format. However, I strongly
recommend having <kbd>!StatusBar_UsingCustomProperties</kbd> set to <kbd>1</kbd> in <kbd>GraphicalBarDefines/StatusBarSettings.asm</kbd> because it could write garbage tiles or crash your game.</li><br>

<li><a href="#WriteBarToHUDLeftwards_Back" id="WriteBarToHUDLeftwards">^</a><kbd>WriteBarToHUDLeftwards</kbd>: Same as above, but writes an X-flipped version, in the direction of filling right to left (<img width="96" class="img-hor" src="readme_files/TransperentBackground.png">). Note that it only
works properly if you set bit 6 of YXPCCCTT properties byte (this routine itself does not automatically set bit 6, even with <kbd>!StatusBar_UsingCustomProperties</kbd> set to <kbd>1</kbd>), assuming
the default graphic for the fill tiles are left-to-right. The tiles are arranged in reverse order so the leftmost tile (including the end tiles) is now the right most, the second leftmost is second
rightmost, and so on. If you didn't X-flip the tiles via editing the tile properties (YXPCCCTT), each tile will starts filling left-to-right starting at the rightmost tile going towards the left.
In vanilla SMW, it is still possible to edit the tile properties (but cannot be changed in-game as the data is stored in ROM) at around address <kbd>$008C81</kbd>.<br><br>

Note that this does NOT reverse the order of bytes stored in <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> table, it simply takes that table, and write them on the HUD backwards.<br><br>

To avoid confusion, I refer the end tiles in which the fill <span style="font-weight: bold;">starts</span> as the left end and right end to where the fill goes to. Left/right <i>side</i> refers the literal left/right side from the user's perspective.
Also keep in mind that as you increase the length of the bar, it will always extend towards the right unless you use the <kbd>BarExtendLeft</kbd> routine.<br><br>

Another note is that the address provided on where to write on the status bar is still &ldquo;left to right&rdquo; meaning as the bar extends, the left side of the bar does not move and will still extend rightwards although
the fill starts on the right side.<br><br>

Just like <kbd>WriteBarToHUD</kbd>, this will also work on stripe image data for both vertical and horizontal.
</li><br>
<li><a href="#WriteBarToHUDVertically_Back" id="WriteBarToHUDVertically">^</a><kbd>WriteBarToHUDVertically</kbd>: Writes a vertical bar on the HUD, supports both upwards and downwards. Only works if the status bar is 32 tiles wide on each contiguous row,
at the time of writing this, only SMB3, SSB, and OWB+ patches will work on this. Don't use this for stripe image.
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$02</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>The starting tile address where the fill starts at. If filling upwards, this would be the bottom, if downwards, this would be the top.</td></tr>
<tr><td><kbd>$03</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>The starting tile property address where the fill starts at. If filling upwards, this would be the bottom, if downwards, this would be the top. Like <kbd>WriteBarToHUD</kbd>, if <kbd>!StatusBar_UsingCustomProperties</kbd> is 0, this is not used.</td></tr>
<tr><td><kbd>$06</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td>YXPCCCTT for each tile (does not modify the Y bit itself, so a vertically flipped bar would mean you set the Y bit yourself). Not used if <kbd>!StatusBar_UsingCustomProperties</kbd> is 0.</td></tr>
<tr><td><kbd>$07</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td>Direction, only use these values: <kbd>$00</kbd> = upwards, <kbd>$02</kbd> = downwards.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Needed to find how many total tiles to write.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table><br>
<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>RAMAddressIn00-(X*32*StatusBarFormat)</kbd> for upwards or <kbd>RAMAddressIn00+(X*32*StatusBarFormat)</kbd> for downwards, both with X being an integer increasing from 0 to <kbd>NumberOfTiles-1</kbd></td><td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles</kbd> (not contiguous)</td><td>Location to write to the status bar/OWB+ patch(es). Note: if using SSB-format, will write every other tile, starting at RAMAddressIn00, otherwise all the bytes in between are written.</td></tr>
<tr><td><kbd>RAMAddressIn03-(X*32*StatusBarFormat)</kbd> for upwards or <kbd>RAMAddressIn03+(X*32*StatusBarFormat)</kbd> for downwards, both with X being an integer increasing from 0 to <kbd>NumberOfTiles-1</kbd></td><td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles</kbd> (not contiguous)</td><td>Same as above, but for tile properties (should you enable the tile properties to be writable via !StatusBar_UsingCustomProperties)</td></tr>
<tr><td><kbd>$00</kbd> to <kbd>$02</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>The address after writing the last tile (as if writing the amount of tiles plus 1), can be used for writing static end tile where the fill ends at</td></tr>
<tr><td><kbd>$03</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Same as above but for tile properties.</td></tr>
</table><br>

Note: Just like <kbd>WriteBarToHUDLeftwards</kbd>, it does not reverse the order of bytes in <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd>. As the fill increases, whatever side it starts from is considered to be the &ldquo;left end&rdquo; and the side that the fill is going towards is considered to be the &ldquo;right end&rdquo;.
</li><br>
<li><a href="#BarExtendLeft_Back" id="BarExtendLeft">^</a><kbd>BarExtendLeft</kbd>: Normally, without this routine, as the bar's length (not to be confused with <kbd>WriteBarToHUDLeftwards</kbd> routine) increases, the
bar always extends rightwards (leftmost tile stays in place while the rightmost moves rightwards), regardless of left or rightwards direction. With this, you call this routine before you call <kbd>WriteBarToHUD</kbd>
or <kbd>WriteBarToHUDLeftwards</kbd> (use the latter if you want a truly mirrored bar) to make it extend leftwards (the leftmost tile moves left while the rightmost tile
stays in place). This is useful for displaying enemy HP bars that are &ldquo;right aligned&rdquo; that have lengths proportional to how much max HP the enemy has and extend leftwards.<br>
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd><span style="font-weight: bold;">$00</span></kbd> to <kbd><span style="font-weight: bold;">$02</span></kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Status bar tile location to write on this and before (this represent the position of the last tile).</td></tr>
<tr><td><kbd><span style="font-weight: bold;">$03</span></kbd> to <kbd><span style="font-weight: bold;">$05</span></kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Same as above, but for tile properties (if you have enabled tile properties write).</td></tr>
</table><br>
Write range:
<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd><span style="font-weight: bold;">$00</span></kbd> to <kbd><span style="font-weight: bold;">$02</span></kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>The tile number location where to write the starting starting (leftmost) tile, calculated via subtracting what you have inputed by
the number of tiles, minus 1 (<kbd>LeftmostTilePosition = RAMAddressIn00 - ((NumberOfTiles-1) * TileFormat)</kbd>, where <kbd>RAMAddressIn00</kbd> is the RAM address prior calling this routine),
then writes back to <kbd>$00</kbd>.</td></tr>
<tr><td><kbd><span style="font-weight: bold;">$03</span></kbd> to <kbd><span style="font-weight: bold;">$05</span></kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Same as above, but for tile properties (if you have enabled tile properties write).</td></tr>
</table><br>
After executing this subroutine, then calling <kbd>WriteBarToHUD</kbd> or <kbd>WriteBarToHUDLeftwards</kbd> now have their tile write range be modified:
<table>
<tr><th><kbd>WriteBarToHUD</kbd> and <kbd>WriteBarToHUDLeftwards</kbd>'s modified tile write range:</th><th>Number of bytes</th><th>Description</th></tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">RAMAddressIn00 - ((NumberOfTiles-1) * TileFormat)</span></span></kbd> to <span class="NoLineBreak"><kbd><span style="font-weight: bold;">RAMAddressIn00</span></kbd></span></td>
<td><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td>
<td>The tile numbers of the bar.</td>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">RAMAddressIn03 - ((NumberOfTiles-1) * TileFormat)</span></span></kbd> to <span class="NoLineBreak"><kbd><span style="font-weight: bold;">RAMAddressIn03</span></kbd></span></td>
<td><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td>
<td>The tile properties of the bar.</td>
</tr>
</table><br>
<img src="readme_files/BarExtendLeftTiles.png"><br>
Example when using the super status bar patch:<br>
<img src="readme_files/BarExtendLeftTiles_OnStatBar.png"><br>
Be careful with bank borders crossing (don't have status bar tile tables that goes from <kbd>$7EFFFF</kbd> to <kbd>$7F0000</kbd>, for a made-up example), as I discovered that
Akaginite's <kbd>16Bit - 8Bit</kbd> (done by <kbd>((-8Bit) + 16Bit</kbd>)) does not work with bank borders if <kbd>8Bit</kbd> is <kbd>$00</kbd> because that causes the carry flag
to be clear, unlike the normal SBC. However, this is very unlikely as no status bar tile tables would ever do that.<br><br>

Don't use this for stripe image, since this modifies <span style="font-weight: bold;">what address</span> the bar starts on. Stripe, however have positions based on whats in the header rather than what address.</li><br>
<li><a href="#WriteBarStaticTileToHUD_Back" id="WriteBarStaticTileToHUD">^</a><span id="StaticEndRoutine">Static end tiles handlers</span> (this calculates where to write the static
end tiles based on the length of the bar and also writes to tile number and properties, <a href="#StaticEndTiles">as mentioned earlier</a>).
<ul>
<li><kbd>WriteBarStaticTileToHUDLeftside</kbd>: Writes tile for the left side of the bar (a tile just before the bar's leftmost tile). Writes at <kbd>RAMAddressIn00 - TileFormat</kbd> for
a bar that extend rightwards and <kbd>RAMAddressIn00 - (NumberOfTiles*!StatusBarFormat)</kbd> for leftwards.</li>
<li><kbd>WriteBarStaticTileToHUDRightside</kbd>: Same as above but for the rightside. Writes at <kbd>RAMAddressIn00 + (NumberOfTiles*!StatusBarFormat)</kbd> for extend-right bars and
<kbd>RAMAddressIn00 + TileFormat</kbd> for extend-left.</li><br>
</ul><br>
If you use <kbd>BarExtendLeft</kbd>, execute that routine, and then this static end tile handler, as that routine modifies the area where to write the bar.

Note that this is unaffected by <kbd>WriteBarToHUDLeftwards</kbd>, meaning that static end tiles don't automatically flip. Inputs are:

<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr>
<td><kbd>$00</kbd> to <kbd>$02</kbd></td>
<td style="text-align: center; vertical-align: middle;">3</td>
<td rowspan="2">Same as <kbd>WriteBarToHUD</kbd></td>
</tr>
<tr>
<td><kbd>$03</kbd> to <kbd>$05</kbd></td>
<td style="text-align: center; vertical-align: middle;">3</td>
</tr>
<tr>
<td><kbd>$06</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td>Tile properties to write (if you have enabled tile properties write).</td>
</tr>
<tr>
<td><kbd>$07</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td>Tile number to write</td>
</tr>
</table>
</li><br>
<li><a href="#CountNumberOfTiles_Back" id="CountNumberOfTiles">^</a><kbd>CountNumberOfTiles</kbd>: Counts how many tiles the bar uses, minus 1. This is used by other routines when writing to the status bar to figure out how many tiles to write. It is also used
to calculate where to place the bar when using <kbd>BarExtendLeft</kbd> as well as where to place static end tiles when running the static end tile handlers.
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Used for counting tiles.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd><span class="NoLineBreak">X register</span></kbd></td><td>1 (not stored)</td><td>The number of tiles, minus 1 (if the bar has 9 tiles, X would be <kbd>$08</kbd>). Returns <kbd>$FF</kbd> if 0 tiles exist (the whole bar set to 0 pieces in total)</td></tr>
</table><br>

This subroutine also exists in <kbd>GraphicalBarConvertToTile.asm</kbd> because of one simple inconvenient reason: several subroutines in that and <kbd>GraphicalBarWriteToStatusBar.asm</kbd> uses this subroutine and you cannot
have one <kbd>library</kbd> ASM file have labels referring to another ASM file in that library (you cannot have one code in a library call another ASM file code), as stated in the readme:
<table><tr><td><pre>The second one is that you can't call other libraries codes from a
library file. For example, if you have a windowing HDMA code and you
need to call a sqrt routine, which is located on the math library, you
can't do that, because UberASM Tool can't guess what labels each file
will generate nor what labels each library .asm file will depend from
each other. So unfortunately the library files are pretty much
isolated from each one.</pre></td></tr></table>

</li><br>
<li><a href="#WriteDoubleEndedBar_Back" id="WriteDoubleEndedBar">^</a><kbd>WriteDoubleEndedBar</kbd>: Writes a mirrored version of the left-to-right bar and places it to the left of that bar. This is intended to display double-ended bars that as the fill increases, it starts in the center
and fill towards both ends (<img src="readme_files/DoubleEndedBar.gif">). You call this routine after calling <kbd>DrawGraphicalBar</kbd> (don't use the leftwards version). NOTE: The mirrored copy ALWAYS have the X-bit in YXPCCCTT
being SET (the bar graphic tiles must be filling left-to-right by default).

<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Needed to count how many tiles to figure out where the starting address for the mirrored bar.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>$00</kbd> to <kbd>$02</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>The address location of the <span style="font-weight: bold;">starting</span> tile of the original left-to-right bar for tile numbers.</td></tr>
<tr><td><kbd>$03</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Same as above but tile properties.</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>Address_In_00-(NumberOfTiles*!StatusBarFormat)</kbd> to <kbd>Address_In_00-(1*!StatusBarFormat)</kbd></td><td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td><td>The area where the flipped bar will be written at (tile numbers).</td></tr>
<tr><td><kbd>Address_In_03-(NumberOfTiles*!StatusBarFormat)</kbd> to <kbd>Address_In_03-(1*!StatusBarFormat)</kbd></td><td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td><td>Same as above but tile properties</td></tr>
<tr><td><kbd>$06</kbd> to <kbd>$08</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td rowspan="2">(overwritten, not useful after this routine) Needed since the address of the original bar and mirrored are both needed during the loop.</td></tr>
<tr><td><kbd>$09</kbd> to <kbd>$0B</kbd></td><td style="text-align: center; vertical-align: middle;">3</td></tr>
</table>
</li><br>
<li><a href="#SetupStripe_Back" id="SetupStripe">^</a><kbd>SetupStripe</kbd>: Sets up the stripe. Automatically handles the 4-byte header, terminating byte and length of stripe (you only have to write tile data starting at <kbd>$7F837D+4,x</kbd>). For more information
about stripe data, see <a href="https://www.smwcentral.net/?p=viewthread&t=14531">here</a> (outdated and some info are incorrect), then see <a href="https://smwc.me/1600801">this</a>, and future posts after it.
<table>
	<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$00</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td>X position, 0-63.</td></tr>
	<tr><td><kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td>Y position, 0-63.</td></tr>
	<tr>
		<td>
			<kbd>$02</kbd>
		</td>
		<td style="text-align: center; vertical-align: middle;">1</td>
		<td>
			What layer:
			<ul>
				<li><kbd>$02</kbd>: Layer 1</li>
				<li><kbd>$03</kbd>: Layer 2</li>
				<li><kbd>$05</kbd>: Layer 3</li>
			</ul>
		</td>
	</tr>
	<tr>
		<td>
			<kbd>$03</kbd>
		</td>
		<td style="text-align: center; vertical-align: middle;">1</td>
		<td>
			Direction and RLE: <kbd>%DR00000000</kbd>
			<ul>
				<li><kbd>R</kbd>: Repeat: 0 = no (manually write different tiles), 1 = yes (write one tile multiple times, based on input <kbd>$04-$05</kbd>)</li>
				<li><kbd>D</kbd>: Direction: 0 = horizontal (rightwards), 1 = vertical (downwards)</li>
			</ul>
		</td>
	</tr>
	<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>Number of tiles, minus 1 (a value of 2 here means 3 tiles). If RLE is used, this is how many times a tile is repeated, minus 1.</td></tr>
</table><br><br>

<table>
	<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$7F837B</kbd> to <kbd>$7F837C</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>Updated length of stripe data.</td></tr>
	<tr><td><kbd>X register</kbd></td><td style="text-align: center; vertical-align: middle;">2 (not stored)</td><td>The index position of where to write tile data (starting at <kbd>$7F837D+4,x</kbd>).</td></tr>
</table><br><br>

<table>
	<tr><th>Destroyed</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$06</kbd> to <kbd>$08</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Used when not using RLE, to calculate the terminating byte location.</td></tr>
</table><br>
After calling that, all you have to do is write your tile data to <kbd>$7F837D+4,x</kbd> (XY register will be 16-bit) and beyond, but be careful not to overwrite the terminating byte (and potentially the bytes after) if this is your last stripe within a frame.
Just like the Super Status Bar patch and OWB+, its tile data format is &ldquo;2-bytes together&rdquo;.
</li>
</ul>


<li><a href="#GraphicalBarOtherRoutinesBack" id="GraphicalBarOtherRoutines">^</a>Inside <kbd>GraphicalBarOtherRoutines.asm</kbd></li>
<ul>
<li><a href="#MapRangeToStartAt0_Back" id="MapRangeToStartAt0">^</a><kbd>MapRangeToStartAt0</kbd>: Maps any given range, and the quantity (of 3 given numbers) to a zero-based range (for use so that any number that is the minimum maps to
0% and maximum to 100%, akin to <a href="https://en.wikipedia.org/wiki/Feature_scaling#Rescaling_(min-max_normalization)">Min-max feature scaling</a>, but this subroutine merely subtracts Quantity and MaxQuantity by <kbd>min</kbd> so it is 0). For example: A range from 75 to 100 with a quantity of 85 would be converted to 0 to 25 with a quantity of 10. This is useful for stacked bars like EXP progress bar or multiple HP bars for bosses. You call this
routine before you call <kbd>CalculateGraphicalBarPercentage</kbd>.
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The quantity (expected to be in between two numbers).</td></tr>
<tr><td><kbd>$02</kbd> to <kbd>$03</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The minimum quantity.</td></tr>
<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The maximum quantity.</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th><th>Where to write for <kbd>CalculateGraphicalBarPercentage</kbd></th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The quantity, subtracted by minimum quantity. <kbd>ZeroBasedQuantity = max(Quantity - Minimum, 0)</kbd></td><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl+1</kbd></td></tr>
<tr><td><kbd>$02</kbd> to <kbd>$03</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The minimum quantity (stayed the same).</td><td>Not used (because this will always be zero by subtracting by itself, if it were used).</td></tr>
<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The maximum quantity (subtracted by minimal quantity), this is also the size of the range. <kbd>ZeroBasedMaxQuantity = MaxQuantity - MinQuantity</kbd></td><td><kbd>!Scratchram_GraphicalBar_FillByteTbl+2</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl+3</kbd></td></tr>
</table><br>

I've made a test file <kbd>Level_RangeBased.asm</kbd> (located in <kbd>UberasmTool_ExampleUsage</kbd> folder) that demonstrates this.
</li><br><br>

<li><a href="#InvertQuantity_Back" id="InvertQuantity">^</a><kbd>InvertQuantity</kbd>: Inverts the quantity (example: 12/100 &rightarrow; 88/100). This is useful
for in case you wanted something that increments (in memory), but the bar decreases from 100%. This is calculated simply by taking the maximum amount subtracting by the current amount, in this case, <kbd>100 - 12 = 88</kbd>. If quantity is exceeding maximum prior calling this routine,
will output zero. NOTE: It is better to use this subroutine to handle the literal quantity amounts prior calling <kbd>CalculateGraphicalBarPercentage</kbd> rather than to invert the fill amount to avoid potential accumulating rounding errors.<br><br>

<ul>
	<li>In Vanilla SMW, chargin chucks, all koopalings besides wendy and lemmy uses an &ldquo;inverted health&rdquo; system: A damage
	counter that increases every damage they take, and dies when it hits 3 (stomps for all HP based sprites), 5 (fireballs, for chucks), or 12 (for Ludwig). But there's a quirk:  regardless of which way to damage these characters, will always deal the same 1 point of damage. The number of hits
	to defeat is based on the last hit reaching or exceeding a value in which that value depends on the aforementioned damage type. This means you can quickly defeat SMW enemies/bosses effectively bypassing their invulnerability timer by shooting 2 fireballs, followed by stomping them, as they only
	gain their invulnerability timer from stomp attack, that the fireballs are worth the same as stomping, and that it was programmed that having 3 points of damage after a stomp defeats the sprite.</li><br>
	<li>A simple way to fix this anomaly is to have the kill threshold is not to have multiple values depending on the attack, but have a single value regardless of an attack, and make damages they take be at different values. To get the desired hits to defeat, do <kbd>Damage = <abbr title="Always round up to an integer; get lowest integer greater than or equal to X.">Ceiling</abbr>(TotalDamageToKill / NumberOfHits)</kbd>, Therefore:
	<table>
		<tr>
			<th>Enemy</th>
			<th>Max health/damage to defeat</th>
			<th>Stomp damage</th>
			<th>Fireball damage</th>
		</tr>
		<tr>
			<td>Chargin chuck</td>
			<td>15</td>
			<td>5</td>
			<td>3</td>
		</tr>
		<tr>
			<td>Ludwig</td>
			<td>12</td>
			<td>4</td>
			<td>1</td>
		</tr>
	</table>
	This <a href="https://www.smwcentral.net/?p=section&a=details&id=18148">Patch</a> along with displaying HP, comes with a fix with the janky SMW HP system.
</li><br>

</ul>
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The quantity</td></tr>
<tr><td><kbd>$02</kbd> to <kbd>$03</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The maximum quantity</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The inverted quantity, calculated via <kbd>InvertedQuantity = max(MaxQuantity - Quantity, 0)</kbd></td></tr>
<tr><td><kbd>$02</kbd> to <kbd>$03</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The maximum quantity (unchanged)</td></tr>
</table>
</li>
</ul>
</ol>

<hr>
<h2><a href="#RoutinesInDrawOamPatch_Back" id="RoutinesInDrawOamPatch">^</a>Routines in <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd> and <kbd>Pixi_CustomSprite/Pixi Routines</kbd></h2>

<p>These routines, unlike the status bar routines, writes the graphical bar tiles as <span style="font-weight: bold;">sprite OAM</span>. This is very useful for sprite HUD or HUD placed on a character (rather than static
on-screen position, a bar that is placed relative to the character, such as on top of the character's head).</p>

<h3>Sprite-status bar-styled HUD (placed at highest priority)</h3>
<p>Note: The three following routines are not to be used for &ldquo;normal sprites&rdquo;, as they use the OAM directly (&ldquo;normal sprites&rdquo; is a term I refer to the type of sprites
that are often interactable, such as enemies, platforms, items, etc. that are SMW or pixi-made, that are part of the 12 (or 22 for sa-1 hacks)-sprite slot limit) and are intended to
function similarly to most sprite status bar patches. These are located at <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd>.</p>
<ul>
	<li><a href="#DrawOamGraphicalBarHorizVert_Back" id="DrawOamGraphicalBarHorizVert">^</a><kbd>DrawOamGraphicalBarHoriz</kbd> and <kbd>DrawOamGraphicalBarVert</kbd>: Draws a horizontal/vertical graphical bar:
	<table>
	<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td><kbd>LeftEnd + MiddleLength + RightEnd</kbd></td><td>Tile numbers to write.</td></tr>
	<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center;">2</td><td rowspan="2">X and Y position, relative to screen border. Note: The XY position origin is the top-left of the 8x8 tile where the fill starts at when increasing<sup>1</sup>.</td></tr>
	<tr><td><kbd>$02</kbd> to <kbd>$03</kbd></td><td style="text-align: center;">2</td></tr>
	<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center;">2</td><td>Number of tiles to write.</td></tr>
	<tr>
	<td><kbd>$06</kbd></td>
	<td style="text-align: center;">1</td>
	<td>Direction:
	For horizontal (using <kbd>DrawOamGraphicalBarHoriz</kbd>):
	<ul>
	<li><kbd>$00</kbd> = Left to right</li>
	<li><kbd>$01</kbd> = Right to left (YXPPCCCT's X bit set)</li>
	</ul>
	For vertical (<kbd>DrawOamGraphicalBarVert</kbd>):
	<ul>
	<li><kbd>$00</kbd> = Bottom to top</li>
	<li><kbd>$01</kbd> = Top to bottom (YXPPCCCT's Y bit set)</li>
	</ul>
	</td>
	</tr>
	<tr><td><kbd>$07</kbd></td><td style="text-align: center;">1</td><td>Properties (YXPPCCCT)</td></tr>
	</table><br>
	
	<table>
	<tr><th>Destroyed</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$08</kbd> to <kbd>$09</kbd></td><td style="text-align: center;">2</td><td>Displacement of each tile during processing (after placing each tile, this value gets increased by 8 for rightwards and downwards-filling bar, or decreased for leftwards and upwards-filling bar). Once finished, this will be the X position for horizontal or Y position for vertical after the final tile. This can be used for placing static end tile here.</td></tr>
	</table>
	</li><br>
	<sup>1</sup> When I mean the top left of the tile where the fill starts, it is this:<br>
	<img src="readme_files/SpriteGraphicalBar_origin.png"><br>
	Note the orange dot is the very specific pixel of the 8x8 tile representing the origin of that tile.<br><br>


<li><a href="#FindNFreeOAMSlot_Back" id="FindNFreeOAMSlot">^</a><kbd>FindNFreeOAMSlot</kbd>: This routine is only used by <kbd>DrawOamGraphicalBarHoriz</kbd> and <kbd>DrawOamGraphicalBarVert</kbd>, checks if there are sufficient OAM slots available of a given number.
The purpose of this is to act as a failsafe by simply not drawing the graphical bar at all if there are insufficient number of slots available (say, 8 open slots when the bar needed 9). This is to prevent drawing a bar with missing tiles (makes it so only show all the tiles or none).
	<table>
	<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center;">2</td><td>The number of slots to find. 16-bit because <abbr title="There are 128 slots, numbered from 0-127 ($00-$7F). Therefore the index must be 0-508 ($0000-$01FC), a range that an 8-bit integer cannot support. Another reason is that both X and Y index registers cannot use different 8 or 16-bit sizes.">OAM indexing are increments of 4<abbr></td></tr>
	</table><br>

	<table>
	<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td>
	<kbd>Carry bit</kbd></td><td style="text-align: center;">N/A</td><td>If no slot is available:
	<ul>
	<li>Clear (<kbd>0</kbd>) = Enough slots found</li>
	<li>Set (<kbd>1</kbd>) = Not enough slots available.</li>
	</ul>
	</td></tr>
	</table><br>
	</li>
<h3>Pixi sprite OAM</h3>
<p>These are the routines to use for &ldquo;normal sprites&rdquo;. Useful if you want to display HP bar next to the main body of the sprite. They are located at <kbd>Pixi_CustomSprite/Pixi Routines</kbd>.</p>

<li><a href="#DrawSpriteGraphicalBarHorizVert_Back" id="DrawSpriteGraphicalBarHorizVert">^</a><kbd>DrawSpriteGraphicalBarHoriz</kbd> and <kbd>DrawSpriteGraphicalBarVert</kbd>: The &ldquo;normal sprite&rdquo; versions of above.
To be called after calling <kbd>%GetDrawInfo()</kbd> and before <kbd>$01B7B3</kbd> or <kbd>%FinishOAMWrite()</kbd> in the sprite's code. Note: These always write 8x8 tiles, and when finishing the OAM write, Y must be $FF (indicating you are manually
setting the tile size) should your sprite use both 8x8 and 16x16 tile sizes.
<table>
<tr><th>Input</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd></td><td>Tile numbers to write.</td></tr>
<tr><td><kbd>Y index</kbd></td><td style="text-align: center;">1 (not stored)</td><td>OAM index to use (start from <kbd>$0300</kbd>/<kbd>$0460</kbd>, not <kbd>$0200</kbd>/<kbd>$0420</kbd>)</td></tr>
<tr><td><kbd>$02</kbd></td><td style="text-align: center;">1</td><td rowspan="2">X and Y position, relative to screen border. Note: The XY position origin is the top-left of the 8x8 tile where the fill starts at when increasing.</td></tr>
<tr><td><kbd>$03</kbd></td><td style="text-align: center;">1</td></tr>
<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center;">2</td><td>Number of tiles.</td></tr>
<tr><td><kbd>$06</kbd></td><td style="text-align: center;">1</td><td>Direction:
For horizontal (using <kbd>DrawSpriteGraphicalBarHoriz</kbd>):
<ul>
<li><kbd>$00</kbd> = Left to right</li>
<li><kbd>$01</kbd> = Right to left (YXPPCCCT's X bit set)</li>
</ul>
For vertical (<kbd>DrawSpriteGraphicalBarVert</kbd>):
<ul>
<li><kbd>$00</kbd> = Bottom to top</li>
<li><kbd>$01</kbd> = Top to bottom (YXPPCCCT's Y bit set)</li>
</ul>
</td></tr>
<tr><td><kbd>$07</kbd></td><td style="text-align: center;">1</td><td>Properties (YXPPCCCT)</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>Y index</kbd></td><td style="text-align: center;">1 (not stored)</td><td>OAM index to use, a slot after writing the last tile of the bar.</td></tr>
</table><br>

<table>
<tr><th>Destroyed</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>$08</kbd></td><td style="text-align: center;">1</td><td>Displacement of each tile during processing (after placing each tile, this value gets increased by 8 for rightwards and downwards-filling bar, or decreased for leftwards and upwards-filling bar). Once finished, this will be the X position for horizontal or Y position for vertical after the final tile. This can be used for placing static end tile here.</td></tr>
</table>

</li>
</ul>
<hr>
<h2><a href="#NotesBack" id="Notes">^</a>Notes</h2>
<ul>

<li><p>You don't have to call the routine <kbd>CalculateGraphicalBarPercentage</kbd> to use <kbd>DrawGraphicalBar</kbd>, this means you can make an icon-based HP system that each
tile byte holds a set amount of HP, for example, in the <i>Legend of Zelda</i> series starting in <i>Ocarina of Time</i>, you can have each heart containing 4 pieces representing each 1 HP.</p></li>

<li><p>It is best to avoid having any end tiles holding the same number of pieces as the middle, although it still works, it is less optimized as the routine <kbd>DrawGraphicalBar</kbd> (including <kbd>DrawGraphicalBarSubtractionLoopEdition</kbd>)
itself only takes a value and represent them as each bytes capped at their maximum. Therefore if you're planning to have 8 pieces for both left and right ends, and have 7 middle bytes also
having 8 pieces at the max, it is better to have both end tiles set to 0 pieces and have 9 middle tiles holding 8 pieces, here is what it looks like on a full bar:<br><br>

Less optimized:
<table><tr><td><pre><span style="color: cyan">!Scratchram_GraphicalBar_LeftEndPiece:       $08</span>
<span style="color: #00C000">!Scratchram_GraphicalBar_MiddlePiece:        $08</span>
<span style="color: red">!Scratchram_GraphicalBar_RightEndPiece:      $08</span>
<span style="color: #00C000">!Scratchram_GraphicalBar_TempLength:         $07</span>
RAM address $00-$01:                         $0048 (72)</pre></td></tr></table>
Result:
<table>
<tr>
<td style="background-color: cyan"><span style="color: black"><kbd>+0</kbd></span></td>
<td style="background-color: #00C000"><kbd>+1</kbd></td>
<td style="background-color: #00C000"><kbd>+2</kbd></td>
<td style="background-color: #00C000"><kbd>+3</kbd></td>
<td style="background-color: #00C000"><kbd>+4</kbd></td>
<td style="background-color: #00C000"><kbd>+5</kbd></td>
<td style="background-color: #00C000"><kbd>+6</kbd></td>
<td style="background-color: #00C000"><kbd>+7</kbd></td>
<td style="background-color: red"><kbd>+8</kbd></td>
</tr>
<tr>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
</tr>
</table>
Vs optimized:
<table><tr><td><pre><span style="color: cyan"><s>!Scratchram_GraphicalBar_LeftEndPiece:       $00</s></span>
<span style="color: #00C000">!Scratchram_GraphicalBar_MiddlePiece:        $08</span>
<span style="color: red"><s>!Scratchram_GraphicalBar_RightEndPiece:      $00</s></span>
<span style="color: #00C000">!Scratchram_GraphicalBar_TempLength:         $09</span>
RAM address $00-$01:                         $0048 (72)</pre></td></tr></table>
Result:
<table>
<tr>
<td style="background-color: #00C000"><kbd>+0</kbd></td>
<td style="background-color: #00C000"><kbd>+1</kbd></td>
<td style="background-color: #00C000"><kbd>+2</kbd></td>
<td style="background-color: #00C000"><kbd>+3</kbd></td>
<td style="background-color: #00C000"><kbd>+4</kbd></td>
<td style="background-color: #00C000"><kbd>+5</kbd></td>
<td style="background-color: #00C000"><kbd>+6</kbd></td>
<td style="background-color: #00C000"><kbd>+7</kbd></td>
<td style="background-color: #00C000"><kbd>+8</kbd></td>
</tr>
<tr>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
</tr>
</table>
The only difference is the FillAmount &rightarrow; TileNumber conversion <kbd>ConvertBarFillAmountToTiles</kbd> (and the doublebar version) that utilizes the tile number you need
to change (Left end have 9 tiles with values 0-8 same as middle's 0-8 but uses a different array tiles to display a outlined-left edge and same goes to the right end). However,
the tile converter does not recognize if the first and last tile are meant to be end tiles to have different graphic than the middle, so just before calling the tile converter,
set the end tiles to be the same number of pieces for middle, and subtract the number of middle tiles by how many end tiles you are using (say 2) so that the end tiles don't use
the same table graphic as middle and cause cutoff-ended bar.
<table><tr><td><pre>	;[...]
	JSL GraphicalBarELITE_DrawGraphicalBar				;&gt;get bar values.
	LDA #$08							;\Middle tiles first and last replaced with end tiles.
	STA !Scratchram_GraphicalBar_LeftEndPiece			;|
	STA !Scratchram_GraphicalBar_RightEndPiece			;|
	LDA !Scratchram_GraphicalBar_TempLength				;|
	SEC								;|
	SBC #$02							;|&gt;Left end + Right end = 2 end tiles
	STA !Scratchram_GraphicalBar_TempLength				;/
	JSL GraphicalBarConvertToTile_ConvertBarFillAmountToTiles	;&gt;Convert tiles (end tiles recognized).
	;[...]</pre></td></tr></table><br><br>

</p></li>
<li><p>You might've noticed the define <span class="NoLineBreak"><kbd>!Settings_GraphicalBar_IndexSize</kbd></span> found in <kbd>GraphicalBarDefines.asm</kbd>, I left that there in for some rare cases anyone
would need a bar that is more than 255 tile bytes long (So a 16-bit addressing was needed).</p></li>

<li><p>Be careful when you call the routine <kbd>WriteBarToHUD</kbd> (and <kbd>WriteBarToHUDLeftwards</kbd>), as because this is multi-bytes based, it will write from
<span class="NoLineBreak"><kbd>!Default_GraphicalBarPosition</kbd></span> to <span class="NoLineBreak"><kbd>!Default_GraphicalBarPosition+((NumberOfTiles-1)*!StatusBarFormat)</kbd></span> address. Thus if you place the bar at RAM address
<kbd>$0F2F</kbd>, the address bytes beyond that (which is non-status-bar-related data, from timer data, scores, then an unused RAM area ($0F3A) and so on) gets overwritten.</p></li>

<ul><li><p>However, if you are using the &ldquo;extend leftwards&rdquo; (not to be confused with a leftwards <span style="font-weight: bold;">filling bar</span>; the bar that extends leftwards as you increase the length),
the address write range is <kbd>DesiredLastTilePos-((NumberOfTiles-1)*!StatusBarFormat)</kbd> to <kbd>DesiredLastTilePos</kbd>, so be careful not to have the bar data be written past the starting RAM
address of the status bar (avoid placing the <kbd>DesiredLastTilePos</kbd> that would cause placing the tiles before the first byte of the status bar tiles).</p></li></ul>

<li>When writing stripe image <b>every frame</b> during levels, make sure you don't write them during the &ldquo;COURSE CLEAR!&rdquo; text (the text appears when <kbd>JSL $05CBFF</kbd> is executed), as it causes the text to glitch out
with some areas having the wrong tiles. Easiest way is to check RAM <kbd>$1493</kbd> like so:
<table><tr><td><pre>
LDA $1493|!addr		;\If goal text is dispayed, don't write the bar during that.
BEQ .SafeToWrite	;/(this is merely a timer of the goal animation, not necessary a RAM that is nonzero when the actual "COURSE CLEAR!" message)
.NotSafeTo
	;[...]
	RTL
.SafeToWrite
	;Code to write your bar here
	;[...]
	RTL</pre></td></tr></table>

</li>
</ul>
<hr>
<h2><a href="#CreditsBack" id="Credits">^</a>Credits</h2>
<ul>
<li><a href="https://www.smwcentral.net/?p=profile&id=8691">Akaginite</a>, for making the math routines</li>
<li><a href="https://www.smwcentral.net/?p=profile&id=4842">Ladida</a>, I borrowed a few lines of her code (and asked for permission):<br>
<img src="readme_files/LadidaPermission.png"></li>
<li><a href="https://www.smwcentral.net/?p=profile&id=41003">JamesD28</a>, of a sprite crashing bug experienced (<kbd>%GetDrawInfo()</kbd> uses a &ldquo;destroy return address&rdquo; (you pull out bytes pushed by the JSL/JSR just before the RTL/RTS, so that it exits out multiple subroutines upon hitting a RTL/RTS))</li>
<li><a href="https://www.smwcentral.net/?p=profile&id=36308">KevinM</a> and <a href="https://www.smwcentral.net/?p=profile&id=12344">LX5</a>, for some knowledge of the technical bits of OAM writing.</li>
<li><a href="https://www.smwcentral.net/?p=profile&id=3879">dahnamics</a>, for the Giant Masked Koopa boss sprite</li>
<li><a href="https://www.w3schools.com/">W3Schools</a> and <a href="https://stackoverflow.com">stackoverflow</a><sup><a href="https://stackoverflow.com/questions/11409895/whats-the-most-elegant-way-to-cap-a-number-to-a-segment">[1]</a></sup>, for making a tutorial on how to make HTML and javascript codes.</li>
<li><a href="https://developer.mozilla.org/en-US/">MDN web docs (by mozilla)</a>, for documenting a lot on JS</li>
</ul>

<script>
//These makes all <pre>...</pre> have an effect that double-clicking will select all the text
//in it, to make it easy to copy code and paste it in your ASM stuff.
//
//Credit:
// https://keestalkstech.com/2014/04/click-to-select-all-on-the-pre-element/
// https://www.sanwebe.com/2014/04/select-all-text-in-element-on-click
document.addEventListener('dblclick', e => {
  let pre = getClosest(e.target, "PRE");
  if (pre && e.ctrlKey) {
    let range = new Range();
    range.selectNodeContents(pre);
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(range);
  }
});

function getClosest(el, tagName) {
  tagName = tagName && tagName.toUpperCase();

  if (!tagName || !el)
    return null;

  do
    if (el.nodeName === tagName)
      return el;
  while (el = el.parentNode);

  return null;
}
</script>