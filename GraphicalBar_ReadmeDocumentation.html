<html>
	<head>
		<style>
			html {
			background-color: #101010;
			color: rgb(221, 221, 221);
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
			img.img-hor {
				-moz-transform: scaleX(-1);
				-o-transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
				transform: scaleX(-1);
				filter: FlipH;
				-ms-filter: "FlipH";
			}
			li {
				padding: 5px;
			}
			div.CodeBlock {
				overflow: auto;
				width: 1000px;
				height: 250px;
				border: 1px solid white;
				resize: both;
				background-color: #101010;
			}
			pre {
				margin: 0px;
			}
		</style>
	</head>
<body style="max-width: 1000px; margin: auto; padding: 15px">
<center><h1>Graphical Bar ELITE</h1><br>
By <a href="https://www.smwcentral.net/?p=profile&id=18802">GreenHammerBro</a><br>
See <a href="https://github.com/GhbSmwc/SMW-Graphical-bar-display">github</a>.</center>

<h2>Introduction</h2>
<p>This is a guide on how to setup a display of a value of something as a graphical bar (or progress bar) that you see in many games. Unlike some hacks like
SMWCP2 and brutal Mario (both as health bars), which are 1-unit (or piece) per tile being displayed, this package contains code to display multiple units
per tile (8 units normally), as well as representing a ratio of something with any number (1-65535) as the max. This means that this can have more accurate
representation (or &ldquo;smoother increments&rdquo;) of a value (say it approximate to the nearest pixel instead of 8x8 tile) as a percentage and have any maximum amount without affecting the
length of the bar.</p>

<p>Make sure you read the comments at the top in the ASM files to fully understand them. This readme covers most of those info.</p>

<p>It supports both layer 3 and sprite OAM.</p>


<h2>Before we begin</h2>
<ul>
<li>This HTML uses <a href="https://en.wikipedia.org/wiki/ASCII_art">ASCII art</a> to represent something in few areas, so make sure you have your browser setting for <a href="https://en.wikipedia.org/wiki/Monospaced_font">fixed-width font</a> such as
&ldquo;Consolas&rdquo; so it displays properly.</li>
<li>You must have at least some ASM knowledge. See this ASM tutorial <a href="https://www.smwcentral.net/?p=section&a=details&id=14268">here.</a></li>
<li>This document assumes you have some knowledge on how to use the Heads-Up display (HUD) elements. If you are new to that, I recommend reading my <a href="https://www.smwcentral.net/?p=section&a=details&id=39627">status bar tutorial</a> before doing this.</li>
<li>If you want to easily select and copy text inside of boxes, hold down CTRL and double-click them.</li>
<li>The HTML files included here uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><kbd>BigInt</kbd></a> to prevent potential rounding upwards instead of downwards. Make sure your browser supports it.</li>
</ul>
<hr>
<h2>Quick jumps:</h2>
<ul>
<li><a href="#Installation" id="InstallationBack">Installation (test run, uberasm tool)</a></li>
<li><a href="#OwnGraphicalBar" id="OwnGraphicalBarBack">Displaying your own value as a graphical bar (Uberasm tool, Layer 3)</a></li>
<li><a href="#CustomSprites" id="CustomSprites_Back">Drawing OAM (Normal sprites (SMW sprites or pixi), not cluster, extended, minor extended, etc.)</li>
	<ul>
		<li><a href="#ProgrammingOtherCustomSprites" id="ProgrammingOtherCustomSprites_back">Programming with other sprites.</a></li>
		<li><a href="readme_files/GMKBossSummary.html" id="GMKBossSummary_TOCBack">Giant Masked Koopa boss editing example summary/tutorial</li>
	</ul>
<li><a href="#DrawOamPatch" id="DrawOamPatch_Back">Drawing OAM (not using sprite slots, but patch using OAM).</a></li>
<li><a href="#AsmDocumentation" id="AsmDocumentationBack">ASM Documentation</a></li>
<ul>
	<li><a href="#GraphicalBarELITE" id="GraphicalBarELITEBack"><kbd>GraphicalBarELITE.asm</kbd></a></li>
	<ul>
		<li><a href="#CalculateGraphicalBarPercentage" id="CalculateGraphicalBarPercentage_Back"><kbd>CalculateGraphicalBarPercentage</kbd>, <kbd>CalculateGraphicalBarPercentageRoundDown</kbd>, and <kbd>CalculateGraphicalBarPercentageRoundUp</kbd></a></li>
		<li><a href="#DrawGraphicalBar" id="DrawGraphicalBar_Back"><s><kbd>DrawGraphicalBar</kbd></s></a> (depreciated and commented out, please use <kbd>DrawGraphicalBarSubtractionLoopEdition</kbd> instead)</li>
		<li><a href="#DrawGraphicalBarSubtractionLoopEdition" id="DrawGraphicalBarSubtractionLoopEdition_Back"><kbd>DrawGraphicalBarSubtractionLoopEdition</kbd></a></li>
		<li><a href="#TOCRoundAwayFromComplete" id="TOCRoundAwayFromComplete_Back"><kbd>Round away from empty/full/both</kbd></a></li>
	</ul>
	<li><a href="#GraphicalBarConvertToTile" id="GraphicalBarConvertToTileBack"><kbd>GraphicalBarConvertToTile.asm</kbd></a></li>
	<ul>
		<li><a href="#ConvertBarFillAmountToTiles" id="ConvertBarFillAmountToTiles_Back"><kbd>ConvertBarFillAmountToTiles</kbd></a></li>
		<li><a href="#ConvertBarFillAmountToTilesDoubleBar" id="ConvertBarFillAmountToTilesDoubleBar_Back"><kbd>ConvertBarFillAmountToTilesDoubleBar</kbd></a></li>
		<li><a href="#ConvertBarFillAmountToTilesEdgeOverMultipleTiles" id="ConvertBarFillAmountToTilesEdgeOverMultipleTiles_Back"><kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTiles</kbd></a></li>
		<li><a href="#ConvertBarFillAmountToTilesIndirectAddressTable" id="ConvertBarFillAmountToTilesIndirectAddressTable_Back"><kbd>ConvertBarFillAmountToTilesIndirectAddressTable</kbd></a></li>
		<li><a href="#ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable" id="ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable_Back"><kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable</kbd></a></li>
	</ul>
	<li><a href="#GraphicalBarWriteToStatusBar" id="GraphicalBarWriteToStatusBarBack"><kbd>GraphicalBarWriteToStatusBar.asm</kbd></li>
	<ul>
		<li><a href="#WriteBarToHUD" id="WriteBarToHUD_Back"><kbd>WriteBarToHUD</kbd></a></li>
		<li><a href="#WriteBarToHUDLeftwards" id="WriteBarToHUDLeftwards_Back"><kbd>WriteBarToHUDLeftwards</kbd></a></li>
		<li><a href="#WriteBarToHUDVertically" id="WriteBarToHUDVertically_Back"><kbd>WriteBarToHUDVertically</kbd></a></li>
		<li><a href="#BarExtendLeft" id="BarExtendLeft_Back"><kbd>BarExtendLeft</kbd></a></li>
		<li><a href="#WriteBarStaticTileToHUD" id="WriteBarStaticTileToHUD_Back"><kbd>Write static tiles</kbd></a></li>
		<li><a href="#CountNumberOfTiles" id="CountNumberOfTiles_Back"><kbd>CountNumberOfTiles</kbd></a></li>
		<li><a href="#WriteDoubleEndedBar" id="WriteDoubleEndedBar_Back"><kbd>WriteDoubleEndedBar</kbd></a></li>
		<li><a href="#SetupStripe" id="SetupStripe_Back"><kbd>SetupStripe</kbd></a></li>
	</ul>
	<li><a href="#GraphicalBarOtherRoutines" id="GraphicalBarOtherRoutinesBack"><kbd>GraphicalBarOtherRoutines.asm</kbd></a></li>
	<ul>
		<li><a href="#MapRangeToStartAt0" id="MapRangeToStartAt0_Back"><kbd>MapRangeToStartAt0</kbd></a></li>
		<li><a href="#InvertQuantity" id="InvertQuantity_Back"><kbd>InvertQuantity</kbd></a></li>
	</ul>
	<li><a href="#RoutinesInDrawOamPatch" id="RoutinesInDrawOamPatch_Back">Routines in <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd> and <kbd>Pixi_CustomSprite/Pixi Routines</kbd></a></li>
	<ul>
		<li><a href="#DrawOamGraphicalBarHorizVert" id="DrawOamGraphicalBarHorizVert_Back"><kbd>DrawOamGraphicalBarHoriz</kbd> and <kbd>DrawOamGraphicalBarVert</kbd></a></li>
		<li><a href="#FindNFreeOAMSlot" id="FindNFreeOAMSlot_Back"><kbd>FindNFreeOAMSlot</kbd></a></li>
		<li><a href="#DrawSpriteGraphicalBarHorizVert" id="DrawSpriteGraphicalBarHorizVert_Back"><kbd>DrawSpriteGraphicalBarHoriz</kbd> and <kbd>DrawSpriteGraphicalBarVert</kbd></a></li>
	</ul>
</ul>
<li><a href="#Notes" id="NotesBack">Notes</a></li>
<li><a href="#Credits" id="CreditsBack">Credits</a></li>


</ul>
<hr>
<h2>The resources you need</h2>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=18113">Uberasm tool</a>, needed for codes to run every frame.</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=18716">Lunar Magic</a>, for level testing purposes.</li>
</ul>
<h2>Stuff you MAY need</h2>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=19545">Shared subroutines patch</a>, if you wanted to not have duplicate subroutines in your game.</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=25953">Asar</a></li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=26026">pixi</a> (if you are inserting custom sprites). Make sure you are using the latest version.</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=15222">Overworld Border plus</a>, required if you want to display a graphical bar on the overworld border
(i.e <kbd>UberasmTool_ExampleUsage/Gamemode0E_OWBorderTest.asm</kbd>)</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=24816">No More Sprite Tile limits</a>, if you are going to use the pixi custom sprite that draw a bar on OAM.</li>
</ul>
<h3>Recommended resources</h3>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=16031">Super Status Bar patch</a>, SMW's status bar (or, heads-up display (HUD)) space is really small. Most of the ASMs and defines here, by default, assumes
you are using this patch.</li>
<li>
	<a href="https://www.smwcentral.net/?p=section&a=details&id=29064">Address tracker v4+</a>, if you already have inserted other ASM stuff that occupies freeram, I made it so it sets the RAM for you to avoid conflicts:
<div class="CodeBlock" style="height: 106px; width: 930px;"><pre>
GraphicalBar	!Scratchram_GraphicalBar_LeftEndPiece	1	-	-
GraphicalBar	!Scratchram_GraphicalBar_MiddlePiece	1	-	-
GraphicalBar	!Scratchram_GraphicalBar_RightEndPiece	1	-	-
GraphicalBar	!Scratchram_GraphicalBar_TempLength	1	-	-
GraphicalBar	!Scratchram_GraphicalBar_FillByteTbl	12	-	-
GraphicalBar	!Freeram_RangeBasedValue	2	-	-
GraphicalBar	!Scratchram_WhatRange	2	-	-</pre></div>
	After getting the results, just place it at the bottom after ALL the free/scratch RAM defines (will override the previous default values). Please note that I assume you only need 12 or less bytes for
	<kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd>, in rare situations that you need a really long bar that is more than 12 fill-able tiles long, then you need to change that number to a higher value.
</li>
</ul>
<h2>Javascript tools</h2>
<p>Note many of these uses <kbd><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</a></kbd>, to avoid potential precision issues with double-precision. Make sure your browser
supports it.</p>
<ul>
	<li><a id="TopJSLink" href="readme_files/JS_GraphicalBarCalculator3.html">Calculate the graphical bar's memory usage</a></li>
	<li><a id="CalculatePercentageRoundBounds" href="readme_files/JS_GraphicalBar_PercentageRoundQuantityRanges.html">CalculateGraphicalBarPercentage's range of inputs to amount of pieces filled</li>
	<li><a id="GraphicsTable" href="readme_files/JS_GraphicsNotes.html">Graphics notes</a></li>
	<li><a id="OAMNotes" href="readme_files/JS_OAM_Side_notes.html">OAM table and conversion sheet</a></li>
	<li>Tile property converters. Note they're not the same, rather similar, layer 3 has 2-bits (0-3) for page number and 1-bit (0-1) for priority, while sprites
have 1-bit for page number and 2-bits of priority:</li>
<ul>
	<li><a id="Layer3Props" href="readme_files/JS_YXPCCCTT.html">Layer 3 properties (YXPCCCTT) converter</a></li>
	<li><a id="SpriteProps" href="readme_files/JS_YXPPCCCT.html">Sprite properties (YXPPCCCT) converter</a></li>
</ul>
	<li><a id="StripeHeaderConverter" href="readme_files/JS_StripeHeaderConverter.html">Stripe header converter</a></li>
	<li><a id="CenterBar" href="readme_files/JS_BarOAMCenterPos.html">Getting the sprite graphical bar to center with the sprite</a></li>
</ul>

<hr>
<h2><a href="#InstallationBack" id="Installation">^</a>Installation (test run, uberasm tool)</h2>
<ol>
<li>First make any necessary changes to the defines in <kbd>GraphicalBarDefines</kbd>. Assuming you testing this out on a clean ROM with nothing
else besides LM making modifications, it is likely you don't have to edit anything. However, if you're planning to use the Super Status Bar patch, open
<kbd>StatusBarSettings.asm</kbd> and change <span class="NoLineBreak"><kbd>!StatusBarFormat</kbd></span> to <kbd>$02</kbd> and <span class="NoLineBreak"><kbd>!StatusBar_UsingCustomProperties</kbd></span>
to <kbd>1</kbd> so that it displays properly.<br><br>
<ul>
<li>Don't forget, if you want to display a graphical bar on the overworld, you need to install the Overworld Border Plus patch (using the vanilla OWB is very difficult
to modify, and that codes here only supports the OWB+ patch). Remember that this have the same tile data format as the super status bar patch, don't worry about
<kbd>!StatusBarFormat</kbd> (this only influences the status bar-related code and not the border) as the routines support hybrid tile formats (you can have status
bar's &ldquo;each next tile is next byte&rdquo; format and OWB+'s &ldquo;each next tile is next 2 bytes over, provided you have set <kbd>!OWPlusAndSSBSameFormat</kbd> to <kbd>0</kbd>).</li><br>

<li>Another thing to note is the define <kbd>!StatusBar_UsingCustomProperties</kbd>, this applies to <span sty;e="font-weight: bold;">both</span> the status bar and the overworld border plus patch. This is because both
writes to the status bar and the border reuses the same &ldquo;write tile&rdquo; routines to save space. Thankfully, most status bar patches that are layer 3-based,
regardless of the formats, will likely enable you to edit their tile properties, so its more likely you have to set this define to 1 (its 0 by default).</li><br>
</ul>

</li>
<li>Now paste the folders:
<ul>
<li><kbd>GraphicalBarDefines</kbd> (the folder itself) &rightarrow; Uberasm tool's main directory (same area as the .exe)</li>
<li>Inside <kbd>Routines</kbd> folder*, <kbd>GraphicalBarELITE.asm</kbd>, <kbd>GraphicalBarOtherRoutines</kbd>, <kbd>GraphicalBarConvertToTile.asm</kbd>, and <kbd>GraphicalBarWriteToStatusBar.asm</kbd> &rightarrow; Uberasm tool's <kbd>library</kbd>.</li>
<li><span style="font-weight: bold;">Inside</span> the folder <kbd>UberasmTool_ExampleUsage</kbd>, they go to their respective locations based on their filename.</li>

<p>*Please note that if you wish to test <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd>, only copy these files, don't move (&ldquo;cut&rdquo;) to the parent/subdirectory or rename them, else you get errors upon patching.</p>
</ul></li>
<li>Open uberasm tool's <kbd>list.txt</kbd>, and paste these so that the codes get inserted:
<div class="CodeBlock" style="width: 547px; height: 171px;"><pre>; Level list. Valid values: 000-1FF.
level:
104		Level_DoubleBar.asm
105		Level_Simple.asm
106		Level_RoundAwayFromComplete.asm

;[...]

gamemode:
; Insert files here
;0E		Gamemode0E_OWBorderTest.asm ;&gt;Need OWB+ patch to function!</pre></div><br>
</li>
<li>Insert the graphics by (see <a href="readme_files/JS_GraphicsNotes.html" target="_blank">this graphic documentation</a>):
<ol>
<li>Create the &ldquo;ExGraphics&rdquo; if you haven't done so by clicking on the blue mushroom in Lunar Magic.</li>
<li>Paste the graphic bin files found in this package's <kbd>ExGraphics</kbd> folder. The graphics include but not limited to:
<ul>
	<li>Transparent background: <img src="readme_files/TransperentBackground.png"></li>
	<li>Black background: <img src="readme_files/BlackBackground.png"></li>
	<li>Megaman-styled: <img src="readme_files/MegamanHPBar.png"> Note: make sure you follow the instructions provided in <a href="readme_files/JS_GraphicsNotes.html" target="_blank"><kbd>readme_files/JS_GraphicsNotes.html</kbd></a> as the fill amounts and tile layouts may differ</li>
</ul>
Please note that there are huge combinations of this due to how many variations there are (<a href="readme_files/DoubleBarInfo.html">double bar</a>, <a href="readme_files/FillEdgeCrossingTileBorder.html">custom fill-edges</a> etc), therefore the listed examples will not cover every combinations.<br><br>

Note: If you're using the minimalistic status bar patch, I recommend using &ldquo;BlackBackground&rdquo; to be able to see the maximum; since the outlines on &ldquo;TransperentBackground&rdquo; would camouflage and you only see the fill amount,
unless you change the minimalistic status bar patch's background color.<br><br>

This readme assumes you're using &ldquo;TransperentBackground&rdquo;.</li><br>
<li>Now in your level editor, click on the green poision mushroom to open a dialog about Layer 3 GFX bypass. On LG1, set that
to use the graphic files. Level 105 and 106 LG1s to be slot 80, but for 104, it needs LG1 to be slot 81 and LG2 to be slot 82 to accommodate the large number of tiles. Then hit OK and save to apply the changes.<br><br>
</li>
</ol>
</li>
<li>Now you are done, although there are more example codes than provided here, given that you can play up to 3 levels from the get-go without beating them and without editing the overworld. If you want to test
thats not listed here, read the comments at the top in the ASM files. The examples follows:
<ul>
<li>Level 104 (Yoshi's house) is a double-bar, which can display two &ldquo;fills&rdquo; overlapping each other (<img width="96" src="readme_files/DoubleBarFills_AnotherColor.png">). Press and hold right, then
press and hold up to see. If you're using the Super Status Bar patch (and have modified the defines so that the code adopts to it), it will display 4 hex numbers at the top right, displaying the first column the amount and fill-percentage amount of FirstFill
and the other column for SecondFill.</li>
<li>Level 105 (Yoshi's island 1) is a progress meter, keep heading right to see it fills up.</li>
<li>Level 106 (Yoshi's island 2) is a coin meter, once 99 is reached, it should be full. It also avoids displaying 0% if if not 0 coins and 100% less than 99 coins,
a failsafe measure to avoid misleading value displays.</li>
<li>On the overworld border, measures Mario's Bonus Stars (does not measure Luigi's if 2-player mode).</li>
</ul>

If you're not using the Super Status Bar patch, the bar will be displayed over the word &ldquo;TIME&rdquo; and the coin symbol. The palette will be yellow on some areas,
but thats intentional as SMW's status bar is very limited.
</li>
</ol>
<hr>
<h2><a href="#OwnGraphicalBarBack" id="OwnGraphicalBar">^</a>Displaying your own value as a graphical bar (Uberasm tool, Layer 3)</h2>
Perhaps if you want to display something other than the provided examples above, here are the templates:

<ul>
<li>A simple graphical bar.
<div class="CodeBlock"><pre>incsrc "../GraphicalBarDefines/GraphicalBarDefines.asm"
incsrc "../GraphicalBarDefines/StatusBarSettings.asm"
;^These are needed so the defines relating to the graphical bars work.

main:		;&gt;You DO need this if using uberasm tool.
.InputRatio
	LDA <span style="color: red">$0DBF|!addr</span>						;\Quantity low byte (example: current HP). Use RAM here.
	STA !Scratchram_GraphicalBar_FillByteTbl		;/
	LDA <span style="color: red">#$00</span>						;\High byte of above. Should your value here is 8-bit or only 1 byte long,
	STA !Scratchram_GraphicalBar_FillByteTbl+1		;/use [LDA #$00 : STA !Scratchram_GraphicalBar_FillByteTbl+1].
	LDA <span style="color: red">#$63</span>						;\Max quantity low byte (example: max HP). Can be a fixed value (#$) or adjustable RAM in-game.
	STA !Scratchram_GraphicalBar_FillByteTbl+2		;/
	LDA <span style="color: red">#$00</span>						;\High byte of above, same format as &lt;Value_high_byte&gt;, so do the same
	STA !Scratchram_GraphicalBar_FillByteTbl+3		;/as that if your value is 8-bit.
.InputGraphicalBarAttributes
	LDA.b <span style="color: green">#!Default_LeftPieces</span>				;\Left end normally have 3 pieces.
	STA !Scratchram_GraphicalBar_LeftEndPiece		;/
	LDA.b <span style="color: green">#!Default_MiddlePieces</span>				;\Number of pieces in each middle byte/8x8 tile
	STA !Scratchram_GraphicalBar_MiddlePiece		;/
	LDA.b <span style="color: green">#!Default_RightPieces</span>				;\Right end
	STA !Scratchram_GraphicalBar_RightEndPiece		;/
	LDA.b <span style="color: green">#!Default_MiddleLength</span>				;\length (number of middle tiles)
	STA !Scratchram_GraphicalBar_TempLength			;/
.ConvertToBar
	JSL GraphicalBarELITE_CalculateGraphicalBarPercentage		;&gt;Get percentage
	<span style="color: orange">JSL GraphicalBarELITE_RoundAwayEmptyFull</span>
	JSL GraphicalBarELITE_DrawGraphicalBarSubtractionLoopEdition	;&gt;get bar values.
	STZ $00								;&gt;Use Level-layer3 tileset
	JSL GraphicalBarConvertToTile_ConvertBarFillAmountToTiles	;&gt;Convert tiles.
	LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Tile</span>				;\Setup address to where to draw the bar.
	STA $00								;|
	LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Tile>>8</span>			;|
	STA $01								;|
	LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Tile>>16</span>			;|
	STA $02								;/
	if !StatusBar_UsingCustomProperties != 0
		LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Properties</span>				;\Same as above but properties
		STA $03								;|
		LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Properties>>8</span>			;|
		STA $04								;|
		LDA.b <span style="color: yellow">#!Default_GraphicalBar_Pos_Properties>>16</span>			;|
		STA $05								;/
		if !Default_LeftwardsBar == 0
			LDA.b <span style="color: green">#!Default_StatusBar_TilePropertiesSetting</span>			;\Properties
		else
			LDA.b <span style="color: green">#(!Default_StatusBar_TilePropertiesSetting|(!Default_LeftwardsBar<<6))</span>
		endif
		STA $06								;/
	endif
	if !Default_LeftwardsBar == 0
		if !StatusBarFormat = $01
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUD			;&gt;Write to status bar
		else
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUDFormat2		;&gt;Write to status bar
		endif
	else
		if !StatusBarFormat = $01
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUDLeftwards
		else
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUDLeftwardsFormat2
		endif
	endif
	RTL
	</pre></div><br>
Font colored in <span style="color: red">red</span> is the things you change, while the <span style="color: green">green</span>, you edit values in the defines via opening up
<kbd>GraphicalBarDefines/StatusBarSettings.asm</kbd> and changing those, and yes, you can safely redefine them when you have multiple bars for advanced use. <span style="color: yellow">Yellow</span>
is the same as green, but it has to be a 3-byte (24-bit) address. <span style="color: orange">Orange</span> means you can remove the rounding away code if you want the bar to be able to round
towards empty or full. Of course, the <kbd>#</kbd> symbol means a fixed number instead of a RAM address.<br><br>

Also if you are handling 16-bit mode quantity while on 8-bit accumulator, you write the 16-bit number <kbd>#$1234</kbd> (a fixed value not stored in RAM) as
storing the <kbd>#$34</kbd> onto the low byte and <kbd>#$12</kbd> on the high byte (if it was RAM, it should be obvious, low byte written to low byte and high to high). Remember that
the SNES is <a href="https://en.wikipedia.org/wiki/Endianness">little-endian</a> when the number stored as bytes are adjacent from one another in memory.</li><br>

<li>Double Bar. Displays 2 fills like this: <img src="readme_files/GraphicalBarFillsAnimation.gif">, which is useful for displaying changes such as how much HP was lost. See
<a id="DoubleBar" href="readme_files/DoubleBarInfo.html">this information</a>. The colored fonts last mentioned above code also applies on codes here as well.</li>

</ul>
<hr>
<h2><a href="#CustomSprites_Back" id="CustomSprites">^</a>Drawing OAM (Normal sprites (SMW sprites or pixi), not cluster, extended, minor extended, etc.)</h2>
<p>While this code library was originally meant to be used with layer 3 status bar on uberasm tool, I added new features that would support sprite OAM.<p>

<p>Due to the limitation of pixi that you cannot have multiple subroutines in a single ASM file with sprites calling other than the first subroutine (call
via a subroutine label), they have to be seperated into multiple ASM files.</p>

<p>Also, for the sake of making it easier to find graphical bar-related routines in pixi's routines folder, I prepended their filenames with
&ldquo;<kbd>GraphicalBar</kbd>&rdquo; so that when sorted alphabetically, they are all together. (at the moment, all routine ASM files must be in the routines folder, not in any subdirectory).</p>

<p>Please note that while I did have pixi versions of graphical bar-related routines in <kbd>Pixi_CustomSprite/Pixi Routines</kbd>, I did not include all the subroutines:
<ul>
	<li>Mainly routines in <kbd>GraphicalBarConvertToTile</kbd>, such as <kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTiles</kbd>, this is because that would mean even more tiles are needed, and sprite tiles are very limited
	espically if you have other custom sprites in your hack (such as the Giant Masked Koopa Boss)</li>
</ul>
</p>
<p>To get started, you'll need pixi, obviously. I also strongly recommend using the &ldquo;No more sprite tile limits&rdquo; patch, as obviously you can easily run into tile limitations and also OAM tiles could be in front or behind
another when they shouldn't.

I recommend having the knowledge of how sprites work before doing this. Here is a <a href="https://www.smwcentral.net/?p=viewthread&t=92218">tutorial</a>.
<h3>Insertion process (test sprite)</h3>
<ol>
	<li>Defines: Same as uberasm tool, make sure you make necessary changes and have the up-to-date information (if you have multiple copies of this, they must all have the latest editions on it). Then have the <b>folder</b>
	<kbd>GraphicalBarDefines</kbd> in the main directory of pixi (where the <kbd>.exe</kbd> program is at).</li>
	<li>
		Sprite insertion: In, <kbd>Pixi_CustomSprite</kbd>, choose a folder of which sprite you want to test, copy the <b>asm</b> and <b>json</b> or <b>cfg</b> file they contain (don't copy the folder itself), and paste them directly in pixi's sprites folder.
	</li>
	<li>
		Routines insertion: Obviously you should find <kbd>Pixi Routines</kbd> folder, open that, copy all the ASM files (not the folder itself), and paste that in pixi's <kbd>routines</kbd> folder.
	</li>
	<li>
		Tile table modification of <kbd>GraphicalBarConvertBarFillAmountToTiles.asm</kbd>: Because the sprites had to have a different tile numbers for the graphical bar tiles, they have to have different fill&rightarrow;TileNumber conversions.
		By default, it uses &ldquo;<kbd>3/8/3 LevelSprite SpriteGraphicalBarTest Layout</kbd>&rdquo; for both <kbd>SpriteGraphicalBarTest.asm</kbd> and <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd>. The included graphics for pixi sprites are located in <kbd>ExGraphics</kbd> folder (see <a href="readme_files/JS_GraphicsNotes.html" target="_blank"><kbd>readme_files/JS_GraphicsNotes.html</kbd></a>
		on where/how the graphics should be inserted, in this case, it should be <kbd>ExGFXA2</kbd> or <kbd>ExGFXA3</kbd>), copy the table, then open <kbd>GraphicalBarConvertBarFillAmountToTiles.asm</kbd> in pixi's routines, and replace the sprite tile table with what you copied.
	</li>
	<li>
		Now open or create <kbd>list.txt</kbd>, and have the following text written (for sprites you didn't pasted in the sprites folder, remove them off the list):
<div class="CodeBlock" style="width: 220px; height: 62px;"><pre>00 SpriteGraphicalBarTest.json
01 giant_masked_koopa.cfg
02 masked_koopa_fireball.cfg
03 masked_koopa_rock.cfg</pre></div>
		And now save. If you have the fireball and rock sprite at a different sprite ID number, you have to edit <kbd>giant_masked_koopa.asm</kbd>'s defines to spawn the correct sprite.
	</li>
	<li>Now run pixi.exe to insert.</li>
	<li>
		Go to <kbd>ExGraphics</kbd> and choose either:
		<ul>
			<li>Both <kbd>ExGFXA0</kbd> and <kbd>ExGFXA1</kbd>: For Giant Masked Koopa.</li>
			<li><kbd>ExGFXA2</kbd> or <kbd>ExGFXA3</kbd>: For SpriteGraphicalBarTest.</li>
		</ul>
		
		...depending on what sprite you want to test. copy one of those files
		(it depends if you want a horizontal bar or a vertical bar, but the GMK boss only supports horizontal), paste it in your ExGraphics folder. If you do not have them, press &ldquo;Quick Extract ExGFX from ROM&rdquo;, which is the blue
		mushroom to make the Exgraphics folder appear.
	</li>
	</li>
	<li>And you are done. If you are planning to use this code within the custom sprite's code, continue doing the steps below.</li>
</ol>
<p><kbd>SpriteGraphicalBarTest.asm</kbd> will show a 16x16 egg sprite (or some other 16x16 tile depending on your graphic settings), along with the bar graphic. The 16x16 tile is meant to show the origin position
of the sprite and how the bar is position in relation to it.</p>

<p>The GMK boss is an example boss sprite that draws a HP bar underneith it.</p>

<h3><a href="#ProgrammingOtherCustomSprites_back" id="ProgrammingOtherCustomSprites">^</a>Programming with existing custom sprites</h3>
<p>Note: You must have some mid-level of knowledge of ASM, as here you must learn how to:
<ul>
<li>Know which scratch RAM is currently used for other purpose during code execution, and be able to relocate them to another RAM should they conflict (2+ different data using the same address(es)) or use
the stack (PHA...PLA)</li><br>
<li>Finding an appropriate place or rearranging to insert the code, due to certain values like indexes and scratch RAM are still being used for a specified purpose (for example: if scratch RAM is used for indirect addressing to write an array of sprite tiles,
we don't want to put our code there, instead we place it at a location that is <i>before</i> (or <i>after</i>, depending on the code structure of the sprite) scratch RAM becomes reserved for addressing).</li><br>
<li>Preserve sprite index (usually on the X index register), often by doing push/pull them (like <kbd>PHX</kbd> (before X is being used for something else)...<kbd>PLX</kbd> (after done using X for something else)) them (or just <kbd>LDX $15E9|!addr</kbd> after done using X for something else), as many stuff and subroutines (including ones here) uses the X register for other things.</li><br>
</ul>
Many sprites on the sprite section on SMWC can be complex and have different coding structures, but following the principals above should make it possible to implement on any sprite.<br>
Another important note is that the routine <kbd>%GetDrawInfo()</kbd> uses &ldquo;<span style="font-weight: bold;">destructive return</span>&rdquo;-- A stack-manipulation technique to exit multiple subroutines at once upon returning (RTS/RTL), consider this simple example shown below:
<div class="CodeBlock" style="height: 480px; width: 1069px;"><pre>	JSR Subroutine
	STZ $00
	RTL
	
	Subroutine:
	JSR InnerSubroutine		
	NOP		;\Just for demonstration purposes, it does nothing.
	NOP		;|These will not be executed
	NOP		;/
	RTS
	
	InnerSubroutine:
	PLA		;\Pull 2 bytes out (the amount of bytes pushed when JSR'ing)
	PLA		;/This destroys the return address to where the 3 NOPs are at in the stack.
	RTS		;&gt;Upon executing this, instead of going to where the 3 NOPs are at, it goes to the STZ $00 after "JSR Subroutine".
	
	;What it executes, it performs in this order:
	;[] = a byte in memory
	;[--] = other stuff in the stack or potentially garbage
	;[SS] = Return address location after JSR Subroutine
	;[II] = Return address location after JSR InnerSubroutine
	;(1) JSR Subroutine		;&gt;stack: [--][--][--][--][SS][SS]
	;(2) JSR InnerSubroutine	;&gt;stack: [--][--][II][II][SS][SS]
	;(3) PLA			;\stack: [--][--][--][--][SS][SS] (we destroyed [II][II])
	;(4) PLA			;/
	;(5) RTS			;&gt;stack: [--][--][--][--][--][--] (jumps to after "JSR Subroutine" ([SS][SS]))
	;(6) STZ $00
	;(7) RTL
	;JSR pushes 2 bytes of address into the stack (more specifically, the next instruction's location, minus 1 into the stack)
	;RTS pulls 2 bytes of address out of the stack (specifically, the location address in the stack. Takes that, add 1, and sets the program counter to jump there)
	;The same applies to JSL and RTL, but 3 bytes instead.</pre></div>
Therefore, if you push something, you must pull before calling <kbd>%GetDrawInfo()</kbd> (or any subroutines using this technique) as the game will crash. For <kbd>%GetDrawInfo()</kbd>, doing the same will crash upon the sprite going offscreen (it doubles-out if the sprite goes offscreen, else it keeps the return address). Normally, you can
push stuff (such as scratch RAM), call a subroutine, then pull stuff (often to restore values such as scratch RAM), but this is an exception to the rule.
</p>
<ol>
	<li>Go to the graphics portion of the code (thankfully, they are conveniently named and 99.99% of the time use <kbd>%GetDrawInfo()</kbd>). You want to know these informations
		<ul>
			<li>The total number of tiles it uses. Before calling the &ldquo;finish OAM write&rdquo; (done by calling <kbd>JSL $01B7B3</kbd> or <kbd>%FinishOAMWrite()</kbd>), you'll need
			to find out the total number of tiles, including the bar itself, and subtract by 1. A common method, is by taking the number of tiles on the sprite's body, minus 1, and then
			add by number of tiles of the bar, without the minus 1 on that itself (<kbd>(SpriteBodyTileCount - 1) + BarTileCount</kbd>), Another method to do so is by getting the total
			(sprite's body + graphical bar) first, and then subtract by 1, and avoid subtracting
			by 1 again for the graphical bar (you'll subtract by 2 which isn't what you want) therefore resulting <kbd>(SpriteBodyTileCount + BarTileCount) - 1</kbd>.</li><br>
			
			<li>The tile sizes. Most sprites on SMWC are composed of 16x16 tiles, so you'll likely need to manually set the tile size</li><br>
		</ul>
	</li>
	<li>If you happen to want a graphical bar on a sprite that is composed of at least 1 16x16 OAM tile (most sprites are like that, by the way), you'll have to
	manually handle the size of editing <kbd>$0460</kbd> in the sprite code (a mixture of 8x8s and 16x16, like the timed lift sprite (the platform itself is 2 16x16s and the number graphic in the center is a single 8x8.)):
<div class="CodeBlock" style="height: 336px; width: 949px;"><pre>;Manually set sprite tile size to 16x16 (this is for the main body of the sprite).

;Note: This may different depending on the sprite being used, for example, the Giant
;Masked Koopa Boss uses the X as the OAM index instead of Y because of indirect
;addressing opcode limitations (There is no [&lt;Opcode&gt; ($xx),x], and Y is
;used for its image state).

	PHY			;&gt;Push OAM index (You'll need this if you are still using the Y OAM index afterwards, especially if you are writing multiple tiles via a loop).
	TYA			;\Convert index to OAM slot numbering
	LSR #2			;|
	TAY 			;/
	LDA $0460|!addr,y	;\Manually set the size bit to 16x16
	ORA.b #%00000010	;|
	STA $0460|!addr,y	;/
	PLY			;&gt;Restore OAM index
	;[...]
;Finish OAM write:
	LDY #$FF		;&gt;The graphical bar tiles are always 8x8, but the sprite's body isn't always 8x8 or 16x16. Y=$FF means mixture
	;A = total number of tiles to write, -1
	&lt;instruction to get the number of tiles, minus 1, into the A register&gt;
	&lt;Either call using JSL $01B7B3, or use %FinishOAMWrite().&gt;</pre></div>
	</li>
</ol><br></p>

<p>The GMK boss that I edited, is <a href="readme_files/GMKBossSummary.html" id="GMKBossSummary_Back">explained here</a> as an example.</p>

<p>Everything is effectively the same as <kbd>GraphicalBarSimpleTest</kbd> except the bar having an actual purpose and the sprite is a boss sprite. Open the ASM file <kbd>giant_masked_koopa.asm</kbd>, and there will be comments I added to show an example
on how to implement a sprite graphical bar (in this example, a HP bar).</p>

<p>Because the boss sprite takes a considerable amount of 8x8 tiles, it uses the <kbd>ConvertBarFillAmountToTilesIndirectAddressTable</kbd> routine to avoid tile conflicts.</p>
<hr>
<h2><a href="#DrawOamPatch_Back" id="DrawOamPatch">^</a>Drawing OAM (not using sprite slots, but patch using OAM).</h2>
<p>This is similar to the sprite version, but written using a patch. Using a hijack at <kbd>$00A2E6</kbd> and running the patch's OAM handler AFTER processing all sprites (including after $028AB1), gives
the benefit of tile priority so that no other sprite will overlap the bar (OAM is handled so that the lower indexes have higher priority and is rendered in front of the higher-indexed OAM slots).</p>
What you need is Asar, a patching tool.
To install:
<ol>
	<li>ASM:
		<ol>
			<li>Again and again with the defines, make necessary changes to it, and make sure it is up to date</li>
			<li>Simply patch <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd> to your game. Please note that this ASM file refers to the defines and routines folder on the main directory of this pack, so don't move or rename
			the files it is referring to. Just use asar on this file directly.</li>
			<li>Make sure the tile table to convert from fill amounts to tiles are <kbd>3/8/3 LevelLayer3</kbd>, it is that by default.</li>
		</ol>
	</li>
	<li>Graphics:
		<ol>
			<li>Insert the graphics, use this one: <kbd>ExGFXA2</kbd>, not the GMK boss.</li>
		</ol>
	</li>
	<li>And you are done. Feel free to take a look at the contents of <kbd>DrawOamPatch.asm</kbd> to learn how it works. Most of the codes are the same as the layer 3 version, but writes to OAM instead.</li>
</ol><br>

You can uninstall it by simply opening <kbd>GraphicalBarDefines/SpriteOAMSettings.asm</kbd>, and set <kbd>!PatchSprite_Uninstall</kbd> to <kbd>1</kbd>, and then re-apply the patch.<br><br>

As a side note, this ASM resource was made before UberASM Tool v2.0 (released on SMWC on 2024-08-02). That means you no longer need the patch, but have its main code as <kbd>level</kbd> under <kbd>end:</kbd> label. I already provided a modified version
in <kbd>UberasmTool_ExampleUsage/Level_Simple_EndOAM.asm</kbd>.
<hr>
<h2><a href="#AsmDocumentationBack" id="AsmDocumentation">^</a>ASM Documentation</h2>
Notes: 
<ul>
	<li>All number values here are unsigned (negative numbers don't exists).</li>
	<li>
		<kbd>MiddleLength</kbd> is equal to a value stored in RAM defined as <kbd>!Scratchram_GraphicalBar_TempLength</kbd>, which is the number of middle tiles. However, if that <b>and/or</b> the number of pieces in each middle tile were to be
		set to <kbd>$00</kbd>, then <kbd>MiddleLength</kbd> would be zero.
	</li>
</ul>
Routine information follows:
<ol>
<li><a href="#GraphicalBarELITEBack" id="GraphicalBarELITE">^</a>Inside <kbd>GraphicalBarELITE.asm</kbd></li>
<ul>
<li><a href="#CalculateGraphicalBarPercentage_Back" id="CalculateGraphicalBarPercentage">^</a><kbd>CalculateGraphicalBarPercentage</kbd>, <kbd>CalculateGraphicalBarPercentageRoundDown</kbd>, and <kbd>CalculateGraphicalBarPercentageRoundUp</kbd>: Calculates the ratio of <kbd>Quantity/MaxQuantity</kbd> to convert to X over the number of pieces (the whole bar).
For example: 50/100 on a 62-pieced bar outputs value of 31.</li>
<table>
<tr>
<th>RAM input</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl</span></span></kbd> to
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl+1</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">2</td>
<td>The number (16-bit unsigned) or amount of something out of the maximum (known as the &ldquo;<kbd>Quantity</kbd>&rdquo;).</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl+2</span></span></kbd> to
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl+3</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">2</td>
<td>The maximum amount (16-bit unsigned) something (known as &ldquo;<kbd>MaxQuantity</kbd>&rdquo;).</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_LeftEndPiece</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td rowspan="4">Graphical bar attributes. The ones with the word &ldquo;piece&rdquo; refer to the number of pieces
or units in their respective byte or 8x8 tile. When 0, they are not included in the table. <kbd>!Scratchram_GraphicalBar_TempLength</kbd>
is the number of repeated middle tile bytes between the left and right end tile bytes.<br><br>

The reason why the pieces setup is RAM-based is so you can have different number of pieces in any bar part (left, middle, and right), for example,
<a href="readme_files/LeftEndMorePieces.png" target="_blank"> 6 pieces for left end</a> along with 3 in the same routine. However, you have to have
both tables in the tile converter in <kbd>GraphicalBarConvertToTile.asm</kbd> to avoid glitched tiles.</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_MiddlePiece</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_RightEndPiece</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_TempLength</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
</table>
Result:
<table>
<tr>
<th>Output</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$01</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">2</td>
<td>The amount of fill as a &ldquo;percentage&rdquo; (known as &ldquo;<kbd>FillAmount</kbd>&rdquo;). Calculated by:<br><br><kbd>FillAmount = Round(Quantity * TotalNumberOfPiecesInBar / MaxQuantity)</kbd><br><br>The <kbd>Round</kbd> function
<a href="https://en.wikipedia.org/wiki/Rounding">rounds</a> the number to an integer, depending on the 3 variations of these subroutines:
<ul>
	<li><kbd>CalculateGraphicalBarPercentage</kbd>: Round half up, during division, if the remainder is less than half the divisor, would round down to nearest integer, otherwise if greater than or equal to, rounds up to nearest integer.</li>
	<li><kbd>CalculateGraphicalBarPercentageRoundUp</kbd>: Round up (ceiling). After division, if the remainder is any nonzero value, rounds up to nearest integer.</li>
	<li><kbd>CalculateGraphicalBarPercentageRoundDown</kbd>: Always round down (floor), regardless of remainder.</li>
</ul><br>
These rounding variations are intended to minimize/control bias when used in conjunction with <a href="#TOCRoundAwayFromComplete"><kbd>RoundAwayEmpty</kbd>, <kbd>RoundAwayEmpty</kbd>, or <kbd>RoundAwayEmptyFull</kbd></a>.
The bias is caused by when a quantity value are within a range that would round to 0 or max, then gets merged with the range that would round to 1 or max-1.
<br><br>
If max quantity is 0, a division by zero occurs, and outputs <kbd>$FFFF</kbd>. If you are familiar with what that is, that is <a href="https://en.wikipedia.org/wiki/Cross-multiplication">cross-multiplying</a> to convert fractions.<br><br>

Because we are dealing with integer values and rounding after division, if you have more MaxQuantity than MaxFill, then several quantity values may result in the same number of pieces filled. See <a href="readme_files/JS_GraphicalBar_PercentageRoundQuantityRanges.html" id="CalculateGraphicalBarPercentage_Discription">this</a> to view the distribution of values to each fill amount<br><br>

Note that this is not capped at total pieces in the bar, meaning that if <kbd>Quantity</kbd> is greater than <kbd>MaxQuantity</kbd>, this routine may output the number of pieces in the bar greater than its maximum, although <kbd>DrawGraphicalBar</kbd> and
<kbd>DrawGraphicalBarSubtractionLoopEdition</kbd> will treat it as capped.<br><br>

As a side note to most programmers, yes, I could alternatively perform <kbd>FillAmount = (Quantity / MaxQuantity) * TotalNumberOfPiecesInBar</kbd>, but we are dealing with integers, not floating points. Performing that
causes problem where the value could output only 0 or any number that is a multiple of n pieces in the bar (will display 0% or 100% but not in between when displayed) due to division rounding the quotient to the nearest
integer, which the error is between 0 and 1, before multiplying by <kbd>TotalNumberOfPiecesInBar</kbd> and scaling that error by an enormous amount:
<div class="CodeBlock"><pre>1 out of 3 HP = 20 and 2/3, or 20.[6] out of 62 pieces (bracket means repeating digits).

The correct way (multiply-first): (1 * 62) / 3

	1 * 62 = 62, multiplying 2 integers always results in the correct number assuming no overflows. However
	since the multiplication routine used here is 16-bit * 16-bit = 32-bit, overflows are not possible, because
	65,535 * 65,535 = 4,294,836,225 and the maximum unsigned 32-bit integer is 4,294,967,295. which means the maximum
	product would be under the maximum unsigned 32-bit integer (131,070 away from the 32-bit max).
	
	62 / 3 = 20.[6] the routine would've round this number to 20 or 21, making the error tiny off by 0.[6] or 0.[3].
	The amount off will always be less than 1.

The incorrect way (divide first): (1 / 3) * 62

	1/3 = 0.[3], the routine would've round this number to 0 or 1, making the error 0.[3] or 0.[6]
	
	If rounded to 0, then 0 * 62 = 0, the calculation is off by 20.[6] units, otherwise if rounded to 1, then
	1 * 62 = 62, which is off by 41.[3] units. Both of these causes the fill amount to always be in multiples of
	TotalNumberOfPiecesInBar.
</pre></div>
Therefore it's best to perform calculations in a way that rounding to only be applied on the final operator (in this case, integer division), when possible.
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">Y register</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">1 (not stored)</td>
<td>Rounding towards empty and full indicator:
<ul>
<li><kbd>Y = $00</kbd> if not rounded to empty or full (if exact empty, rounded to any number besides 0 or maximum, or full (or higher))</li>
<li><kbd>Y = $01</kbd> if rounded to empty.</li>
<li><kbd>Y = $02</kbd> if rounded to full.</li>
See more information <a id="RoundAwayFromComplete" href="readme_files/RoundAwayFromComplete.html">here</a>.
</ul></td>
</tr>
</table>
Destroyed:
<table>
<tr><th>Destroyed</th><th>Number of Bytes</th><th>Description</th></tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$02</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$09</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">8</td>
<td>Overwritten by math routines. Contains garbage values.</td>
</tr>
</table>

<li><a href="#DrawGraphicalBar_Back" id="DrawGraphicalBar">^</a><kbd>DrawGraphicalBar</kbd> (depreciated and commented out, recommended to use
<kbd><a href="#DrawGraphicalBarSubtractionLoopEdition">DrawGraphicalBarSubtractionLoopEdition</a></kbd> instead): it takes a value representing how much fill in the entire bar,
and divides them into a byte-array of numbers that are addends of the fill amount, in this order: N (can be zero) bytes being at their set maximums, 0 or 1 fraction byte (no
fraction if bar is full), and then N bytes (can be zero) empty, while keeping the order of their maximums (3, 8, 8, 8, 8...), stored in a RAM defined <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd>:<br>
<img src="readme_files/FillAmountDividedUnevenlyToTileBytes.png"><br><br>

The reason for this being treated as segmented parts is because the SNES' graphics are all tile-based, (most modern games rely on texture-based rendering
often drawing polygons that get the width of the fill region, or simply have one number representing a fill for the entire bar) so we have to deal with them tile-by-tile.<br><br>

<table>
<tr>
<th>Input</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$01</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">2</td>
<td>The amount of fill in the bar, as in, the total number of pieces filled.<br><br>

The total number of pieces (full amount) in the bar is calculated as: <kbd>[FullAmount = LeftEndPiece + (MiddlePiece * MiddleLength) + RightEndPiece]</kbd>,
for example: 62 = 3 + (7 * 8) + 3</td>
</tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Graphical bar attributes, same as <kbd>CalculateGraphicalBarPercentage</kbd></td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table>
Result:
<table>
<tr>
<th>Output</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl + ((<abbr title="0 if no left end, 1 if set to any nonzero number of pieces">LeftEnd</abbr> +
<abbr title="Equals to !Scratchram_GraphicalBar_TempLength if middle pieces is nonzero, 0 otherwise">MiddleLength</abbr> + <abbr title="0 if no right end, 1 if set to any nonzero number of pieces">RightEnd</abbr>) - 1)</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td>
<td>
The table containing N &ge; 0 bytes ordered from full, then zero or one byte containing a fraction (fill amount ranges from <kbd>0</kbd> to <kbd>max-1</kbd>), then  N &ge; 0 empty bytes.
If the bar's fill amount be greater than maximum (say, 63 out of 62 pieces), the values stored in this table will act as if the bar is full and does not write additional bytes.<br><br>

Number of bytes taken is <kbd>LeftEnd + Middle + RightEnd</kbd> where LeftEnd and RightEnd equals to 1 when set to nonzero number of pieces or 0 otherwise, and middle is equal to <kbd>!Scratchram_GraphicalBar_TempLength</kbd>
if MiddlePieces (number of pieces in each middle tile) is nonzero, otherwise it is 0. The JavaScript file linked previously will show how many bytes and memory address range it will occupy.<br><br>

Because the SNES screen is 32 8x8 tiles wide, there is no need to have a bar more than 32 tiles wide (the bar will extend past the border of the screen).

If you are using &ldquo;DoubleBar&rdquo;, it is the duplicate table of above, just located
nth bytes after depending on what you set <span class="NoLineBreak"><kbd>!Setting_GraphicalBar_SecondFillByteTableOffset</kbd></span>.
See <a href="readme_files/DoubleBarInfo.html#SecondTable" target="_blank">this information</a> for what I mean.
</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">$08</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$09</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">2</td>
<td>
The amount of fill that was <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$01</span></span></kbd> was originally before calling this routine, the value is not
capped, so inputting a number 63 when there are 62 pieces will have this RAM address storing the value 63. Can be used on such things like &ldquo;multi-bars&rdquo; that multiple bars are shown, and the
fills advances to the next bar: <img src="readme_files/MultiBar.gif">
</td>
</tr>
</table><br>

<table>
<th>Destroyed</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$07</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;">8</td>
<td>
Garbage:
<ul>
<li><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$01</span></span></kbd>:</li>
<ul>
<li>If the right end exist without regards of the middle and left end, will contain the right end amount.</li>
<li>#$00 if right end does not exist and middle exist.</li>
<li>If the left end only exist and middle and right are not, contains the left end amount.</li>
</ul>

<li><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$02</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$07</span></span></kbd>: Needed to move the values to another
address due to subroutines as well as outputs of the subroutines.</li>
</ul>
</td>
</tr>
</table>

Here are the formulas on how each are calculated:<br><br>

<ul>
<li>Left end:</li>
<ul>
<kbd>LeftEndFill = clamp(TotalFilled, 0, LeftEndMax)</kbd>
</ul>
<li>Middle:</li>
<ul>
<li><kbd>TotalMiddleMax = MiddleLength * MiddleMaxEachTile</kbd> (total number of pieces in the middle part of the bar)</li>
<li><kbd>MiddleFill = clamp((TotalFilled - LeftEndMax), 0, TotalMiddleMax)</kbd> (excluding the left end, how many pieces filled in the whole middle)</li>
<li><kbd>NumberOfFullMiddleTiles = clamp(floor(MiddleFill/MiddleMaxEachTile), 0, MiddleLength)</kbd> (<a href="https://en.wikipedia.org/wiki/Euclidean_division">euclidean division</a>)</li>
<li><kbd>MiddleFractionFill = MiddleFill MOD MiddleMaxEachTile</kbd> (euclidean division), placed just after the last full middle tile or
on the first middle tile if there are no full middle tiles, if the entire middle tiles is full, fraction is not written at all.</li>
</ul>
<li>Right end:</li>
<ul>
<li><kbd>RightEndFill = clamp((TotalFilled - (LeftEndMax + TotalMiddleMax)), 0, RightEndMax)</kbd></li>
</ul><br><br>
<li>functions explanation:</li>
<ul>
<li><kbd>clamp(x, min, max)</kbd> returns x in between <kbd>min</kbd> and <kbd>max</kbd>, but returns <kbd>min</kbd> if at or below that number and <kbd>max</kbd> if at or above that number</li>
<li><kbd>floor(x)</kbd> returns the highest integer that is &le; x. Essentially this round down an integer (7/8 = 0.875 &rarr; 0, 9/8 = 1.125 &rarr; 1).</li>
</ul>
</ul><br>
Another version of <kbd>DrawGraphicalBar</kbd>, <a href="#DrawGraphicalBarSubtractionLoopEdition"><kbd>DrawGraphicalBarSubtractionLoopEdition</kbd></a> does the same thing, but is more optimized and functions slightly differently.</p>

The inputs are similar to the previously mentioned routine (such as requiring the attributes), but you don't write to <span class="NoLineBreak"><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd></span> to
<span class="NoLineBreak"><kbd>!Scratchram_GraphicalBar_FillByteTbl+3</kbd></span>, as it is no longer needed. Just to keep in mind, the attributes are kept after running this routine, so you don't have to rewrite them again.
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$01</span></span></kbd> is the number of units (or pieces) filled as the input. It is important to note that this output table isn't tile numbers but rather
<i>fill amounts</i>, to be indexed into tile numbers (to allow different tile graphic locations for the same routine (such as different format on the overworld compared to level)). The only different
input here is <kbd>$00</kbd>:<br><br>

This is what it looks like as an example:
<ul>
<li><span style="color: cyan">Cyan</span> means the left end tile byte.</li>
<li><span style="color: #00C000">Green</span> means the middle tile byte(s).</li>
<li><span style="color: red">Red</span> means right end tile byte.</li>
<li><span style="color: orange">Orange </span> means the tile byte is full or reaches maximum.</li>
<li><span style="color: yellow">Yellow</span> means the tile byte is between 0 to max-1 inclusively (known as a fraction tile).</li>
<li><span style="color: grey">Grey</span> means the tile byte is empty.</li><br>
</ul>
<table>
<tr>
<td>
<pre>;These three are what sets the maximum fill values for the byte table.
 <span style="color: cyan">!Scratchram_GraphicalBar_LeftEndPiece:      $03</span>
 <span style="color: #00C000">!Scratchram_GraphicalBar_MiddlePiece:       $08</span>
 <span style="color: red">!Scratchram_GraphicalBar_RightEndPiece:     $03</span>
;This is how long the middle section.
 <span style="color: #00C000">!Scratchram_GraphicalBar_TempLength:        $07</span>
;The number of units or pieces filled:
 RAM address $00-$01:                        $0017 (23)</pre>
</td>
<td>


<pre>ASCII art depicting the byte table and how each byte correlates to the table.

                                     Table: <span style="background-color: orange">$03</span>,<span style="background-color: orange">$08</span>,<span style="background-color: orange">$08</span>,<span style="background-color: yellow"><span style="color: black">$04</span></span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>
                                             |   |   |   |   |   |   |   |   |
<span style="color: cyan">!Scratchram_GraphicalBar_FillByteTbl+0</span> ------/   |   |   |   |   |   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+1</span> ----------/   |   |   |   |   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+2</span> --------------/   |   |   |   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+3</span> ------------------/   |   |   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+4</span> ----------------------/   |   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+5</span> --------------------------/   |   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+6</span> ------------------------------/   |   |
<span style="color: #00C000">!Scratchram_GraphicalBar_FillByteTbl+7</span> ----------------------------------/   |
<span style="color: red">!Scratchram_GraphicalBar_FillByteTbl+8</span> --------------------------------------/
</pre><br>
Note: define <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> is an address, thus the above math (note the <kbd>+x</kbd>) means you add the value of the address (not the value stored in)
to get the relative location (so if <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> is being defined as <kbd>$7F844A</kbd> and you have <kbd>!Scratchram_GraphicalBar_FillByteTbl+1</kbd>,
that is <kbd>$7F844A + 1</kbd> which is address <kbd>$7F844B</kbd>).
</td>
</tr>
</table><br>

If any maximum was set to $00, they are excluded from the table and are skipped (all bytes with a nonzero maximum should not have a gap of unused bytes in between in any of them):
<table>
<tr>
<td>
<pre>
<span style="color: cyan"><s>!Scratchram_GraphicalBar_LeftEndPiece:       $00</s></span>
<span style="color: #00C000">!Scratchram_GraphicalBar_MiddlePiece:        $08</span>
<span style="color: red">!Scratchram_GraphicalBar_RightEndPiece:      $03</span>
<span style="color: #00C000">!Scratchram_GraphicalBar_TempLength:         $07</span>
RAM address $00-$01:                         $0017 (23)</pre>
</td>
<td>

<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address (index):</td>
<td style="background-color: #00C000"><kbd>+0</kbd></td>
<td style="background-color: #00C000"><kbd>+1</kbd></td>
<td style="background-color: #00C000"><kbd>+2</kbd></td>
<td style="background-color: #00C000"><kbd>+3</kbd></td>
<td style="background-color: #00C000"><kbd>+4</kbd></td>
<td style="background-color: #00C000"><kbd>+5</kbd></td>
<td style="background-color: #00C000"><kbd>+6</kbd></td>
<td style="background-color: red"><kbd>+7</kbd></td>
<td><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values:</td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: yellow"><span style="color: black"><kbd>$07</kbd></span></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td><kbd>(unused, garbage)</kbd></td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<pre>
<span style="color: cyan">!Scratchram_GraphicalBar_LeftEndPiece:       $03</span>
<span style="color: #00C000"><s>!Scratchram_GraphicalBar_MiddlePiece:        $00</s></span>
<span style="color: red">!Scratchram_GraphicalBar_RightEndPiece:      $03</span>
<span style="color: #00C000"><s>!Scratchram_GraphicalBar_TempLength:         $00</s></span>
RAM address $00-$01:                         $0004 (4)

Note: !Scratchram_GraphicalBar_MiddlePiece <u>and/or</u>
!Scratchram_GraphicalBar_TempLength to be set to zero,
will excludes the entire middle section.</pre>
</td>
<td>

<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address (index):</td>
<td style="background-color: cyan"><span style="color: black"><kbd>+0</kbd></span></td>
<td style="background-color: red"><kbd>+1</kbd></td>
<td><kbd>+2</kbd></td>
<td><kbd>+3</kbd></td>
<td><kbd>+4</kbd></td>
<td><kbd>+5</kbd></td>
<td><kbd>+6</kbd></td>
<td><kbd>+7</kbd></td>
<td><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values:</td>
<td style="background-color: orange"><kbd>$03</kbd></td>
<td style="background-color: yellow"><span style="color: black"><kbd>$01</kbd></span></td>
<td colspan="7"><kbd>(unused, garbage)</kbd></td>
</tr>
</table>
</td>
<tr>
<td>
<pre><span style="color: cyan">!Scratchram_GraphicalBar_LeftEndPiece:       $03</span>
<span style="color: #00C000">!Scratchram_GraphicalBar_MiddlePiece:        $08</span>
<span style="color: red"><s>!Scratchram_GraphicalBar_RightEndPiece:      $00</s></span>
<span style="color: #00C000">!Scratchram_GraphicalBar_TempLength:         $07</span>
RAM address $00-$01:                         $0017 (23)</pre>
</td>
<td>

<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address (index):</td>
<td style="background-color: cyan"><span style="color: black"><kbd>+0</kbd></span></td>
<td style="background-color: #00C000"><kbd>+1</kbd></td>
<td style="background-color: #00C000"><kbd>+2</kbd></td>
<td style="background-color: #00C000"><kbd>+3</kbd></td>
<td style="background-color: #00C000"><kbd>+4</kbd></td>
<td style="background-color: #00C000"><kbd>+5</kbd></td>
<td style="background-color: #00C000"><kbd>+6</kbd></td>
<td style="background-color: #00C000"><kbd>+7</kbd></td>
<td><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values:</td>
<td style="background-color: orange"><kbd>$03</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: yellow"><span style="color: black"><kbd>$04</kbd></span></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td><kbd>(unused, garbage)</kbd></td>
</tr>
</table>
</td>
</tr>
</tr>
</table><br>

<span id="StaticEndTiles"></span>Because of this, it also means that the <a href="#ConvertFillToTile"><kbd>FillAmount &rightarrow; TileNumber</kbd></a> and <a href="#StatusBarWrite"><kbd>tile write</kbd></a> routine themselves <span style="font-weight: bold;">will not write static
tiles as end tiles</span>. Static end tiles are unchanging tiles that only serve to draw a border graphic at the ends of the bar (which is useful to avoid cutoff at those ends without needing a border for <i>every</i> tile which gives it a segmented look),
here is what I mean as an example:<br>
<img src="readme_files/StaticEndTiles.png"><br>
You have to manually write the tiles at either side of the bar yourself:
<div class="CodeBlock" style="width: 539px; height: 185px;"><pre>	LDA #&lt;LeftEndTileNumber&gt;
	STA &lt;LeftEndTilePosition&gt;
	LDA #&lt;LeftEndTileProps&gt;
	STA &lt;LeftEndTilePropsPosition&gt;

	LDA #&lt;RightEndTileNumber&gt;
	STA &lt;RightEndTilePosition&gt;
	LDA #&lt;RightEndTileProps&gt;
	STA &lt;RightEndTilePropsPosition&gt;
	
	;Remove any line with the words &ldquo;props&rdquo; if the status bar
	;you're working on does not allow modifying the tile properties.
</pre></div>
If you have variable-length bar, I've <a href="#StaticEndRoutine">provided routines</a> that would automatically calculate where to write the static end tiles. Also note that this readme
assumes you never used static end tiles, most of the info provided about status bar write ranges only include the tiles affected based on fill amount, not static end tiles.
<br><br>

Of course, I made a <a id="ComputeGraphicalBarData" href="readme_files/JS_GraphicalBarCalculator3.html">javascript code page</a> that calculates memory statistics
without the need of manually calculating the values.</li><br>

<li><a href="#DrawGraphicalBarSubtractionLoopEdition_Back" id="DrawGraphicalBarSubtractionLoopEdition">^</a><kbd>DrawGraphicalBarSubtractionLoopEdition</kbd> An alternative routine to <kbd>DrawGraphicalBar</kbd>,
it does the same thing, but slightly different. Instead of using any form of division, it simply uses repeated subtraction, and in fact, does not use any other subroutines (this is a standalone). Almost all the inputs and outputs the
same, except that the output <kbd>$00-$01</kbd> acts as the remaining fill when the bar is full or higher and 0 otherwise (<kbd>RemainingFill = <abbr title="Picks what number in the parameter is the highest value. If the fill amount is less than 0, it results things like max(-5, 0) which returns 0 and not -5">max</abbr>((InputFillAmount - BarMaximumFull), 0)</kbd>), while <kbd>$02-$09</kbd> aren't destroyed.<br>

<p>It works like this: subtract the input fill amount by the tile byte maximum starting at the first byte going towards the last byte, if the subtraction was successful (having enough filled pieces to be full; subtracted without going in the negatives), then write
the maximum amount to the byte in the table and write the difference back to the remaining fill amount, otherwise (if it fails, having less than maximum) it would write that remaining fill amount into the byte in the table and
set the remaining fill amount to 0 (takes all the rest if less). After this, this then repeats (the remaining fill amount gets subtracted towards 0) until all tile bytes are finished.<br><br>

As an analogy, there are N empty cups, arranged in a row, and starting at the first cup, you fill that cup with water until it's full, or until you run out of water, and then you repeat the process on the next
cup finishing once you reached the last one. The only difference is that the bytes' value are <i>not</i> added by the fill amount, rather <i>set</i> to as it would be unoptimized to repeatedly do <kbd>0 + FillTaken</kbd>.<br><br>

<ul><li>For example: using the same attributes as examples above (but with 4 middle tiles), [14 - 3 = 11]. Subtraction successful, write 3 (maximum)
for the left end, and then write 11 back to the remaining fill amount. Then [11 - 8 = 3], subtraction successful, so the first middle tile byte is 8 (maximum). Finally, [3 - 8 = (-5)]. Subtraction failed, write the remaining amount
(3) on the second middle tile byte. Set the remaining fill amount to 0, and repeat until all tile bytes processed (which results in [0 - MaxAmount], and repeatedly sets the following bytes to 0):
<table>
<tr><th><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> addresses</th><th>Tile byte type</th><th>Fill amount</th><th>Fill maximum</th><th>Calculation</th><th>Remaining fill amount changes</th></tr>
<tr><td><kbd>$7F844A</kbd> (<kbd>Address+0</kbd>)</td><td><span style="color: cyan">Left end</span></td><td style="background-color: orange"><kbd>3</kbd> (<kbd>$03</kbd>)</td><td style="text-align: center;"><kbd>3</kbd></td><td><kbd>14 - 3 = 11</kbd> subtraction successful!</td><td>14 &rightarrow; 11</td></tr>
<tr><td><kbd>$7F844B</kbd> (<kbd>Address+1</kbd>)</td><td><span style="color: #00FF00">Middle 1</span></td><td style="background-color: orange"><kbd>8</kbd> (<kbd>$08</kbd>)</td><td style="text-align: center;"><kbd>8</kbd></td><td><kbd>11 - 8 = 3</kbd> subtraction successful!</td><td>11 &rightarrow; 3</td></tr>
<tr><td><kbd>$7F844C</kbd> (<kbd>Address+2</kbd>)</td><td><span style="color: #00FF00">Middle 2</span></td><td style="background-color: yellow"><span style="color: black"><kbd>3</kbd> (<kbd>$03</kbd>)</span></td><td style="text-align: center;"><kbd>8</kbd></td><td><kbd>3 - 8 = (-5)</kbd> subtraction failed!</td><td>3 &rightarrow; 0</td></tr>
<tr><td><kbd>$7F844D</kbd> (<kbd>Address+3</kbd>)</td><td><span style="color: #00FF00">Middle 3</span></td><td style="background-color: grey"><kbd>0</kbd> (<kbd>$00</kbd>)</td><td style="text-align: center;"><kbd>8</kbd></td><td><kbd>0 - 8 = (-8)</kbd> subtraction failed!</td><td>0 &rightarrow; 0</td></tr>
<tr><td><kbd>$7F844E</kbd> (<kbd>Address+4</kbd>)</td><td><span style="color: #00FF00">Middle 4</span></td><td style="background-color: grey"><kbd>0</kbd> (<kbd>$00</kbd>)</td><td style="text-align: center;"><kbd>8</kbd></td><td><kbd>0 - 8 = (-8)</kbd> subtraction failed!</td><td>0 &rightarrow; 0</td></tr>
<tr><td><kbd>$7F844F</kbd> (<kbd>Address+5</kbd>)<td><span style="color: red">Right end</span></td><td style="background-color: grey"><kbd>0</kbd> (<kbd>$00</kbd>)</td><td style="text-align: center;"><kbd>3</kbd></td><td><kbd>0 - 3 = (-3)</kbd> subtraction failed!</td><td>0 &rightarrow; 0</td></tr>
</table><br>
<svg width="700" height="900" style="background-color: #606060" id="SVG_RepeatedSubtractionExplained">
</li></ul><br>
<br><br>


<table>
<tr><th>Input</th><td>Number of bytes</td><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The amount of fill</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Graphical bar attributes, same as <kbd>CalculateGraphicalBarPercentage</kbd></td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of Bytes</th><th>Description</th></tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl + ((<abbr title="0 if no left end, 1 if set to any nonzero number of pieces">LeftEnd</abbr> +
<abbr title="Equals to !Scratchram_GraphicalBar_TempLength if middle pieces is nonzero, 0 otherwise">MiddleLength</abbr> + <abbr title="0 if no right end, 1 if set to any nonzero number of pieces">RightEnd</abbr>) - 1)</span></span></kbd>
</td>
<td style="text-align: center; vertical-align: middle;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td>
<td>The table array containing each tile byte fill amount, same as <kbd>DrawGraphicalBar</kbd>.</td>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The leftover remaining amount of fill, if the fill amount is greater than the maximum/total, 0 otherwise (calculated via <kbd>RemainingFill = max((InputFillAmount - BarMaximumFull), 0)</kbd>)</td></tr>
</tr>

</table>
</li>
<br>

<li><a href="#TOCRoundAwayFromComplete_Back" id="TOCRoundAwayFromComplete">^</a><kbd>RoundAwayEmpty</kbd>, <kbd>RoundAwayFull</kbd>, and <kbd>RoundAwayEmptyFull</kbd>: After getting the Y register value from <a href="#CalculateGraphicalBarPercentage"><kbd>CalculateGraphicalBarPercentage</kbd></a>, this increments or
decrements the fill amount <kbd>$00-$01</kbd> by 1 so it will display 1 and/or <kbd>MaxFill-1</kbd> instead of showing 0 and/or <kbd>MaxFill</kbd> when the value is rounded towards them. The names
of the routine should be obvious (e.g. <kbd>RoundAwayEmpty</kbd> means round away from empty). See explanation <a href="readme_files/RoundAwayFromComplete.html">here</a>.</li><br>
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td>Y register</td><td style="text-align: center; vertical-align: middle;">1 (not stored)</td><td>Rounding modes, as explained when using <kbd>CalculateGraphicalBarPercentage</kbd>.</td></tr>
</table><br><br>

<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>Rounded percentage value.</td></tr>
</table><br><br>

</ul>
</ul>
<li><span id="ConvertFillToTile"><a href="#GraphicalBarConvertToTileBack" id="GraphicalBarConvertToTile">^</a>Inside <kbd>GraphicalBarConvertToTile.asm</kbd></span></li>
<ul>
<li><a href="#ConvertBarFillAmountToTiles_Back" id="ConvertBarFillAmountToTiles">^</a><kbd>ConvertBarFillAmountToTiles</kbd>: converts the bar fill table into tile numbers via indexing (inputs the same as above and don't
need to be rewritten). Note that this DOES modifies the values in <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> (replacing them with tile numbers):
<table>
<tr>
<th>Input</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td><td>The fill amount array to be converted to tile numbers.</td></tr>
<tr>
<td><kbd>$00</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td>Determines what sets of fill graphic tiles to use based on:<br>
<ul>
<li><kbd>#$00</kbd> = Level, layer 3</li>
<li><kbd>#$01</kbd> = Level, sprite</li>
<li><kbd>#$02</kbd> = Overworld, layer 3</li>
</ul></td>
</tr>
<tr>
<td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td rowspan="4">Needed to convert each tile by identifying the left end, middle (and how many middle tiles), and right end.</td>
</tr>
<tr>
<td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
<tr>
<td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
<tr>
<td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
</tr>
</table>
Output:
<table>
<tr>
<th>Output</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">!Scratchram_GraphicalBar_FillByteTbl + ((<abbr title="0 if no left end, 1 if set to any nonzero number of pieces">LeftEnd</abbr> +
<abbr title="Equals to !Scratchram_GraphicalBar_TempLength if middle pieces is nonzero, 0 otherwise">MiddleLength</abbr> + <abbr title="0 if no right end, 1 if set to any nonzero number of pieces">RightEnd</abbr>) - 1)</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td>
<td>Tile array containing tile numbers.</td>
</tr>
</table>
Destroyed:
<table>
<tr><th>Destroyed</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>$01</kbd></td><td style="text-align: center;">1</td><td>Used to keep track if all the middle tiles are processed.</td></tr>
</table>
What it looks like (&ldquo;in level - layer 3&rdquo; conversion):
<table>
<tr>
<th>Left end</th>
<th>Middle</th>
<th>Right end</th>
</tr>
<tr>
<td>
	<table>
		<tr><td><kbd>Fill amount $00 &rightarrow; tile number $36</kbd></td><td><img src="readme_files/GraphicalBarFills/LeftEnd_0_of_3.png"></td></tr>
		<tr><td><kbd>Fill amount $01 &rightarrow; tile number $37</kbd></td><td><img src="readme_files/GraphicalBarFills/LeftEnd_1_of_3.png"></td></tr>
		<tr><td><kbd>Fill amount $02 &rightarrow; tile number $38</kbd></td><td><img src="readme_files/GraphicalBarFills/LeftEnd_2_of_3.png"></td></tr>
		<tr><td><kbd>Fill amount $03 &rightarrow; tile number $39</kbd></td><td><img src="readme_files/GraphicalBarFills/LeftEnd_3_of_3.png"></td></tr>
	</table>
</td>
<td>

	<table>
		<tr><td><kbd>Fill amount $00 &rightarrow; tile number $55</kbd></td><td><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></td></tr>
		<tr><td><kbd>Fill amount $01 &rightarrow; tile number $56</kbd></td><td><img src="readme_files/GraphicalBarFills/Middle_1_of_8.png"></td></tr>
		<tr><td><kbd>Fill amount $02 &rightarrow; tile number $57</kbd></td><td><img src="readme_files/GraphicalBarFills/Middle_2_of_8.png"></td></tr>
		<tr><td><kbd>Fill amount $03 &rightarrow; tile number $58</kbd></td><td><img src="readme_files/GraphicalBarFills/Middle_3_of_8.png"></td></tr>
		<tr><td><kbd>Fill amount $04 &rightarrow; tile number $59</kbd></td><td><img src="readme_files/GraphicalBarFills/Middle_4_of_8.png"></td></tr>
		<tr><td><kbd>Fill amount $05 &rightarrow; tile number $65</kbd></td><td><img src="readme_files/GraphicalBarFills/Middle_5_of_8.png"></td></tr>
		<tr><td><kbd>Fill amount $06 &rightarrow; tile number $66</kbd></td><td><img src="readme_files/GraphicalBarFills/Middle_6_of_8.png"></td></tr>
		<tr><td><kbd>Fill amount $07 &rightarrow; tile number $67</kbd></td><td><img src="readme_files/GraphicalBarFills/Middle_7_of_8.png"></td></tr>
		<tr><td><kbd>Fill amount $08 &rightarrow; tile number $68</kbd></td><td><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"></td></tr>
	</table>
</td>
<td>
	<table>
		<tr><td><kbd>Fill amount $00 &rightarrow; tile number $50</kbd></td><td><img src="readme_files/GraphicalBarFills/RightEnd_0_of_3.png"></td></tr>
		<tr><td><kbd>Fill amount $01 &rightarrow; tile number $51</kbd></td><td><img src="readme_files/GraphicalBarFills/RightEnd_1_of_3.png"></td></tr>
		<tr><td><kbd>Fill amount $02 &rightarrow; tile number $52</kbd></td><td><img src="readme_files/GraphicalBarFills/RightEnd_2_of_3.png"></td></tr>
		<tr><td><kbd>Fill amount $03 &rightarrow; tile number $53</kbd></td><td><img src="readme_files/GraphicalBarFills/RightEnd_3_of_3.png"></td></tr>
	</table>
</td>
</tr>
</table><br>

So if <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> contains these values and gets converted, this happens:
<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address (index):</td>
<td style="background-color: cyan"><span style="color: black"><kbd>+0</kbd></span></td>
<td style="background-color: #00C000"><kbd>+1</kbd></td>
<td style="background-color: #00C000"><kbd>+2</kbd></td>
<td style="background-color: #00C000"><kbd>+3</kbd></td>
<td style="background-color: #00C000"><kbd>+4</kbd></td>
<td style="background-color: #00C000"><kbd>+5</kbd></td>
<td style="background-color: #00C000"><kbd>+6</kbd></td>
<td style="background-color: #00C000"><kbd>+7</kbd></td>
<td style="background-color: red"><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values...:</td>
<td style="background-color: orange"><kbd>$03</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: yellow"><span style="color: black"><kbd>$04</kbd></span></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
<td style="background-color: grey"><kbd>$00</kbd></td>
</tr>
<tr>
<td>...converted to tile number:</td>
<td style="background-color: orange"><kbd>$39</kbd></td>
<td style="background-color: orange"><kbd>$68</kbd></td>
<td style="background-color: orange"><kbd>$68</kbd></td>
<td style="background-color: yellow"><span style="color: black"><kbd>$59</kbd></span></td>
<td style="background-color: grey"><kbd>$55</kbd></td>
<td style="background-color: grey"><kbd>$55</kbd></td>
<td style="background-color: grey"><kbd>$55</kbd></td>
<td style="background-color: grey"><kbd>$55</kbd></td>
<td style="background-color: grey"><kbd>$50</kbd></td>
</tr>
<tr>
<td>Tile image:</td>
<td><center><img src="readme_files/GraphicalBarFills/LeftEnd_3_of_3.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_4_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/RightEnd_0_of_3.png"></center></td>
</tr>
<tr>
<td>
Result:
</td>
<td colspan="9">
<center>
<span class="NoLineBreak">
<img src="readme_files/GraphicalBarFills/LeftEnd_3_of_3.png"><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_4_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/RightEnd_0_of_3.png">
</span>
</center>
</td>
</tr>
</table><br>
If you changed the number of pieces in any tile bytes (left, middle (each middle), and right), the number of pieces must equal to the number of values, plus 1.
For example, by making left end have 4 pieces instead of 3, you must have 5 values in the left end tile table. Else your tiles will glitch:
<div class="CodeBlock"><pre>
;This is an example, therefore the numbers in this table may
;be different to you.

			GraphicalBar_LeftEnd8x8s_Lvl_L3:
			;Left end fill amount tile numbers:
			db $36		;&gt;Fill amount/index: $00
			db $37		;&gt;Fill amount/index: $01
			db $38		;&gt;Fill amount/index: $02
			db $39		;&gt;Fill amount/index: $03

	;4 pieces, now values are 0-4:
			GraphicalBar_LeftEnd8x8s_Lvl_L3:
			;Left end fill amount tile numbers:
			db $36		;&gt;Fill amount/index: $00
			db $37		;&gt;Fill amount/index: $01
			db $38		;&gt;Fill amount/index: $02
			db $39		;&gt;Fill amount/index: $03
			db <span style="color: red">$xx</span>		;&gt;Fill amount/index: $04</pre></div>

<br><br>

Note that scratch RAM <kbd>$00</kbd> and <kbd>$01</kbd> is overwritten to determine should it use overworld border version and handle a loop that translates the middle tiles.<br><br>

The table of tile numbers in the routine are ordered from empty to full in the tile array, I left the comments on there to show what fill amount for every byte for easier editing.<br><br>

</li>
<li><a href="#ConvertBarFillAmountToTilesDoubleBar_Back" id="ConvertBarFillAmountToTilesDoubleBar">^</a><kbd>ConvertBarFillAmountToTilesDoubleBar</kbd>: Same as above, but handles a
<a href="readme_files/DoubleBarInfo.html">double-filled bar (aka double-bar)</a> using a separate graphics. Tiles are formated <a href="readme_files/DoubleBarFills.png" target="_blank">like this</a>.
Also like above, make sure you have the number of pieces equal to <kbd>(NumberOfPieces+1)^2</kbd> number of values in table (for example, left end have 4 pieces, therefore you must have 25 values;
<kbd>(4+1)^2 = 25</kbd>). I recommend to have the table to form a perfect square so that the fill values are visually organized.<br>

Of course, the default graphics included here are pixel-column-based, meaning each column of pixels is 1 piece of a bar.<br><br>

Note that this does not support overworld graphics unlike above, as there are even more tiles used than the status bar.</li><br><br>

<table>
<tr><th>Input</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td><kbd>LeftEnd + MiddleLength + RightEnd</kbd></td><td>The fill amount array to be converted to tile numbers. (SecondFill).</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl + !Setting_GraphicalBar_SecondFillByteTableOffset</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + (((LeftEnd + MiddleLength + RightEnd) - 1) + !Setting_GraphicalBar_SecondFillByteTableOffset)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd></td><td>The fill amount array to be converted to tile numbers. (FirstFill).</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Graphical bar attributes, same as <kbd>CalculateGraphicalBarPercentage</kbd></td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td><kbd>LeftEnd + MiddleLength + RightEnd</kbd></td><td>Tile array containing tile numbers representing both first and second fills.</td></tr>
</table><br>

<table>
<tr><th>Overwritten</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd></td><td style="text-align: center;">1</td><td>Used to keep track if all the middle tiles are processed.</td></tr>
</table><br>

<li><a href="#ConvertBarFillAmountToTilesEdgeOverMultipleTiles_Back" id="ConvertBarFillAmountToTilesEdgeOverMultipleTiles">^</a><kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTiles</kbd>: Converts the bar fill table into tile numbers like <kbd>ConvertBarFillAmountToTiles</kbd> but can handle fill edge crossing tile borders. Due to the way the fill byte table format of having only up to a single fraction tile byte exist, this subroutine makes having
the fill edge covering multiple 8x8 tiles possible. This is useful for slanted, rounded, or outlined fill edged graphics:<br>
<img src="readme_files/MultiPartiallyFilled.png"><br>
See explanation <a href="readme_files/FillEdgeCrossingTileBorder.html" id="FillEdgeCrossingTileBorder">here</a> Inputs and outputs are the same as <kbd>ConvertBarFillAmountToTiles</kbd>.
</li>

<li><a href="#ConvertBarFillAmountToTilesIndirectAddressTable_Back" id="ConvertBarFillAmountToTilesIndirectAddressTable">^</a><kbd>ConvertBarFillAmountToTilesIndirectAddressTable</kbd>: Does the same thing as <kbd><a href="#ConvertBarFillAmountToTiles">ConvertBarFillAmountToTiles</a></kbd>, but tile
tables are no longer &ldquo;fixed&rdquo; (no need to edit the routine's code to check $00's newer values and adding new tables around that area). This is useful for situations that you need different tile layouts across levels due to other sprites occupying certain 8x8 tiles
(the Giant Masked Koopa included here demonstrates this).
<table>
<tr><th>Input</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td><td>The fill amount array to be converted to tile numbers.</td></tr>
<tr><td><kbd>$00</kbd> to <kbd>$02</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for left end.</td></tr>
<tr><td><kbd>$03</kbd> to <kbd>$05</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for middles.</td></tr>
<tr><td><kbd>$06</kbd> to <kbd>$08</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for right end.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center;">1</td><td rowspan="4">Needed to convert each tile by identifying the left end, middle (and how many middle tiles), and right end.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center;">1</td></tr>
</table><br>
<table>
<tr><th>Output</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td>
<td>Tile array containing tile numbers.</td></tr>
</table><br>
Destroyed:
<table>
<tr><th>Destroyed</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$09</kbd></td><td style="text-align: center;">1</td><td>Used to track the middle tiles if all of them are done.</td></tr>
</table><br>

<p>In case if you don't know how input an address into scratch RAM, you label your table like this (this is an example from the tile table for the Giant Masked Koopa Boss):
<div class="CodeBlock"><pre>		BarTilesLeft:
		;Left end fill amount tile numbers:
		db $88		;&gt;Fill amount/index: $00
		db $89		;&gt;Fill amount/index: $01
		db $8A		;&gt;Fill amount/index: $02
		db $8B		;&gt;Fill amount/index: $03
		BarTilesMiddle:
		;Middle fill amount tile numbers
		db $8C		;&gt;Fill amount/index: $00
		db $8D		;&gt;Fill amount/index: $01
		db $8E		;&gt;Fill amount/index: $02
		db $8F		;&gt;Fill amount/index: $03
		db $98		;&gt;Fill amount/index: $04
		db $99		;&gt;Fill amount/index: $05
		db $9A		;&gt;Fill amount/index: $06
		db $9B		;&gt;Fill amount/index: $07
		db $9C		;&gt;Fill amount/index: $08
		BarTilesRight:
		;Right end fill amount tile numbers:
		db $9D		;&gt;Fill amount/index: $00
		db $9E		;&gt;Fill amount/index: $01
		db $9F		;&gt;Fill amount/index: $02
		db $A8		;&gt;Fill amount/index: $03</pre></div><br>
The labels are <kbd>GraphicalBar_LeftEnd8x8s_Lvl_Spr</kbd>, <kbd>GraphicalBar_Middle8x8s_Lvl_Spr</kbd>, and <kbd>GraphicalBar_RightEnd8x8s_Lvl_Spr</kbd> are labels, and points to an array of bytes (starting at the first byte of the array).<br><br>

To write such address into RAM with the labels in existence, you do this:
<div class="CodeBlock" style="height: 353px; width: 1049px;"><pre>			REP #$20
			LDA $00 : PHA	;Preserve a bunch of stuff because following subroutine uses $00-$09.
			LDA $02 : PHA
			LDA $04 : PHA
			LDA $06 : PHA
			LDA $08 : PHA
			LDA.w #BarTilesLeft : STA $00		;\Here is the actual writing the address into RAM.
			LDA.w #BarTilesMiddle : STA $03		;|(the low 2 bytes of the 3-byte address)
			LDA.w #BarTilesRight : STA $06		;/
			SEP #$20
			LDA.b #BarTilesLeft&gt;&gt;16 : STA $02 : STA $05 : STA $08
				;^Same as above but this time, the high byte. Because all 3 tables resides in the same bank, we only need one LDA.
			%GraphicalBarConvertBarFillAmountToTilesIndirectAddressTable() ;Convert fill amount to tiles
			REP #$20
			PLA : STA $08
			PLA : STA $06
			PLA : STA $04
			PLA : STA $02
			PLA : STA $00
			SEP #$20
	
	;Labels represents the address (or position) in the ROM. LDA.w #Label when Label is at location $1234, that means it will
	;be LDA #$1234. If you don't have that hash symbol, it would be LDA Label -&gt; LDA $1234 (which loads RAM instead of &ldquo;Immediate&rdquo;)</pre></div><br>
</p>
</li>
<li><a href="#ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable_Back" id="ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable">^</a><kbd>ConvertBarFillAmountToTilesEdgeOverMultipleTilesIndirectAddressTable</kbd>: same as <kbd><a href="#ConvertBarFillAmountToTilesEdgeOverMultipleTiles">ConvertBarFillAmountToTilesEdgeOverMultipleTiles</a></kbd>
and just like <kbd><a href="#ConvertBarFillAmountToTilesIndirectAddressTable">ConvertBarFillAmountToTilesIndirectAddressTable</a></kbd>, have a relocatable table that you can manually set.
<table>
<tr><th>Input</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td><td>The fill amount array to be converted to tile numbers.</td></tr>
<tr><td><kbd>$00</kbd> to <kbd>$02</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for left end.</td></tr>
<tr><td><kbd>$03</kbd> to <kbd>$05</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for middles.</td></tr>
<tr><td><kbd>$06</kbd> to <kbd>$08</kbd></td><td style="text-align: center;">3</td><td>Address location of where the table of tile numbers for right end.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center;">1</td><td rowspan="4">Needed to convert each tile by identifying the left end, middle (and how many middle tiles), and right end.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center;">1</td></tr>
</table><br>
<table>
<tr><th>Output</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd> (both ends are 0 or 1 if nonexistent or exist, MiddleLength is how many middle tiles)</td>
<td>The tile number array that was previously the fill amounts.</td></tr>
</table><br>

Destroyed:
<table>
<tr><th>Destroyed</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$09</kbd></td><td style="text-align: center;">1</td><td>Used to track the middle tiles if all of them are done.</td></tr>
<tr><td><kbd>$0A</kbd></td><td style="text-align: center;">1</td><td>Needed to prevent taking the last tile, and adding by an invalid data after that.</td></tr>
</table>
</li>

</ul><br>

<li><span id="StatusBarWrite"><a href="#GraphicalBarWriteToStatusBarBack" id="GraphicalBarWriteToStatusBar">^</a>Inside <kbd>GraphicalBarWriteToStatusBar.asm</kbd>. Note that there are two similar subroutines main labels with one that have &ldquo;<kbd>Format2</kbd>&rdquo; (such as <kbd>WriteBarToHUD</kbd> and
<kbd>WriteBarToHUDFormat2</kbd>) appended are the same as the other but handles a different status bar/OWB format. See <a href="readme_files/Layer3TileFormat/Layer3TileFormat.html" target="_blank">this information</a>
regarding the tile formats.
</li>
<ul>
<li><a href="#WriteBarToHUD_Back" id="WriteBarToHUD">^</a><kbd>WriteBarToHUD</kbd>: Copies the tile numbers in the table to paste to (writes) the status bar or stripe image,
in the direction of filling left to right. If used as a stripe on vertical mode, it would be downwards. Inputs are again, similar to <kbd>CalculateGraphicalBarPercentage</kbd>
with only the attributes being used, but a new input is required:
<table>
<tr>
<th>Input</th>
<th>Number of bytes</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$00</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$02</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">3</td>
<td>This input contains the starting <abbr title="You write an ADDRESS into RAM, e.g. Setting RAM $00~$02 to values $00, $A0, $7F would mean writing to $7FA000.">address</abbr> (left end, extends rightwards, even when the bar is set to fill leftwards) location to write the tile numbers to the status bar.</td>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$03</span></span></kbd> to <kbd><span class="NoLineBreak"><span style="font-weight: bold;">$05</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">3</td>
<td>The starting address (left end, extends rightwards, even when the bar is set to fill leftwards) location to write the tile properties to the status bar.
(This only works if you installed status bar patches that enable editing the properties in-game, and set <kbd>!StatusBar_UsingCustomProperties</kbd> to <kbd>1</kbd>,
else this is no longer needed to write values to this input). I deliberately used the if statement around this to prevent writing to an arbitrary address (the <span class="NoLineBreak"><kbd>STA [$03],y</kbd></span> could write to an invalid address).</td>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">$06</span></span></kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td>The tile properties (YXPCCCTT) for each tile. Same as above, if you have it disabled, this is not used.</td>
</tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Needed to find how many total tiles to write.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table><br>
<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr>
<td><kbd><span style="font-weight: bold;">RAMAddressIn00</span></kbd> to <span class="NoLineBreak"><kbd><span style="font-weight: bold;">RAMAddressIn00 + ((NumberOfTiles-1)*<a href="readme_files/Layer3TileFormat/Layer3TileFormat.html" target="_blank">TileFormat</a>)</span></kbd></span></td>
<td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td>
<td>Location to write to the status bar/OWB+ patch(es). Note: if using SSB-format, will write every other tile, starting at <kbd>RAMAddressIn00</kbd>, otherwise all the bytes in between
are written.</td>
</tr>
<tr>
<td><kbd><span style="font-weight: bold;">RAMAddressIn03</span></kbd> to <span class="NoLineBreak"><kbd><span style="font-weight: bold;">RAMAddressIn03 + ((NumberOfTiles-1)*!StatusBarFormat)</span></kbd></span></td>
<td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td>
<td>Same as above, but for tile properties (should you enable the tile properties to be writable via <span class="NoLineBreak"><kbd>!StatusBar_UsingCustomProperties</kbd></span>)</td>
</tr>
</table>
Remember that all numbers are little endians (The address <kbd>$7E0F09</kbd>, for example are stored in each bytes as
<pre>$7E0000: $09
$7E0001: $0F
$7E0002: $7E</pre>

so be careful on that.).
Of course, because the <a href="https://www.smwcentral.net/?p=section&a=details&id=15222">Overworld Border Plus</a> patch have the same format as the Super Status Bar patch,
it will work on that as well (if <kbd>!StatusBarFormat</kbd> set to $02 and you make a different version of the routine <kbd>ConvertBarFillAmountToTiles</kbd> to use a different
table to use OW layer 3 tiles).<br><br>

As a side note, the <kbd>Format2</kbd> version of this also works stripe image both horizontal and vertical, since SSB, OWB+ and stripe uses the same <kbd>TTTTTTTT YXPCCCTT TTTTTTTT YXPCCCTT...</kbd> format. However, I strongly
recommend having <kbd>!StatusBar_UsingCustomProperties</kbd> set to <kbd>1</kbd> in <kbd>GraphicalBarDefines/StatusBarSettings.asm</kbd> because it could write garbage tiles or crash your game.</li><br>

<li><a href="#WriteBarToHUDLeftwards_Back" id="WriteBarToHUDLeftwards">^</a><kbd>WriteBarToHUDLeftwards</kbd>: Same as above, but writes an X-flipped version, in the direction of filling right to left (<img width="96" class="img-hor" src="readme_files/TransperentBackground.png">), if used
as a vertical stripe, it would be bottom to top.<br><br>

Note that the properties byte (assuming <kbd>!StatusBar_UsingCustomProperties == 1</kbd>) does not automatically modify the X- and/or Y-flip flags when set to fill leftwards or downwards. This is because when having vertical
bars as a stripe image, they need to be Y-flipped instead of X when filling in opposite directions.<br><br>

In vanilla SMW, it is still possible to edit the tile properties (but cannot be changed in-game as the data is stored in ROM) at around address <kbd>$008C81</kbd>.<br><br>

Note that this does NOT reverse the order of bytes stored in <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> table, it simply takes that table, and write them on the HUD backwards.<br><br>

To avoid confusion, I refer the end tiles in which the fill <span style="font-weight: bold;">starts</span> as the left end and right end to where the fill goes to. Left/right <i>side</i> refers the literal left/right side from the user's perspective.
Also keep in mind that as you increase the length of the bar, it will always extend towards the right unless you use the <kbd>BarExtendLeft</kbd> routine.<br><br>

Another note is that the address provided on where to write on the status bar is still &ldquo;left to right&rdquo; meaning as the bar extends, the left side of the bar does not move and will still extend rightwards although
the fill starts on the right side.<br><br>

Just like <kbd>WriteBarToHUD</kbd>, this will also work on stripe image data for both vertical and horizontal (this is for upwards-filling bar).
</li><br>
<li><a href="#WriteBarToHUDVertically_Back" id="WriteBarToHUDVertically">^</a><kbd>WriteBarToHUDVertically</kbd>: Writes a vertical bar on the HUD, supports both upwards and downwards. Only works if the status bar is 32 tiles wide on each contiguous row,
at the time of writing this, only SMB3, SSB, and OWB+ patches will work on this. Don't use this for stripe image.
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$02</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>The starting tile address where the fill starts at. If filling upwards, this would be the bottom, if downwards, this would be the top.</td></tr>
<tr><td><kbd>$03</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>The starting tile property address where the fill starts at. If filling upwards, this would be the bottom, if downwards, this would be the top. Like <kbd>WriteBarToHUD</kbd>, if <kbd>!StatusBar_UsingCustomProperties</kbd> is 0, this is not used.</td></tr>
<tr><td><kbd>$06</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td>YXPCCCTT for each tile (does not modify the Y bit itself, so a vertically flipped bar would mean you set the Y bit yourself). Not used if <kbd>!StatusBar_UsingCustomProperties</kbd> is 0.</td></tr>
<tr><td><kbd>$07</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td>Direction, only use these values: <kbd>$00</kbd> = upwards, <kbd>$02</kbd> = downwards.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Needed to find how many total tiles to write.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table><br>
<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>RAMAddressIn00-(X*32*StatusBarFormat)</kbd> for upwards or <kbd>RAMAddressIn00+(X*32*StatusBarFormat)</kbd> for downwards, both with X being an integer increasing from 0 to <kbd>NumberOfTiles-1</kbd></td><td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles</kbd> (not contiguous)</td><td>Location to write to the status bar/OWB+ patch(es). Note: if using SSB-format, will write every other tile, starting at RAMAddressIn00, otherwise all the bytes in between are written.</td></tr>
<tr><td><kbd>RAMAddressIn03-(X*32*StatusBarFormat)</kbd> for upwards or <kbd>RAMAddressIn03+(X*32*StatusBarFormat)</kbd> for downwards, both with X being an integer increasing from 0 to <kbd>NumberOfTiles-1</kbd></td><td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles</kbd> (not contiguous)</td><td>Same as above, but for tile properties (should you enable the tile properties to be writable via !StatusBar_UsingCustomProperties)</td></tr>
<tr><td><kbd>$00</kbd> to <kbd>$02</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>The address after writing the last tile (as if writing the amount of tiles plus 1), can be used for writing static end tile where the fill ends at</td></tr>
<tr><td><kbd>$03</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Same as above but for tile properties.</td></tr>
</table><br>

Note: Just like <kbd>WriteBarToHUDLeftwards</kbd>, it does not reverse the order of bytes in <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd>. As the fill increases, whatever side it starts from is considered to be the &ldquo;left end&rdquo; and the side that the fill is going towards is considered to be the &ldquo;right end&rdquo;.
</li><br>
<li><a href="#BarExtendLeft_Back" id="BarExtendLeft">^</a><kbd>BarExtendLeft</kbd>: Normally, without this routine, as the bar's length (not to be confused with <kbd>WriteBarToHUDLeftwards</kbd> routine) increases, the
bar always extends rightwards (leftmost tile stays in place while the rightmost moves rightwards), regardless of left or rightwards direction. With this, you call this routine before you call <kbd>WriteBarToHUD</kbd>
or <kbd>WriteBarToHUDLeftwards</kbd> (use the latter if you want a truly mirrored bar) to make it extend leftwards (the leftmost tile moves left while the rightmost tile
stays in place). This is useful for displaying enemy HP bars that are &ldquo;right aligned&rdquo; that have lengths proportional to how much max HP the enemy has and extend leftwards.<br>
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd><span style="font-weight: bold;">$00</span></kbd> to <kbd><span style="font-weight: bold;">$02</span></kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Status bar tile location to write on this and before (this represent the position of the last tile).</td></tr>
<tr><td><kbd><span style="font-weight: bold;">$03</span></kbd> to <kbd><span style="font-weight: bold;">$05</span></kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Same as above, but for tile properties (if you have enabled tile properties write).</td></tr>
</table><br>
Write range:
<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd><span style="font-weight: bold;">$00</span></kbd> to <kbd><span style="font-weight: bold;">$02</span></kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>The tile number location where to write the starting starting (leftmost) tile, calculated via subtracting what you have inputed by
the number of tiles, minus 1 (<kbd>LeftmostTilePosition = RAMAddressIn00 - ((NumberOfTiles-1) * TileFormat)</kbd>, where <kbd>RAMAddressIn00</kbd> is the RAM address prior calling this routine),
then writes back to <kbd>$00</kbd>.</td></tr>
<tr><td><kbd><span style="font-weight: bold;">$03</span></kbd> to <kbd><span style="font-weight: bold;">$05</span></kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Same as above, but for tile properties (if you have enabled tile properties write).</td></tr>
</table><br>
After executing this subroutine, then calling <kbd>WriteBarToHUD</kbd> or <kbd>WriteBarToHUDLeftwards</kbd> now have their tile write range be modified:
<table>
<tr><th><kbd>WriteBarToHUD</kbd> and <kbd>WriteBarToHUDLeftwards</kbd>'s modified tile write range:</th><th>Number of bytes</th><th>Description</th></tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">RAMAddressIn00 - ((NumberOfTiles-1) * TileFormat)</span></span></kbd> to <span class="NoLineBreak"><kbd><span style="font-weight: bold;">RAMAddressIn00</span></kbd></span></td>
<td><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td>
<td>The tile numbers of the bar.</td>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><span style="font-weight: bold;">RAMAddressIn03 - ((NumberOfTiles-1) * TileFormat)</span></span></kbd> to <span class="NoLineBreak"><kbd><span style="font-weight: bold;">RAMAddressIn03</span></kbd></span></td>
<td><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td>
<td>The tile properties of the bar.</td>
</tr>
</table><br>
<img src="readme_files/BarExtendLeftTiles.png"><br>
Example when using the Super Status Bar patch:<br>
<img src="readme_files/BarExtendLeftTiles_OnStatBar.png"><br>
Be careful with bank borders crossing (don't have status bar tile tables that goes from <kbd>$7EFFFF</kbd> to <kbd>$7F0000</kbd>, for a made-up example), as I discovered that
Akaginite's <kbd>16Bit - 8Bit</kbd> (done by <kbd>((-8Bit) + 16Bit</kbd>)) does not work with bank borders if <kbd>8Bit</kbd> is <kbd>$00</kbd> because that causes the carry flag
to be clear, unlike the normal SBC. However, this is very unlikely as no status bar tile tables would ever do that.<br><br>

Don't use this for stripe image, since this modifies <span style="font-weight: bold;">what address</span> the bar starts on. Stripe, however have tile XY positions based on whats in the header rather than what address.</li><br>
<li><a href="#WriteBarStaticTileToHUD_Back" id="WriteBarStaticTileToHUD">^</a><span id="StaticEndRoutine">Static end tiles handlers</span> (this calculates where to write the static
end tiles based on the length of the bar and also writes to tile number and properties, <a href="#StaticEndTiles">as mentioned earlier</a>).
<ul>
<li><kbd>WriteBarStaticTileToHUDLeftside</kbd>: Writes tile for the left side of the bar (a tile just before the bar's leftmost tile). Writes at <kbd>RAMAddressIn00 - TileFormat</kbd> for
a bar that extend rightwards and <kbd>RAMAddressIn00 - (NumberOfTiles*TileFormat)</kbd> for leftwards.</li>
<li><kbd>WriteBarStaticTileToHUDRightside</kbd>: Same as above but for the rightside. Writes at <kbd>RAMAddressIn00 + (NumberOfTiles*!StatusBarFormat)</kbd> for extend-right bars and
<kbd>RAMAddressIn00 + TileFormat</kbd> for extend-left.</li><br>
</ul><br>
If you use <kbd>BarExtendLeft</kbd>, execute that routine, and then this static end tile handler, as that routine modifies the area where to write the bar.

Note that this is unaffected by <kbd>WriteBarToHUDLeftwards</kbd>, meaning that static end tiles don't automatically flip. Inputs are:

<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr>
<td><kbd>$00</kbd> to <kbd>$02</kbd></td>
<td style="text-align: center; vertical-align: middle;">3</td>
<td rowspan="2">Same as <kbd>WriteBarToHUD</kbd></td>
</tr>
<tr>
<td><kbd>$03</kbd> to <kbd>$05</kbd></td>
<td style="text-align: center; vertical-align: middle;">3</td>
</tr>
<tr>
<td><kbd>$06</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td>Tile properties to write (if you have enabled tile properties write).</td>
</tr>
<tr>
<td><kbd>$07</kbd></td>
<td style="text-align: center; vertical-align: middle;">1</td>
<td>Tile number to write</td>
</tr>
</table>
</li><br>
<li><a href="#CountNumberOfTiles_Back" id="CountNumberOfTiles">^</a><kbd>CountNumberOfTiles</kbd>: Counts how many tiles the bar uses, minus 1. This is used by other routines when writing to the status bar to figure out how many tiles to write. It is also used
to calculate where to place the bar when using <kbd>BarExtendLeft</kbd> as well as where to place static end tiles when running the static end tile handlers.
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Used for counting tiles.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd><span class="NoLineBreak">X register</span></kbd></td><td>1 (not stored)</td><td>The number of tiles, minus 1 (if the bar has 9 tiles, X would be <kbd>$08</kbd>). Returns <kbd>$FF</kbd> if 0 tiles exist (the whole bar set to 0 pieces in total)</td></tr>
</table><br>

This subroutine also exists in <kbd>GraphicalBarConvertToTile.asm</kbd> because of one simple inconvenient reason: several subroutines in that and <kbd>GraphicalBarWriteToStatusBar.asm</kbd> uses this subroutine and you cannot
have one <kbd>library</kbd> ASM file have labels referring to another ASM file in that library (you cannot have one code in a library call another ASM file code), as stated in the readme:
<div class="CodeBlock" style="width: 517px; height: 109px;"><pre>The second one is that you can't call other libraries codes from a
library file. For example, if you have a windowing HDMA code and you
need to call a sqrt routine, which is located on the math library, you
can't do that, because UberASM Tool can't guess what labels each file
will generate nor what labels each library .asm file will depend from
each other. So unfortunately the library files are pretty much
isolated from each one.</pre></div>

</li><br>
<li><a href="#WriteDoubleEndedBar_Back" id="WriteDoubleEndedBar">^</a><kbd>WriteDoubleEndedBar</kbd>: Writes a mirrored version of the left-to-right bar and places it to the left of that bar. This is intended to display double-ended bars that as the fill increases, it starts in the center
and fill towards both ends (<img src="readme_files/DoubleEndedBar.gif">). You call this routine after calling <kbd>WriteBarToHUD</kbd> (don't use the leftwards version). NOTE: The mirrored copy ALWAYS have the X-bit in YXPCCCTT
being SET (the bar graphic tiles must be filling left-to-right by default).

<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_LeftEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td rowspan="4">Needed to count how many tiles to figure out where the starting address for the mirrored bar.</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_RightEndPiece</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_TempLength</kbd></td><td style="text-align: center; vertical-align: middle;">1</td></tr>
<tr><td><kbd>$00</kbd> to <kbd>$02</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>The address location of the <span style="font-weight: bold;">starting</span> tile of the original left-to-right bar for tile numbers.</td></tr>
<tr><td><kbd>$03</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Same as above but tile properties.</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>Address_In_00-(NumberOfTiles*!StatusBarFormat)</kbd> to <kbd>Address_In_00-(1*!StatusBarFormat)</kbd></td><td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td><td>The area where the flipped bar will be written at (tile numbers).</td></tr>
<tr><td><kbd>Address_In_03-(NumberOfTiles*!StatusBarFormat)</kbd> to <kbd>Address_In_03-(1*!StatusBarFormat)</kbd></td><td style="text-align: center; vertical-align: middle;"><kbd>NumberOfTiles*!StatusBarFormat</kbd> (every other byte written if TileFormat = 2)</td><td>Same as above but tile properties</td></tr>
<tr><td><kbd>$06</kbd> to <kbd>$08</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td rowspan="2">(overwritten, not useful after this routine) Needed since the address of the original bar and mirrored are both needed during the loop.</td></tr>
<tr><td><kbd>$09</kbd> to <kbd>$0B</kbd></td><td style="text-align: center; vertical-align: middle;">3</td></tr>
</table>
</li><br>
<li><a href="#SetupStripe_Back" id="SetupStripe">^</a><kbd>SetupStripe</kbd>: Sets up the stripe. Automatically handles the 4-byte header, terminating byte and length of stripe (you only have to write tile data starting at <kbd>$7F837D+4,x</kbd>). For more information
about stripe data, see <a href="https://www.smwcentral.net/?p=viewthread&t=14531">here</a> (outdated and some info are incorrect), then see <a href="https://smwc.me/1600801">this</a>, and future posts after it.
<table>
	<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$00</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td>X position, 0-63.</td></tr>
	<tr><td><kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td>Y position, 0-63.</td></tr>
	<tr>
		<td>
			<kbd>$02</kbd>
		</td>
		<td style="text-align: center; vertical-align: middle;">1</td>
		<td>
			What layer:
			<ul>
				<li><kbd>$02</kbd>: Layer 1</li>
				<li><kbd>$03</kbd>: Layer 2</li>
				<li><kbd>$05</kbd>: Layer 3</li>
			</ul>
		</td>
	</tr>
	<tr>
		<td>
			<kbd>$03</kbd>
		</td>
		<td style="text-align: center; vertical-align: middle;">1</td>
		<td>
			Direction and RLE: <kbd>%DR00000000</kbd>
			<ul>
				<li><kbd>R</kbd>: Repeat: 0 = no (manually write different tiles), 1 = yes (write one tile multiple times, based on input <kbd>$04-$05</kbd>)</li>
				<li><kbd>D</kbd>: Direction: 0 = horizontal (rightwards), 1 = vertical (downwards)</li>
			</ul>
		</td>
	</tr>
	<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>Number of tiles, minus 1 (a value of 2 here means 3 tiles). If RLE is used, this is how many times a tile is repeated, minus 1.</td></tr>
</table><br><br>

<table>
	<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$7F837B</kbd> to <kbd>$7F837C</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>Updated length of stripe data.</td></tr>
	<tr><td><kbd>X register</kbd></td><td style="text-align: center; vertical-align: middle;">2 (not stored)</td><td>The index position of where to write tile data (starting at <kbd>$7F837D+4,x</kbd>).</td></tr>
</table><br><br>

<table>
	<tr><th>Destroyed</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$06</kbd> to <kbd>$08</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Used when not using RLE, to calculate the terminating byte location.</td></tr>
</table><br>
After calling that, all you have to do is write your tile data to <kbd>$7F837D+4,x</kbd> (XY register will be 16-bit) and beyond, but be careful not to overwrite the terminating byte (and potentially the bytes after) if this is your last stripe within a frame.
Just like the Super Status Bar patch and OWB+, its tile data format is &ldquo;2-bytes together&rdquo;.
</li>
</ul>


<li><a href="#GraphicalBarOtherRoutinesBack" id="GraphicalBarOtherRoutines">^</a>Inside <kbd>GraphicalBarOtherRoutines.asm</kbd></li>
<ul>
<li><a href="#MapRangeToStartAt0_Back" id="MapRangeToStartAt0">^</a><kbd>MapRangeToStartAt0</kbd>: Maps any given range, and the quantity (of 3 given numbers) to a zero-based range (for use so that any number that is the minimum maps to
0% and maximum to 100%, akin to <a href="https://en.wikipedia.org/wiki/Feature_scaling#Rescaling_(min-max_normalization)">Min-max feature scaling</a>, but this subroutine merely subtracts Quantity and MaxQuantity by <kbd>min</kbd> so it is 0). For example: A range from 75 to 100 with a quantity of 85 would be converted to 0 to 25 with a quantity of 10. This is useful for stacked bars like EXP progress bar or multiple HP bars for bosses. You call this
routine before you call <kbd>CalculateGraphicalBarPercentage</kbd>.
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The quantity (expected to be in between two numbers).</td></tr>
<tr><td><kbd>$02</kbd> to <kbd>$03</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The minimum quantity.</td></tr>
<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The maximum quantity.</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th><th>Where to write for <kbd>CalculateGraphicalBarPercentage</kbd></th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The quantity, subtracted by minimum quantity. <kbd>ZeroBasedQuantity = max(Quantity - Minimum, 0)</kbd></td><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl+1</kbd></td></tr>
<tr><td><kbd>$02</kbd> to <kbd>$03</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The minimum quantity (stayed the same).</td><td>Not used (because this will always be zero by subtracting by itself, if it were used).</td></tr>
<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The maximum quantity (subtracted by minimal quantity), this is also the size of the range. <kbd>ZeroBasedMaxQuantity = MaxQuantity - MinQuantity</kbd></td><td><kbd>!Scratchram_GraphicalBar_FillByteTbl+2</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl+3</kbd></td></tr>
</table><br>

I've made a test file <kbd>Level_RangeBased.asm</kbd> (located in <kbd>UberasmTool_ExampleUsage</kbd> folder) that demonstrates this.
</li><br><br>

<li><a href="#InvertQuantity_Back" id="InvertQuantity">^</a><kbd>InvertQuantity</kbd>: Inverts the quantity (example: 12/100 &rightarrow; 88/100). This is useful
for in case you wanted something that increments (in memory), but the bar decreases from 100%. This is calculated simply by taking the maximum amount subtracting by the current amount, in this case, <kbd>100 - 12 = 88</kbd>. If quantity is exceeding maximum prior calling this routine,
will output zero. NOTE: It is better to use this subroutine to handle the literal quantity amounts prior calling <kbd>CalculateGraphicalBarPercentage</kbd> rather than to invert the fill amount to avoid potential accumulating rounding errors.<br><br>

<ul>
	<li>In Vanilla SMW, chargin chucks, all koopalings besides wendy and lemmy uses an &ldquo;inverted health&rdquo; system: A damage
	counter that increases every damage they take, and dies when it hits 3 (stomps for all HP based sprites), 5 (fireballs, for chucks), or 12 (for Ludwig). But there's a quirk:  regardless of which way to damage these characters, will always deal the same 1 point of damage. The number of hits
	to defeat is based on the last hit reaching or exceeding a value in which that value depends on the aforementioned damage type. This means you can quickly defeat SMW enemies/bosses effectively bypassing their invulnerability timer by shooting 2 fireballs, followed by stomping them, as they only
	gain their invulnerability timer from stomp attack, that the fireballs are worth the same as stomping, and that it was programmed that having 3 points of damage after a stomp defeats the sprite.</li><br>
	<li>A simple way to fix this anomaly is to have the kill threshold is not to have multiple values depending on the attack, but have a single value regardless of an attack, and make damages they take be at different values. To get the desired hits to defeat, do <kbd>Damage = <abbr title="Always round up to an integer; get lowest integer greater than or equal to X.">Ceiling</abbr>(TotalDamageToKill / NumberOfHits)</kbd>, Therefore:
	<table>
		<tr>
			<th>Enemy</th>
			<th>Max health/damage to defeat</th>
			<th>Stomp damage</th>
			<th>Fireball damage</th>
		</tr>
		<tr>
			<td>Chargin chuck</td>
			<td>15</td>
			<td>5</td>
			<td>3</td>
		</tr>
		<tr>
			<td>Ludwig</td>
			<td>12</td>
			<td>4</td>
			<td>1</td>
		</tr>
	</table>
	This <a href="https://www.smwcentral.net/?p=section&a=details&id=18148">Patch</a> along with displaying HP, comes with a fix with the janky SMW HP system.
</li><br>

</ul>
<table>
<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The quantity</td></tr>
<tr><td><kbd>$02</kbd> to <kbd>$03</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The maximum quantity</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The inverted quantity, calculated via <kbd>InvertedQuantity = max(MaxQuantity - Quantity, 0)</kbd></td></tr>
<tr><td><kbd>$02</kbd> to <kbd>$03</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>The maximum quantity (unchanged)</td></tr>
</table>
</li>
</ul>
</ol>

<hr>
<h2><a href="#RoutinesInDrawOamPatch_Back" id="RoutinesInDrawOamPatch">^</a>Routines in <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd> and <kbd>Pixi_CustomSprite/Pixi Routines</kbd></h2>

<p>These routines, unlike the status bar routines, writes the graphical bar tiles as <span style="font-weight: bold;">sprite OAM</span>. This is very useful for sprite HUD or HUD placed on a character (rather than static
on-screen position, a bar that is placed relative to the character, such as on top of the character's head).</p>

<h3>Sprite-status bar-styled HUD (placed at highest priority)</h3>
<p>Note: The three following routines are not to be used for &ldquo;normal sprites&rdquo;, as they use the OAM directly (&ldquo;normal sprites&rdquo; is a term I refer to the type of sprites
that are often interactable, such as enemies, platforms, items, etc. that are SMW or pixi-made, that are part of the 12 (or 22 for sa-1 hacks)-sprite slot limit) and are intended to
function similarly to most sprite status bar patches. These are used by the patch at <kbd>Patch_DrawSpriteGraphicalBar/DrawOamPatch.asm</kbd> which includes the routines from <kbd>Routines</kbd> folder.</p>
<ul>
	<li><a href="#DrawOamGraphicalBarHorizVert_Back" id="DrawOamGraphicalBarHorizVert">^</a><kbd>DrawOamGraphicalBarHoriz</kbd> and <kbd>DrawOamGraphicalBarVert</kbd>: Draws a horizontal/vertical graphical bar:
	<table>
	<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td><kbd>LeftEnd + MiddleLength + RightEnd</kbd></td><td>Tile numbers to write.</td></tr>
	<tr><td><kbd>$00</kbd> to <kbd>$01</kbd></td><td style="text-align: center;">2</td><td rowspan="2">X and Y position, relative to screen border (where the fill starts at). Note: The XY position origin is the top-left of the 8x8 tile where the fill starts at when increasing<sup>1</sup>.</td></tr>
	<tr><td><kbd>$02</kbd> to <kbd>$03</kbd></td><td style="text-align: center;">2</td></tr>
	<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center;">2</td><td>Number of tiles to write.</td></tr>
	<tr>
	<td><kbd>$06</kbd></td>
	<td style="text-align: center;">1</td>
	<td>Direction:
	For horizontal (using <kbd>DrawOamGraphicalBarHoriz</kbd>):
	<ul>
	<li><kbd>$00</kbd> = Left to right</li>
	<li><kbd>$01</kbd> = Right to left (YXPPCCCT's X bit automatically set)</li>
	</ul>
	For vertical (<kbd>DrawOamGraphicalBarVert</kbd>):
	<ul>
	<li><kbd>$00</kbd> = Bottom to top</li>
	<li><kbd>$01</kbd> = Top to bottom (YXPPCCCT's Y bit automatically set)</li>
	</ul>
	</td>
	</tr>
	<tr><td><kbd>$07</kbd></td><td style="text-align: center;">1</td><td>Properties (YXPPCCCT)</td></tr>
	</table><br>
	
	<table>
	<tr><th>Destroyed</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$08</kbd> to <kbd>$09</kbd></td><td style="text-align: center;">2</td><td>Displacement of each tile during processing (after placing each tile, this value gets increased by 8 for rightwards and downwards-filling bar, or decreased for leftwards and upwards-filling bar). Once finished, this will be the X position for horizontal or Y position for vertical after the final tile. This can be used for placing static end tile here.</td></tr>
	</table>
	</li><br>
	<sup>1</sup> When I mean the top left of the tile where the fill starts, it is this:<br>
	<img src="readme_files/SpriteGraphicalBar_origin.png"><br>
	Note the orange dot is the very specific pixel of the 8x8 tile representing the origin of that tile.<br><br>


<li><a href="#FindNFreeOAMSlot_Back" id="FindNFreeOAMSlot">^</a><kbd>FindNFreeOAMSlot</kbd>: This routine is only used by <kbd>DrawOamGraphicalBarHoriz</kbd> and <kbd>DrawOamGraphicalBarVert</kbd>, checks if there are sufficient OAM slots available of a given number.
The purpose of this is to act as a failsafe by simply not drawing the graphical bar at all if there are insufficient number of slots available (say, 8 open slots when the bar needed 9). This is to prevent drawing a bar with missing tiles (makes it so only show all the tiles or none).
	<table>
	<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center;">2</td><td>The number of slots to find. 16-bit because <abbr title="There are 128 slots, numbered from 0-127 ($00-$7F). Therefore the index must be 0-508 ($0000-$01FC), a range that an 8-bit integer cannot support. Another reason is that both X and Y index registers cannot use different 8 or 16-bit sizes.">OAM indexing are increments of 4<abbr></td></tr>
	</table><br>

	<table>
	<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td>
	<kbd>Carry bit</kbd></td><td style="text-align: center;">N/A</td><td>If no slot is available:
	<ul>
	<li>Clear (<kbd>0</kbd>) = Enough slots found</li>
	<li>Set (<kbd>1</kbd>) = Not enough slots available.</li>
	</ul>
	</td></tr>
	</table><br>
	</li>
<h3>Pixi sprite OAM</h3>
<p>These are the routines to use for &ldquo;normal sprites&rdquo;. Useful if you want to display HP bar next to the main body of the sprite. They are located at <kbd>Pixi_CustomSprite/Pixi Routines</kbd>.</p>

<li><a href="#DrawSpriteGraphicalBarHorizVert_Back" id="DrawSpriteGraphicalBarHorizVert">^</a><kbd>DrawSpriteGraphicalBarHoriz</kbd> and <kbd>DrawSpriteGraphicalBarVert</kbd>: The &ldquo;normal sprite&rdquo; versions of above.
To be called after calling <kbd>%GetDrawInfo()</kbd> and before <kbd>$01B7B3</kbd> or <kbd>%FinishOAMWrite()</kbd> in the sprite's code. Note: These always write 8x8 tiles, and when finishing the OAM write, Y must be $FF (indicating you are manually
setting the tile size) should your sprite use both 8x8 and 16x16 tile sizes.
<table>
<tr><th>Input</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> to <kbd>!Scratchram_GraphicalBar_FillByteTbl + ((LeftEnd + MiddleLength + RightEnd) - 1)</kbd></td><td style="text-align: center;"><kbd>LeftEnd + MiddleLength + RightEnd</kbd></td><td>Tile numbers to write.</td></tr>
<tr><td><kbd>Y index</kbd></td><td style="text-align: center;">1 (not stored)</td><td>OAM index to use (start from <kbd>$0300</kbd>/<kbd>$0460</kbd>, not <kbd>$0200</kbd>/<kbd>$0420</kbd>)</td></tr>
<tr><td><kbd>$02</kbd></td><td style="text-align: center;">1</td><td rowspan="2">X and Y position, relative to screen border (where the fill starts at). Note: The XY position origin is the top-left of the 8x8 tile where the fill starts at when increasing.</td></tr>
<tr><td><kbd>$03</kbd></td><td style="text-align: center;">1</td></tr>
<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center;">2</td><td>Number of tiles.</td></tr>
<tr><td><kbd>$06</kbd></td><td style="text-align: center;">1</td><td>Direction:
For horizontal (using <kbd>DrawSpriteGraphicalBarHoriz</kbd>):
<ul>
<li><kbd>$00</kbd> = Left to right</li>
<li><kbd>$01</kbd> = Right to left (YXPPCCCT's X bit set)</li>
</ul>
For vertical (<kbd>DrawSpriteGraphicalBarVert</kbd>):
<ul>
<li><kbd>$00</kbd> = Bottom to top</li>
<li><kbd>$01</kbd> = Top to bottom (YXPPCCCT's Y bit set)</li>
</ul>
</td></tr>
<tr><td><kbd>$07</kbd></td><td style="text-align: center;">1</td><td>Properties (YXPPCCCT)</td></tr>
</table><br>

<table>
<tr><th>Output</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>Y index</kbd></td><td style="text-align: center;">1 (not stored)</td><td>OAM index to use, a slot after writing the last tile of the bar.</td></tr>
</table><br>

<table>
<tr><th>Destroyed</th><th>Number of Bytes</th><th>Description</th></tr>
<tr><td><kbd>$08</kbd></td><td style="text-align: center;">1</td><td>Displacement of each tile during processing (after placing each tile, this value gets increased by 8 for rightwards and downwards-filling bar, or decreased for leftwards and upwards-filling bar). Once finished, this will be the X position for horizontal or Y position for vertical after the final tile. This can be used for placing static end tile here.</td></tr>
</table>

</li>
</ul>
<hr>
<h2><a href="#NotesBack" id="Notes">^</a>Notes</h2>
<ul>

<li><p>You don't have to call the routine <kbd>CalculateGraphicalBarPercentage</kbd> to use <kbd>DrawGraphicalBar</kbd>, this means you can make an icon-based HP system that each
tile byte holds a set amount of HP, for example, in the <i>Legend of Zelda</i> series starting in <i>Ocarina of Time</i>, you can have each heart containing 4 pieces representing each 1 HP.</p></li>

<li><p>It is best to avoid having any end tiles holding the same number of pieces as the middle, although it still works, it is less optimized as the routine <kbd>DrawGraphicalBar</kbd> (including <kbd>DrawGraphicalBarSubtractionLoopEdition</kbd>)
itself only takes a value and represent them as each bytes capped at their maximum. Therefore if you're planning to have 8 pieces for both left and right ends, and have 7 middle bytes also
having 8 pieces at the max, it is better to have both end tiles set to 0 pieces and have 9 middle tiles holding 8 pieces, here is what it looks like on a full bar:<br><br>

Less optimized:
<div class="CodeBlock" style="width: 401px; height: 84px;"><pre><span style="color: cyan">!Scratchram_GraphicalBar_LeftEndPiece:       $08</span>
<span style="color: #00C000">!Scratchram_GraphicalBar_MiddlePiece:        $08</span>
<span style="color: red">!Scratchram_GraphicalBar_RightEndPiece:      $08</span>
<span style="color: #00C000">!Scratchram_GraphicalBar_TempLength:         $07</span>
RAM address $00-$01:                         $0048 (72)</pre></div>
Result:
<table>
<tr>
<td style="background-color: cyan"><span style="color: black"><kbd>+0</kbd></span></td>
<td style="background-color: #00C000"><kbd>+1</kbd></td>
<td style="background-color: #00C000"><kbd>+2</kbd></td>
<td style="background-color: #00C000"><kbd>+3</kbd></td>
<td style="background-color: #00C000"><kbd>+4</kbd></td>
<td style="background-color: #00C000"><kbd>+5</kbd></td>
<td style="background-color: #00C000"><kbd>+6</kbd></td>
<td style="background-color: #00C000"><kbd>+7</kbd></td>
<td style="background-color: red"><kbd>+8</kbd></td>
</tr>
<tr>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
</tr>
</table>
Vs optimized:
<div class="CodeBlock" style="width: 401px; height: 84px;"><pre><span style="color: cyan"><s>!Scratchram_GraphicalBar_LeftEndPiece:       $00</s></span>
<span style="color: #00C000">!Scratchram_GraphicalBar_MiddlePiece:        $08</span>
<span style="color: red"><s>!Scratchram_GraphicalBar_RightEndPiece:      $00</s></span>
<span style="color: #00C000">!Scratchram_GraphicalBar_TempLength:         $09</span>
RAM address $00-$01:                         $0048 (72)</pre></div>
Result:
<table>
<tr>
<td style="background-color: #00C000"><kbd>+0</kbd></td>
<td style="background-color: #00C000"><kbd>+1</kbd></td>
<td style="background-color: #00C000"><kbd>+2</kbd></td>
<td style="background-color: #00C000"><kbd>+3</kbd></td>
<td style="background-color: #00C000"><kbd>+4</kbd></td>
<td style="background-color: #00C000"><kbd>+5</kbd></td>
<td style="background-color: #00C000"><kbd>+6</kbd></td>
<td style="background-color: #00C000"><kbd>+7</kbd></td>
<td style="background-color: #00C000"><kbd>+8</kbd></td>
</tr>
<tr>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
<td style="background-color: orange"><kbd>$08</kbd></td>
</tr>
</table>
The only difference is the FillAmount &rightarrow; TileNumber conversion <kbd>ConvertBarFillAmountToTiles</kbd> (and the doublebar version) that utilizes the tile number you need
to change (Left end have 9 tiles with values 0-8 same as middle's 0-8 but uses a different array tiles to display a outlined-left edge and same goes to the right end). However,
the tile converter does not recognize if the first and last tile are meant to be end tiles to have different graphic than the middle, so just before calling the tile converter,
set the end tiles to be the same number of pieces for middle, and subtract the number of middle tiles by how many end tiles you are using (say 2) so that the end tiles don't use
the same table graphic as middle and cause cutoff-ended bar.
<div class="CodeBlock" style="height: 169px; width: 991px;"><pre>	;[...]
	JSL GraphicalBarELITE_DrawGraphicalBarSubtractionLoopEdition	;&gt;get bar values.
	LDA #$08							;\Middle tiles first and last replaced with end tiles.
	STA !Scratchram_GraphicalBar_LeftEndPiece			;|
	STA !Scratchram_GraphicalBar_RightEndPiece			;|
	LDA !Scratchram_GraphicalBar_TempLength				;|
	SEC								;|
	SBC #$02							;|&gt;Left end + Right end = 2 end tiles
	STA !Scratchram_GraphicalBar_TempLength				;/
	JSL GraphicalBarConvertToTile_ConvertBarFillAmountToTiles	;&gt;Convert tiles (end tiles recognized).
	;[...]</pre></div><br><br>

</p></li>
<li><p>You might've noticed the define <span class="NoLineBreak"><kbd>!Settings_GraphicalBar_IndexSize</kbd></span> found in <kbd>GraphicalBarDefines.asm</kbd>, I left that there in for some rare cases anyone
would need a bar that is more than 255 tile bytes long (So a 16-bit addressing was needed).</p></li>

<li><p>Be careful when you call the routine <kbd>WriteBarToHUD</kbd> (and <kbd>WriteBarToHUDLeftwards</kbd>), as because this is multi-bytes based, it will write from
<span class="NoLineBreak"><kbd>!Default_GraphicalBarPosition</kbd></span> to <span class="NoLineBreak"><kbd>!Default_GraphicalBarPosition+((NumberOfTiles-1)*!StatusBarFormat)</kbd></span> address. Thus if you place the bar at RAM address
<kbd>$0F2F</kbd>, the address bytes beyond that (which is non-status-bar-related data, from timer data, scores, then an unused RAM area ($0F3A) and so on) gets overwritten.</p></li>

<ul><li><p>However, if you are using the &ldquo;extend leftwards&rdquo; (not to be confused with a leftwards <span style="font-weight: bold;">filling bar</span>; the bar that extends leftwards as you increase the length),
the address write range is <kbd>DesiredLastTilePos-((NumberOfTiles-1)*!StatusBarFormat)</kbd> to <kbd>DesiredLastTilePos</kbd>, so be careful not to have the bar data be written past the starting RAM
address of the status bar (avoid placing the <kbd>DesiredLastTilePos</kbd> that would cause placing the tiles before the first byte of the status bar tiles).</p></li></ul>

<li>When writing stripe image <b>every frame</b> during levels, make sure you don't write them during the &ldquo;COURSE CLEAR!&rdquo; text (the text appears when <kbd>JSL $05CBFF</kbd> is executed) or during message box, as it
may cause graphical glitches (or even graphic corruptions). Easiest way is to check RAM <kbd>$1493</kbd> like so:
<div class="CodeBlock" style="width: 946px; height: 171px;"><pre>
LDA $1493|!addr		;&gt;Goal timer
ORA $1426|!addr		;&gt;Message box (to me, I did experienced screen went black except for the layer 3, I kept this here anyways just in case)
BEQ .SafeToWrite	;&gt;0 = None of the above are active, Nonzero: Any of above are active.
.NotSafeTo
	;[...]
	RTL
.SafeToWrite
	;Code to write your bar here
	;[...]
	RTL</pre></div>

</li><br>
</ul>
<hr>
<h2><a href="#CreditsBack" id="Credits">^</a>Credits</h2>
<ul>
<li><a href="https://www.smwcentral.net/?p=profile&id=8691">Akaginite</a>, for making the math routines</li>
<li><a href="https://www.smwcentral.net/?p=profile&id=4842">Ladida</a>, I borrowed a few lines of her code (and asked for permission):<br>
<img src="readme_files/LadidaPermission.png"></li>
<li><a href="https://www.smwcentral.net/?p=profile&id=41003">JamesD28</a>, of a sprite crashing bug experienced (<kbd>%GetDrawInfo()</kbd> uses a &ldquo;destroy return address&rdquo; (you pull out bytes pushed by the JSL/JSR just before the RTL/RTS, so that it exits out multiple subroutines upon hitting a RTL/RTS))</li>
<li><a href="https://www.smwcentral.net/?p=profile&id=36308">KevinM</a> and <a href="https://www.smwcentral.net/?p=profile&id=12344">LX5</a>, for some knowledge of the technical bits of OAM writing.</li>
<li><a href="https://www.smwcentral.net/?p=profile&id=3879">dahnamics</a>, for the Giant Masked Koopa boss sprite</li>
<li><a href="https://www.w3schools.com/">W3Schools</a> and <a href="https://stackoverflow.com">stackoverflow</a><sup><a href="https://stackoverflow.com/questions/11409895/whats-the-most-elegant-way-to-cap-a-number-to-a-segment">[1]</a></sup>, for making a tutorial on how to make HTML and javascript codes.</li>
<li><a href="https://developer.mozilla.org/en-US/">MDN web docs (by mozilla)</a>, for documenting a lot on JS</li>
</ul>

<script>
//These makes all <pre>...</pre> have an effect that double-clicking will select all the text
//in it, to make it easy to copy code and paste it in your ASM stuff.
//
//Credit:
// https://keestalkstech.com/2014/04/click-to-select-all-on-the-pre-element/
// https://www.sanwebe.com/2014/04/select-all-text-in-element-on-click
document.addEventListener('dblclick', e => {
  let pre = getClosest(e.target, "PRE");
  if (pre && e.ctrlKey) {
    let range = new Range();
    range.selectNodeContents(pre);
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(range);
  }
});

function getClosest(el, tagName) {
  tagName = tagName && tagName.toUpperCase();

  if (!tagName || !el)
    return null;

  do
    if (el.nodeName === tagName)
      return el;
  while (el = el.parentNode);

  return null;
}
	DrawRepeatedSubtractionSVG()
	
	
	function DrawRepeatedSubtractionSVG() {
		let SVGGraphToDisplay = document.getElementById("SVG_RepeatedSubtractionExplained")
		
		//Amount Settings
			let GraphicalBarLeftEndPiece = 3n
			let GraphicalBarMiddlePiece = 8n
			let GraphicalBarRightEndPiece = 3n
			let GraphicalBarMiddleLength = 4n
			
			let InputAmountFilled = 14n
		//Display positioning settings
			let FilledAmountLeftMargin = 10n
			let TileProcessYPositionRow_Spacing = 130n
			let FilledPieceXPosition = FilledAmountLeftMargin + 10n
			let VerticalLineXPos = FilledPieceXPosition + (InputAmountFilled * 10n) + 30n
		//Don't touch
		{
			//Starting fill amount
			let OutputProcessYPositionStart = 100n
			
			let StartingFillAmountText = createSVGElement("text")
			StartingFillAmountText.setAttribute("x", FilledAmountLeftMargin.toString(10))
			StartingFillAmountText.setAttribute("y", "30")
			StartingFillAmountText.setAttribute("font-family", "monospace")
			StartingFillAmountText.appendChild(document.createTextNode("$00-$01 fill amount:"))
			SVGGraphToDisplay.appendChild(StartingFillAmountText)
			
			for (let Countdown = InputAmountFilled; Countdown > 0n; Countdown--) {
				let Xpositioning = FilledPieceXPosition + ((InputAmountFilled - Countdown) * 10n)
				
				let Piece = createSVGElement("rect")
				Piece.setAttribute("x", Xpositioning.toString(10))
				Piece.setAttribute("y", "50")
				Piece.setAttribute("width", "10")
				Piece.setAttribute("height", "30")
				Piece.setAttribute("stroke-width", "1")
				Piece.setAttribute("stroke", "#000000")
				Piece.setAttribute("fill", "#00C000")
				SVGGraphToDisplay.appendChild(Piece)
			}
			
			let FillAmountNumberTextDisplay = createSVGElement("text")
			FillAmountNumberTextDisplay.setAttribute("x", (FilledAmountLeftMargin + (InputAmountFilled * 10n) + 15n).toString(10))
			FillAmountNumberTextDisplay.setAttribute("y", "70")
			FillAmountNumberTextDisplay.setAttribute("font-family", "monospace")
			FillAmountNumberTextDisplay.appendChild(document.createTextNode(InputAmountFilled.toString(10)))
			SVGGraphToDisplay.appendChild(FillAmountNumberTextDisplay)
			
			let VerticalLine = createSVGElement("line")
			VerticalLine.setAttribute("x1", VerticalLineXPos.toString(10))
			VerticalLine.setAttribute("y1", "0")
			VerticalLine.setAttribute("x2", VerticalLineXPos.toString(10))
			VerticalLine.setAttribute("y2", "1000")
			VerticalLine.setAttribute("stroke", "black")
			SVGGraphToDisplay.appendChild(VerticalLine)
		}
		{
			//Each row representing each tile byte getting filled.
			let RemainingFill = InputAmountFilled
			let TileProcessYPositionRow = 100n
			let CurrentFillXPos = VerticalLineXPos + 20n

			//Show subtraction from the remaining fill amount
			//Declare functions
				function RepeatedSubtractionDisplay({Max = 0n}) {
					let HorizontalLine = createSVGElement("line")
					HorizontalLine.setAttribute("x1", "0")
					HorizontalLine.setAttribute("y1", TileProcessYPositionRow.toString(10))
					HorizontalLine.setAttribute("x2", "1000")
					HorizontalLine.setAttribute("y2", TileProcessYPositionRow.toString(10))
					HorizontalLine.setAttribute("stroke", "black")
					SVGGraphToDisplay.appendChild(HorizontalLine)
					
					let RemainingFillSubtracted = RemainingFill-Max
					
					let SubtractionText = createSVGElement("text")
					SubtractionText.setAttribute("x", FilledAmountLeftMargin.toString(10))
					SubtractionText.setAttribute("y", (TileProcessYPositionRow + 20n).toString(10))
					SubtractionText.setAttribute("font-family", "monospace")
					
					let Text = ""
					if (RemainingFillSubtracted < 0n) {
						SubtractionText.setAttribute("fill", "#900000")
						Text += RemainingFill.toString(10) + " - " + Max.toString(10) + " = (" + RemainingFillSubtracted + ")  0"
					} else {
						Text += RemainingFill.toString(10) + " - " + Max.toString(10) + " = " + RemainingFillSubtracted
					}
					SubtractionText.appendChild(document.createTextNode(Text))
					
					SVGGraphToDisplay.appendChild(SubtractionText)
					
					//Graphical fill changes
					if (RemainingFillSubtracted < 0) { //Below max
						for (let Countdown = Max, FillLeft = RemainingFill; Countdown > 0n; Countdown--, FillLeft--) {
							let Xpositioning = FilledPieceXPosition + ((Max - Countdown) * 10n)
							
							let Piece = createSVGElement("rect")
							Piece.setAttribute("x", Xpositioning.toString(10))
							Piece.setAttribute("width", "10")
							Piece.setAttribute("height", "30")
							Piece.setAttribute("stroke-width", "1")
							
							if (FillLeft <= 0n)  { //Below by...
								Piece.setAttribute("stroke-dasharray", "2")
								Piece.setAttribute("fill", "rgb(0,0,0,0)")
								Piece.setAttribute("y", (TileProcessYPositionRow+50n).toString(10))
							} else { //Remaining fill
								Piece.setAttribute("stroke", "#000000")
								Piece.setAttribute("fill", "#B5E61D")
								Piece.setAttribute("y", (TileProcessYPositionRow+40n).toString(10))
							}
							
							Piece.setAttribute("stroke", "#000000")
							SVGGraphToDisplay.appendChild(Piece)
						}
						
					} else {
						for (let Countdown = RemainingFill, Subtracted = RemainingFillSubtracted; Countdown > 0n; Countdown--, Subtracted--) {
							let Xpositioning = FilledPieceXPosition + ((RemainingFill - Countdown) * 10n)
							
							let FillColor = "#00C000"
							let Shifted = 0n
							if (Subtracted <= 0n) {//Boxes that are removed.
								FillColor = "#B5E61D"
								Shifted = -10n
							}
							
							let Piece = createSVGElement("rect")
							Piece.setAttribute("x", Xpositioning.toString(10))
							Piece.setAttribute("y", (TileProcessYPositionRow+50n+Shifted).toString(10))
							Piece.setAttribute("width", "10")
							Piece.setAttribute("height", "30")
							Piece.setAttribute("stroke-width", "1")
							Piece.setAttribute("stroke", "#000000")
							
							Piece.setAttribute("fill", FillColor)
							SVGGraphToDisplay.appendChild(Piece)
						}
					}
				}
				function RepeatedSubtractionFills(Filled) {
					let TempFillAmount = Filled
					let Xpositioning = FilledPieceXPosition+VerticalLineXPos+20n
					let CurrentFillByteIndex = 0n
					
					function GeneratePieces() {
						let PieceFilledOrNot = createSVGElement("rect")
						PieceFilledOrNot.setAttribute("x", (Xpositioning).toString(10))
						PieceFilledOrNot.setAttribute("y", (TileProcessYPositionRow+30n).toString(10))
						PieceFilledOrNot.setAttribute("width", "10")
						PieceFilledOrNot.setAttribute("height", "30")
						PieceFilledOrNot.setAttribute("stroke-width", "1")
						PieceFilledOrNot.setAttribute("stroke", "#000000")
						
						let FillColor = "#00C000"
						if (TempFillAmount == 0n) {
							FillColor = "#808080"
						}
						
						PieceFilledOrNot.setAttribute("fill", FillColor)
						SVGGraphToDisplay.appendChild(PieceFilledOrNot)
						
						TempFillAmount--
						if (TempFillAmount < 0n) {
							TempFillAmount = 0
						}
						Xpositioning += 10n
					}
					function DisplayCurrentlyProcessedTileByte(NumberOfPieces) {
						if (CurrentFillByteIndex == FillByteTableIndex_RecentlyFilled) {
							let WidthOfBox = (NumberOfPieces*10n)+10n
							let BoxXPos = Xpositioning-5n
							let MidPointXPos = BoxXPos + (WidthOfBox/2n)
							
							let ProcessingText = createSVGElement("text")
							ProcessingText.setAttribute("x", MidPointXPos.toString(10))
							ProcessingText.setAttribute("y", (TileProcessYPositionRow+20n).toString(10))
							ProcessingText.setAttribute("fill", "#FFFF00")
							ProcessingText.setAttribute("text-anchor", "middle")
							ProcessingText.appendChild(document.createTextNode("Processing"))
							ProcessingText.setAttribute("font-family", "monospace")
							SVGGraphToDisplay.appendChild(ProcessingText)
							
							let HighlightedBox = createSVGElement("rect")
							HighlightedBox.setAttribute("x", BoxXPos.toString(10))
							HighlightedBox.setAttribute("y", (TileProcessYPositionRow+25n).toString(10))
							HighlightedBox.setAttribute("width", WidthOfBox.toString(10))
							HighlightedBox.setAttribute("height", "40")
							HighlightedBox.setAttribute("fill", "rgb(0,0,0,0)")
							HighlightedBox.setAttribute("stroke-width", "2")
							HighlightedBox.setAttribute("stroke", "#FFFF00")
							SVGGraphToDisplay.appendChild(HighlightedBox)
						}
					}
					function ByteTypeLabeling({ByteType = "", MiddleCount = 0n}) {
						let NameColor = {
							"Left end": "cyan",
							"Middle": "#00FF00",
							"Right end": "red"
						}
						let ByteTypeText = createSVGElement("text")
						ByteTypeText.setAttribute("transform", "translate(" + (Xpositioning+5n).toString(10) + ", " + (TileProcessYPositionRow+70n).toString(10) + ")rotate(45)")
						
						ByteTypeText.setAttribute("fill", NameColor[ByteType])
						ByteTypeText.setAttribute("font-family", "monospace")
						let Text = ByteType
						if (ByteType == "Middle") {
							Text += " " + MiddleCount.toString(10)
						}
						ByteTypeText.appendChild(document.createTextNode(Text))
						SVGGraphToDisplay.appendChild(ByteTypeText)
					}
					if (GraphicalBarLeftEndPiece > 0n) {
						ByteTypeLabeling({ByteType: "Left end"})
						DisplayCurrentlyProcessedTileByte(GraphicalBarLeftEndPiece)
						for (let Countdown = GraphicalBarLeftEndPiece; Countdown > 0n; Countdown--) {
							GeneratePieces()
						}
						Xpositioning += 10n
						CurrentFillByteIndex++
					}
					for (let MiddleCountDown = GraphicalBarMiddleLength; MiddleCountDown > 0n; MiddleCountDown--) {
						ByteTypeLabeling({ByteType: "Middle", MiddleCount: GraphicalBarMiddleLength - MiddleCountDown + 1n})
						DisplayCurrentlyProcessedTileByte(GraphicalBarMiddlePiece)
						for (let FillCountDownPerTile = GraphicalBarMiddlePiece; FillCountDownPerTile > 0n; FillCountDownPerTile--) {
							GeneratePieces()
						}
						Xpositioning += 10n
						CurrentFillByteIndex++
					}
					if (GraphicalBarRightEndPiece > 0n) {
						ByteTypeLabeling({ByteType: "Right end"})
						DisplayCurrentlyProcessedTileByte(GraphicalBarRightEndPiece)
						for (let Countdown = GraphicalBarRightEndPiece; Countdown > 0n; Countdown--) {
							GeneratePieces()
						}
						Xpositioning += 10n
						CurrentFillByteIndex++
					}
				}
				function NextTile({Max = 0n}) {
					RemainingFill -= Max
					if (RemainingFill < 0n) {
						RemainingFill = 0n
					}
					TileProcessYPositionRow += TileProcessYPositionRow_Spacing
					FillByteTableIndex_RecentlyFilled++
				}
			let StartingFillAmountOutputTable = 0n
			function IncreaseFillByteTable(IncreaseBy) {
				StartingFillAmountOutputTable += IncreaseBy
				if (StartingFillAmountOutputTable > InputAmountFilled) {
					StartingFillAmountOutputTable = InputAmountFilled
				}
			}
			
			let FillByteTableIndex_RecentlyFilled = 0n
			
			if (GraphicalBarLeftEndPiece > 0n) { //Left end
				RepeatedSubtractionDisplay({Max: GraphicalBarLeftEndPiece})
				IncreaseFillByteTable(GraphicalBarLeftEndPiece)
				RepeatedSubtractionFills(StartingFillAmountOutputTable)
				NextTile({Max: GraphicalBarLeftEndPiece})
			}
			for (let MiddleLeft = GraphicalBarMiddleLength; MiddleLeft > 0n; MiddleLeft--) {
				RepeatedSubtractionDisplay({Max: GraphicalBarMiddlePiece})
				IncreaseFillByteTable(GraphicalBarMiddlePiece)
				RepeatedSubtractionFills(StartingFillAmountOutputTable)
				NextTile({Max: GraphicalBarMiddlePiece})
			}
			if (GraphicalBarRightEndPiece > 0n) {
				RepeatedSubtractionDisplay({Max: GraphicalBarRightEndPiece})
				IncreaseFillByteTable(GraphicalBarRightEndPiece)
				RepeatedSubtractionFills(StartingFillAmountOutputTable)
				NextTile({Max: GraphicalBarRightEndPiece})
			}
		}
	}

	function createSVGElement(tag) { //https://stackoverflow.com/questions/57894500/why-is-it-necessary-to-use-document-createelementns-when-adding-svg-tags-to
		let SVGEle = document.createElementNS('http://www.w3.org/2000/svg', tag)
		SVGEle.setAttribute("shape-rendering", "crispEdges")
		return SVGEle
	}
</script>